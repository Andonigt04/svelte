import {
  __export,
  __publicField,
  __require
} from "./chunk-A23LVNQA.js";

// node_modules/@storybook/global/dist/index.mjs
var scope = (() => {
  let win;
  if (typeof window !== "undefined") {
    win = window;
  } else if (typeof globalThis !== "undefined") {
    win = globalThis;
  } else if (typeof global !== "undefined") {
    win = global;
  } else if (typeof self !== "undefined") {
    win = self;
  } else {
    win = {};
  }
  return win;
})();

// node_modules/@storybook/core/dist/client-logger/index.js
var u = Object.defineProperty;
var a = (e2, o3) => u(e2, "name", { value: o3, configurable: true });
var y = (() => {
  let e2;
  return typeof window < "u" ? e2 = window : typeof globalThis < "u" ? e2 = globalThis : typeof global < "u" ? e2 = global : typeof self < "u" ? e2 = self : e2 = {}, e2;
})();
var { LOGLEVEL: b } = y;
var t = {
  trace: 1,
  debug: 2,
  info: 3,
  warn: 4,
  error: 5,
  silent: 10
};
var L = b;
var i = t[L] || t.info;
var s = {
  trace: a((e2, ...o3) => {
    i <= t.trace && console.trace(e2, ...o3);
  }, "trace"),
  debug: a((e2, ...o3) => {
    i <= t.debug && console.debug(e2, ...o3);
  }, "debug"),
  info: a((e2, ...o3) => {
    i <= t.info && console.info(e2, ...o3);
  }, "info"),
  warn: a((e2, ...o3) => {
    i <= t.warn && console.warn(e2, ...o3);
  }, "warn"),
  error: a((e2, ...o3) => {
    i <= t.error && console.error(e2, ...o3);
  }, "error"),
  log: a((e2, ...o3) => {
    i < t.silent && console.log(e2, ...o3);
  }, "log")
};
var c = /* @__PURE__ */ new Set();
var n = a((e2) => (o3, ...l3) => {
  if (!c.has(o3))
    return c.add(o3), s[e2](o3, ...l3);
}, "once");
n.clear = () => c.clear();
n.trace = n("trace");
n.debug = n("debug");
n.info = n("info");
n.warn = n("warn");
n.error = n("error");
n.log = n("log");
var m = n("warn");
var r = a((e2) => (...o3) => {
  let l3 = [];
  if (o3.length) {
    let f8 = /<span\s+style=(['"])([^'"]*)\1\s*>/gi, p6 = /<\/span>/gi, d3;
    for (l3.push(o3[0].replace(f8, "%c").replace(p6, "%c")); d3 = f8.exec(o3[0]); )
      l3.push(d3[2]), l3.push("");
    for (let g3 = 1; g3 < o3.length; g3++)
      l3.push(o3[g3]);
  }
  s[e2].apply(s, l3);
}, "pretty");
r.trace = r("trace");
r.debug = r("debug");
r.info = r("info");
r.warn = r("warn");
r.error = r("error");

// node_modules/@storybook/core/dist/core-events/index.js
var core_events_exports = {};
__export(core_events_exports, {
  ARGTYPES_INFO_REQUEST: () => RE,
  ARGTYPES_INFO_RESPONSE: () => SE,
  CHANNEL_CREATED: () => T,
  CHANNEL_WS_DISCONNECT: () => S,
  CONFIG_ERROR: () => N,
  CREATE_NEW_STORYFILE_REQUEST: () => O,
  CREATE_NEW_STORYFILE_RESPONSE: () => A,
  CURRENT_STORY_WAS_SET: () => r2,
  DOCS_PREPARED: () => D,
  DOCS_RENDERED: () => I,
  FILE_COMPONENT_SEARCH_REQUEST: () => C,
  FILE_COMPONENT_SEARCH_RESPONSE: () => o,
  FORCE_REMOUNT: () => P,
  FORCE_RE_RENDER: () => L2,
  GLOBALS_UPDATED: () => U,
  NAVIGATE_URL: () => G,
  PLAY_FUNCTION_THREW_EXCEPTION: () => a2,
  PRELOAD_ENTRIES: () => t2,
  PREVIEW_BUILDER_PROGRESS: () => e,
  PREVIEW_KEYDOWN: () => W,
  REGISTER_SUBSCRIPTION: () => d,
  REQUEST_WHATS_NEW_DATA: () => z,
  RESET_STORY_ARGS: () => H,
  RESULT_WHATS_NEW_DATA: () => J,
  SAVE_STORY_REQUEST: () => EE,
  SAVE_STORY_RESPONSE: () => _E,
  SELECT_STORY: () => l,
  SET_CONFIG: () => i2,
  SET_CURRENT_STORY: () => p,
  SET_FILTER: () => M,
  SET_GLOBALS: () => u2,
  SET_INDEX: () => F,
  SET_STORIES: () => s2,
  SET_WHATS_NEW_CACHE: () => Z,
  SHARED_STATE_CHANGED: () => c2,
  SHARED_STATE_SET: () => g,
  STORIES_COLLAPSE_ALL: () => y2,
  STORIES_EXPAND_ALL: () => h,
  STORY_ARGS_UPDATED: () => Q,
  STORY_CHANGED: () => f2,
  STORY_ERRORED: () => x,
  STORY_INDEX_INVALIDATED: () => m2,
  STORY_MISSING: () => V,
  STORY_PREPARED: () => w,
  STORY_RENDERED: () => X,
  STORY_RENDER_PHASE_CHANGED: () => B,
  STORY_SPECIFIED: () => q,
  STORY_THREW_EXCEPTION: () => b2,
  STORY_UNCHANGED: () => K,
  TELEMETRY_ERROR: () => v,
  TESTING_MODULE_CANCEL_TEST_RUN_REQUEST: () => rE,
  TESTING_MODULE_CANCEL_TEST_RUN_RESPONSE: () => DE,
  TESTING_MODULE_CRASH_REPORT: () => TE,
  TESTING_MODULE_PROGRESS_REPORT: () => NE,
  TESTING_MODULE_RUN_ALL_REQUEST: () => AE,
  TESTING_MODULE_RUN_REQUEST: () => OE,
  TESTING_MODULE_WATCH_MODE_REQUEST: () => IE,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: () => $,
  UNHANDLED_ERRORS_WHILE_PLAYING: () => Y,
  UPDATE_GLOBALS: () => j,
  UPDATE_QUERY_PARAMS: () => k,
  UPDATE_STORY_ARGS: () => n2,
  default: () => R
});
var _ = ((E2) => (E2.CHANNEL_WS_DISCONNECT = "channelWSDisconnect", E2.CHANNEL_CREATED = "channelCreated", E2.CONFIG_ERROR = "configError", E2.STORY_INDEX_INVALIDATED = "storyIndexInvalidated", E2.STORY_SPECIFIED = "storySpecified", E2.SET_CONFIG = "setConfig", E2.SET_STORIES = "setStories", E2.SET_INDEX = "setIndex", E2.SET_CURRENT_STORY = "setCurrentStory", E2.CURRENT_STORY_WAS_SET = "currentStoryWasSet", E2.FORCE_RE_RENDER = "forceReRender", E2.FORCE_REMOUNT = "forceRemount", E2.PRELOAD_ENTRIES = "preloadStories", E2.STORY_PREPARED = "storyPrepared", E2.DOCS_PREPARED = "docsPrepared", E2.STORY_CHANGED = "storyChanged", E2.STORY_UNCHANGED = "storyUnchanged", E2.STORY_RENDERED = "storyRendered", E2.STORY_MISSING = "storyMissing", E2.STORY_ERRORED = "storyErrored", E2.STORY_THREW_EXCEPTION = "storyThrewException", E2.STORY_RENDER_PHASE_CHANGED = "storyRenderPhaseChanged", E2.PLAY_FUNCTION_THREW_EXCEPTION = "playFunctionThrewException", E2.UNHANDLED_ERRORS_WHILE_PLAYING = "unhandledErrorsWhilePlaying", E2.UPDATE_STORY_ARGS = "updateStoryArgs", E2.STORY_ARGS_UPDATED = "storyArgsUpdated", E2.RESET_STORY_ARGS = "resetStoryArgs", E2.SET_FILTER = "setFilter", E2.SET_GLOBALS = "setGlobals", E2.UPDATE_GLOBALS = "updateGlobals", E2.GLOBALS_UPDATED = "globalsUpdated", E2.REGISTER_SUBSCRIPTION = "registerSubscription", E2.PREVIEW_KEYDOWN = "previewKeydown", E2.PREVIEW_BUILDER_PROGRESS = "preview_builder_progress", E2.SELECT_STORY = "selectStory", E2.STORIES_COLLAPSE_ALL = "storiesCollapseAll", E2.STORIES_EXPAND_ALL = "storiesExpandAll", E2.DOCS_RENDERED = "docsRendered", E2.SHARED_STATE_CHANGED = "sharedStateChanged", E2.SHARED_STATE_SET = "sharedStateSet", E2.NAVIGATE_URL = "navigateUrl", E2.UPDATE_QUERY_PARAMS = "updateQueryParams", E2.REQUEST_WHATS_NEW_DATA = "requestWhatsNewData", E2.RESULT_WHATS_NEW_DATA = "resultWhatsNewData", E2.SET_WHATS_NEW_CACHE = "setWhatsNewCache", E2.TOGGLE_WHATS_NEW_NOTIFICATIONS = "toggleWhatsNewNotifications", E2.TELEMETRY_ERROR = "telemetryError", E2.FILE_COMPONENT_SEARCH_REQUEST = "fileComponentSearchRequest", E2.FILE_COMPONENT_SEARCH_RESPONSE = "fileComponentSearchResponse", E2.SAVE_STORY_REQUEST = "saveStoryRequest", E2.SAVE_STORY_RESPONSE = "saveStoryResponse", E2.ARGTYPES_INFO_REQUEST = "argtypesInfoRequest", E2.ARGTYPES_INFO_RESPONSE = "argtypesInfoResponse", E2.CREATE_NEW_STORYFILE_REQUEST = "createNewStoryfileRequest", E2.CREATE_NEW_STORYFILE_RESPONSE = "createNewStoryfileResponse", E2.TESTING_MODULE_CRASH_REPORT = "testingModuleCrashReport", E2.TESTING_MODULE_PROGRESS_REPORT = "testingModuleProgressReport", E2.TESTING_MODULE_RUN_REQUEST = "testingModuleRunRequest", E2.TESTING_MODULE_RUN_ALL_REQUEST = "testingModuleRunAllRequest", E2.TESTING_MODULE_CANCEL_TEST_RUN_REQUEST = "testingModuleCancelTestRunRequest", E2.TESTING_MODULE_CANCEL_TEST_RUN_RESPONSE = "testingModuleCancelTestRunResponse", E2.TESTING_MODULE_WATCH_MODE_REQUEST = "testingModuleWatchModeRequest", E2))(_ || {});
var R = _;
var {
  CHANNEL_WS_DISCONNECT: S,
  CHANNEL_CREATED: T,
  CONFIG_ERROR: N,
  CREATE_NEW_STORYFILE_REQUEST: O,
  CREATE_NEW_STORYFILE_RESPONSE: A,
  CURRENT_STORY_WAS_SET: r2,
  DOCS_PREPARED: D,
  DOCS_RENDERED: I,
  FILE_COMPONENT_SEARCH_REQUEST: C,
  FILE_COMPONENT_SEARCH_RESPONSE: o,
  FORCE_RE_RENDER: L2,
  FORCE_REMOUNT: P,
  GLOBALS_UPDATED: U,
  NAVIGATE_URL: G,
  PLAY_FUNCTION_THREW_EXCEPTION: a2,
  UNHANDLED_ERRORS_WHILE_PLAYING: Y,
  PRELOAD_ENTRIES: t2,
  PREVIEW_BUILDER_PROGRESS: e,
  PREVIEW_KEYDOWN: W,
  REGISTER_SUBSCRIPTION: d,
  RESET_STORY_ARGS: H,
  SELECT_STORY: l,
  SET_CONFIG: i2,
  SET_CURRENT_STORY: p,
  SET_FILTER: M,
  SET_GLOBALS: u2,
  SET_INDEX: F,
  SET_STORIES: s2,
  SHARED_STATE_CHANGED: c2,
  SHARED_STATE_SET: g,
  STORIES_COLLAPSE_ALL: y2,
  STORIES_EXPAND_ALL: h,
  STORY_ARGS_UPDATED: Q,
  STORY_CHANGED: f2,
  STORY_ERRORED: x,
  STORY_INDEX_INVALIDATED: m2,
  STORY_MISSING: V,
  STORY_PREPARED: w,
  STORY_RENDER_PHASE_CHANGED: B,
  STORY_RENDERED: X,
  STORY_SPECIFIED: q,
  STORY_THREW_EXCEPTION: b2,
  STORY_UNCHANGED: K,
  UPDATE_GLOBALS: j,
  UPDATE_QUERY_PARAMS: k,
  UPDATE_STORY_ARGS: n2,
  REQUEST_WHATS_NEW_DATA: z,
  RESULT_WHATS_NEW_DATA: J,
  SET_WHATS_NEW_CACHE: Z,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: $,
  TELEMETRY_ERROR: v,
  SAVE_STORY_REQUEST: EE,
  SAVE_STORY_RESPONSE: _E,
  ARGTYPES_INFO_REQUEST: RE,
  ARGTYPES_INFO_RESPONSE: SE,
  TESTING_MODULE_CRASH_REPORT: TE,
  TESTING_MODULE_PROGRESS_REPORT: NE,
  TESTING_MODULE_RUN_REQUEST: OE,
  TESTING_MODULE_RUN_ALL_REQUEST: AE,
  TESTING_MODULE_CANCEL_TEST_RUN_REQUEST: rE,
  TESTING_MODULE_CANCEL_TEST_RUN_RESPONSE: DE,
  TESTING_MODULE_WATCH_MODE_REQUEST: IE
} = _;

// node_modules/@storybook/core/dist/channels/index.js
var Qt = Object.create;
var st = Object.defineProperty;
var te = Object.getOwnPropertyDescriptor;
var ee = Object.getOwnPropertyNames;
var re = Object.getPrototypeOf;
var ne = Object.prototype.hasOwnProperty;
var i3 = (t4, e2) => st(t4, "name", { value: e2, configurable: true });
var U2 = ((t4) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(t4, {
  get: (e2, r4) => (typeof __require < "u" ? __require : e2)[r4]
}) : t4)(function(t4) {
  if (typeof __require < "u") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + t4 + '" is not supported');
});
var oe = (t4, e2) => () => (e2 || t4((e2 = { exports: {} }).exports, e2), e2.exports);
var ae = (t4, e2, r4, n3) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function")
    for (let a5 of ee(e2))
      !ne.call(t4, a5) && a5 !== r4 && st(t4, a5, { get: () => e2[a5], enumerable: !(n3 = te(e2, a5)) || n3.enumerable });
  return t4;
};
var ie = (t4, e2, r4) => (r4 = t4 != null ? Qt(re(t4)) : {}, ae(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e2 || !t4 || !t4.__esModule ? st(r4, "default", { value: t4, enumerable: true }) : r4,
  t4
));
var At = oe((Ot2, ct2) => {
  (function(t4) {
    if (typeof Ot2 == "object" && typeof ct2 < "u")
      ct2.exports = t4();
    else if (typeof define == "function" && define.amd)
      define([], t4);
    else {
      var e2;
      typeof window < "u" ? e2 = window : typeof global < "u" ? e2 = global : typeof self < "u" ? e2 = self : e2 = this, e2.memoizerific = t4();
    }
  })(function() {
    var t4, e2, r4;
    return i3(function n3(a5, l3, s4) {
      function c3(u5, p6) {
        if (!l3[u5]) {
          if (!a5[u5]) {
            var d3 = typeof U2 == "function" && U2;
            if (!p6 && d3) return d3(u5, true);
            if (o3) return o3(u5, true);
            var g3 = new Error("Cannot find module '" + u5 + "'");
            throw g3.code = "MODULE_NOT_FOUND", g3;
          }
          var y4 = l3[u5] = { exports: {} };
          a5[u5][0].call(y4.exports, function(m4) {
            var v6 = a5[u5][1][m4];
            return c3(v6 || m4);
          }, y4, y4.exports, n3, a5, l3, s4);
        }
        return l3[u5].exports;
      }
      i3(c3, "s");
      for (var o3 = typeof U2 == "function" && U2, h5 = 0; h5 < s4.length; h5++) c3(s4[h5]);
      return c3;
    }, "e")({ 1: [function(n3, a5, l3) {
      a5.exports = function(s4) {
        if (typeof Map != "function" || s4) {
          var c3 = n3("./similar");
          return new c3();
        } else
          return /* @__PURE__ */ new Map();
      };
    }, { "./similar": 2 }], 2: [function(n3, a5, l3) {
      function s4() {
        return this.list = [], this.lastItem = void 0, this.size = 0, this;
      }
      i3(s4, "Similar"), s4.prototype.get = function(c3) {
        var o3;
        if (this.lastItem && this.isEqual(this.lastItem.key, c3))
          return this.lastItem.val;
        if (o3 = this.indexOf(c3), o3 >= 0)
          return this.lastItem = this.list[o3], this.list[o3].val;
      }, s4.prototype.set = function(c3, o3) {
        var h5;
        return this.lastItem && this.isEqual(this.lastItem.key, c3) ? (this.lastItem.val = o3, this) : (h5 = this.indexOf(c3), h5 >= 0 ? (this.lastItem = this.list[h5], this.list[h5].val = o3, this) : (this.lastItem = { key: c3, val: o3 }, this.list.push(this.lastItem), this.size++, this));
      }, s4.prototype.delete = function(c3) {
        var o3;
        if (this.lastItem && this.isEqual(this.lastItem.key, c3) && (this.lastItem = void 0), o3 = this.indexOf(c3), o3 >= 0)
          return this.size--, this.list.splice(o3, 1)[0];
      }, s4.prototype.has = function(c3) {
        var o3;
        return this.lastItem && this.isEqual(this.lastItem.key, c3) ? true : (o3 = this.indexOf(c3), o3 >= 0 ? (this.lastItem = this.list[o3], true) : false);
      }, s4.prototype.forEach = function(c3, o3) {
        var h5;
        for (h5 = 0; h5 < this.size; h5++)
          c3.call(o3 || this, this.list[h5].val, this.list[h5].key, this);
      }, s4.prototype.indexOf = function(c3) {
        var o3;
        for (o3 = 0; o3 < this.size; o3++)
          if (this.isEqual(this.list[o3].key, c3))
            return o3;
        return -1;
      }, s4.prototype.isEqual = function(c3, o3) {
        return c3 === o3 || c3 !== c3 && o3 !== o3;
      }, a5.exports = s4;
    }, {}], 3: [function(n3, a5, l3) {
      var s4 = n3("map-or-similar");
      a5.exports = function(u5) {
        var p6 = new s4(false), d3 = [];
        return function(g3) {
          var y4 = i3(function() {
            var m4 = p6, v6, C6, w6 = arguments.length - 1, I6 = Array(w6 + 1), P7 = true, j2;
            if ((y4.numArgs || y4.numArgs === 0) && y4.numArgs !== w6 + 1)
              throw new Error("Memoizerific functions should always be called with the same number of arguments");
            for (j2 = 0; j2 < w6; j2++) {
              if (I6[j2] = {
                cacheItem: m4,
                arg: arguments[j2]
              }, m4.has(arguments[j2])) {
                m4 = m4.get(arguments[j2]);
                continue;
              }
              P7 = false, v6 = new s4(false), m4.set(arguments[j2], v6), m4 = v6;
            }
            return P7 && (m4.has(arguments[w6]) ? C6 = m4.get(arguments[w6]) : P7 = false), P7 || (C6 = g3.apply(null, arguments), m4.set(arguments[w6], C6)), u5 > 0 && (I6[w6] = {
              cacheItem: m4,
              arg: arguments[w6]
            }, P7 ? c3(d3, I6) : d3.push(I6), d3.length > u5 && o3(d3.shift())), y4.wasMemoized = P7, y4.numArgs = w6 + 1, C6;
          }, "memoizerific");
          return y4.limit = u5, y4.wasMemoized = false, y4.cache = p6, y4.lru = d3, y4;
        };
      };
      function c3(u5, p6) {
        var d3 = u5.length, g3 = p6.length, y4, m4, v6;
        for (m4 = 0; m4 < d3; m4++) {
          for (y4 = true, v6 = 0; v6 < g3; v6++)
            if (!h5(u5[m4][v6].arg, p6[v6].arg)) {
              y4 = false;
              break;
            }
          if (y4)
            break;
        }
        u5.push(u5.splice(m4, 1)[0]);
      }
      i3(c3, "moveToMostRecentLru");
      function o3(u5) {
        var p6 = u5.length, d3 = u5[p6 - 1], g3, y4;
        for (d3.cacheItem.delete(d3.arg), y4 = p6 - 2; y4 >= 0 && (d3 = u5[y4], g3 = d3.cacheItem.get(d3.arg), !g3 || !g3.size); y4--)
          d3.cacheItem.delete(d3.arg);
      }
      i3(o3, "removeCachedResult");
      function h5(u5, p6) {
        return u5 === p6 || u5 !== u5 && p6 !== p6;
      }
      i3(h5, "isEqual");
    }, { "map-or-similar": 1 }] }, {}, [3])(3);
  });
});
var b3 = (() => {
  let t4;
  return typeof window < "u" ? t4 = window : typeof globalThis < "u" ? t4 = globalThis : typeof global < "u" ? t4 = global : typeof self < "u" ? t4 = self : t4 = {}, t4;
})();
var se = i3((t4) => t4.transports !== void 0, "isMulti");
var le = i3(() => Math.random().toString(16).slice(2), "generateRandomId");
var lt = class lt2 {
  constructor(e2 = {}) {
    this.sender = le();
    this.events = {};
    this.data = {};
    this.transports = [];
    this.isAsync = e2.async || false, se(e2) ? (this.transports = e2.transports || [], this.transports.forEach((r4) => {
      r4.setHandler((n3) => this.handleEvent(n3));
    })) : this.transports = e2.transport ? [e2.transport] : [], this.transports.forEach((r4) => {
      r4.setHandler((n3) => this.handleEvent(n3));
    });
  }
  get hasTransport() {
    return this.transports.length > 0;
  }
  addListener(e2, r4) {
    this.events[e2] = this.events[e2] || [], this.events[e2].push(r4);
  }
  emit(e2, ...r4) {
    let n3 = { type: e2, args: r4, from: this.sender }, a5 = {};
    r4.length >= 1 && r4[0] && r4[0].options && (a5 = r4[0].options);
    let l3 = i3(() => {
      this.transports.forEach((s4) => {
        s4.send(n3, a5);
      }), this.handleEvent(n3);
    }, "handler");
    this.isAsync ? setImmediate(l3) : l3();
  }
  last(e2) {
    return this.data[e2];
  }
  eventNames() {
    return Object.keys(this.events);
  }
  listenerCount(e2) {
    let r4 = this.listeners(e2);
    return r4 ? r4.length : 0;
  }
  listeners(e2) {
    return this.events[e2] || void 0;
  }
  once(e2, r4) {
    let n3 = this.onceListener(e2, r4);
    this.addListener(e2, n3);
  }
  removeAllListeners(e2) {
    e2 ? this.events[e2] && delete this.events[e2] : this.events = {};
  }
  removeListener(e2, r4) {
    let n3 = this.listeners(e2);
    n3 && (this.events[e2] = n3.filter((a5) => a5 !== r4));
  }
  on(e2, r4) {
    this.addListener(e2, r4);
  }
  off(e2, r4) {
    this.removeListener(e2, r4);
  }
  handleEvent(e2) {
    let r4 = this.listeners(e2.type);
    r4 && r4.length && r4.forEach((n3) => {
      n3.apply(e2, e2.args);
    }), this.data[e2.type] = e2.args;
  }
  onceListener(e2, r4) {
    let n3 = i3((...a5) => (this.removeListener(e2, n3), r4(...a5)), "onceListener");
    return n3;
  }
};
i3(lt, "Channel");
var z2 = lt;
var ce = Object.create;
var St = Object.defineProperty;
var fe = Object.getOwnPropertyDescriptor;
var wt = Object.getOwnPropertyNames;
var ue = Object.getPrototypeOf;
var pe = Object.prototype.hasOwnProperty;
var x2 = i3((t4, e2) => i3(function() {
  return e2 || (0, t4[wt(t4)[0]])((e2 = { exports: {} }).exports, e2), e2.exports;
}, "__require"), "__commonJS");
var ye = i3((t4, e2, r4, n3) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function")
    for (let a5 of wt(e2))
      !pe.call(t4, a5) && a5 !== r4 && St(t4, a5, { get: i3(() => e2[a5], "get"), enumerable: !(n3 = fe(e2, a5)) || n3.enumerable });
  return t4;
}, "__copyProps");
var tt = i3((t4, e2, r4) => (r4 = t4 != null ? ce(ue(t4)) : {}, ye(
  e2 || !t4 || !t4.__esModule ? St(r4, "default", { value: t4, enumerable: true }) : r4,
  t4
)), "__toESM");
var de = [
  "bubbles",
  "cancelBubble",
  "cancelable",
  "composed",
  "currentTarget",
  "defaultPrevented",
  "eventPhase",
  "isTrusted",
  "returnValue",
  "srcElement",
  "target",
  "timeStamp",
  "type"
];
var he = ["detail"];
function Et(t4) {
  let e2 = de.filter((r4) => t4[r4] !== void 0).reduce((r4, n3) => ({ ...r4, [n3]: t4[n3] }), {});
  return t4 instanceof CustomEvent && he.filter((r4) => t4[r4] !== void 0).forEach((r4) => {
    e2[r4] = t4[r4];
  }), e2;
}
i3(Et, "extractEventHiddenProperties");
var Ut = ie(At(), 1);
var Tt = x2({
  "node_modules/has-symbols/shams.js"(t4, e2) {
    "use strict";
    e2.exports = i3(function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return false;
      if (typeof Symbol.iterator == "symbol")
        return true;
      var n3 = {}, a5 = Symbol("test"), l3 = Object(a5);
      if (typeof a5 == "string" || Object.prototype.toString.call(a5) !== "[object Symbol]" || Object.prototype.toString.call(l3) !== "[object Symbol]")
        return false;
      var s4 = 42;
      n3[a5] = s4;
      for (a5 in n3)
        return false;
      if (typeof Object.keys == "function" && Object.keys(n3).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(
        n3
      ).length !== 0)
        return false;
      var c3 = Object.getOwnPropertySymbols(n3);
      if (c3.length !== 1 || c3[0] !== a5 || !Object.prototype.propertyIsEnumerable.call(n3, a5))
        return false;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var o3 = Object.getOwnPropertyDescriptor(n3, a5);
        if (o3.value !== s4 || o3.enumerable !== true)
          return false;
      }
      return true;
    }, "hasSymbols");
  }
});
var Ft = x2({
  "node_modules/has-symbols/index.js"(t4, e2) {
    "use strict";
    var r4 = typeof Symbol < "u" && Symbol, n3 = Tt();
    e2.exports = i3(function() {
      return typeof r4 != "function" || typeof Symbol != "function" || typeof r4("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : n3();
    }, "hasNativeSymbols");
  }
});
var ge = x2({
  "node_modules/function-bind/implementation.js"(t4, e2) {
    "use strict";
    var r4 = "Function.prototype.bind called on incompatible ", n3 = Array.prototype.slice, a5 = Object.prototype.toString, l3 = "[object Function]";
    e2.exports = i3(function(c3) {
      var o3 = this;
      if (typeof o3 != "function" || a5.call(o3) !== l3)
        throw new TypeError(r4 + o3);
      for (var h5 = n3.call(arguments, 1), u5, p6 = i3(function() {
        if (this instanceof u5) {
          var v6 = o3.apply(
            this,
            h5.concat(n3.call(arguments))
          );
          return Object(v6) === v6 ? v6 : this;
        } else
          return o3.apply(
            c3,
            h5.concat(n3.call(arguments))
          );
      }, "binder"), d3 = Math.max(0, o3.length - h5.length), g3 = [], y4 = 0; y4 < d3; y4++)
        g3.push("$" + y4);
      if (u5 = Function("binder", "return function (" + g3.join(",") + "){ return binder.apply(this,arguments); }")(p6), o3.prototype) {
        var m4 = i3(function() {
        }, "Empty2");
        m4.prototype = o3.prototype, u5.prototype = new m4(), m4.prototype = null;
      }
      return u5;
    }, "bind");
  }
});
var ut = x2({
  "node_modules/function-bind/index.js"(t4, e2) {
    "use strict";
    var r4 = ge();
    e2.exports = Function.prototype.bind || r4;
  }
});
var me = x2({
  "node_modules/has/src/index.js"(t4, e2) {
    "use strict";
    var r4 = ut();
    e2.exports = r4.call(Function.call, Object.prototype.hasOwnProperty);
  }
});
var Nt = x2({
  "node_modules/get-intrinsic/index.js"(t4, e2) {
    "use strict";
    var r4, n3 = SyntaxError, a5 = Function, l3 = TypeError, s4 = i3(function(T4) {
      try {
        return a5('"use strict"; return (' + T4 + ").constructor;")();
      } catch {
      }
    }, "getEvalledConstructor"), c3 = Object.getOwnPropertyDescriptor;
    if (c3)
      try {
        c3({}, "");
      } catch {
        c3 = null;
      }
    var o3 = i3(function() {
      throw new l3();
    }, "throwTypeError"), h5 = c3 ? function() {
      try {
        return arguments.callee, o3;
      } catch {
        try {
          return c3(arguments, "callee").get;
        } catch {
          return o3;
        }
      }
    }() : o3, u5 = Ft()(), p6 = Object.getPrototypeOf || function(T4) {
      return T4.__proto__;
    }, d3 = {}, g3 = typeof Uint8Array > "u" ? r4 : p6(Uint8Array), y4 = {
      "%AggregateError%": typeof AggregateError > "u" ? r4 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r4 : ArrayBuffer,
      "%ArrayIteratorPrototype%": u5 ? p6([][Symbol.iterator]()) : r4,
      "%AsyncFromSyncIteratorPrototype%": r4,
      "%AsyncFunction%": d3,
      "%AsyncGenerator%": d3,
      "%AsyncGeneratorFunction%": d3,
      "%AsyncIteratorPrototype%": d3,
      "%Atomics%": typeof Atomics > "u" ? r4 : Atomics,
      "%BigInt%": typeof BigInt > "u" ? r4 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView > "u" ? r4 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array > "u" ? r4 : Float32Array,
      "%Float64Array%": typeof Float64Array > "u" ? r4 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r4 : FinalizationRegistry,
      "%Function%": a5,
      "%GeneratorFunction%": d3,
      "%Int8Array%": typeof Int8Array > "u" ? r4 : Int8Array,
      "%Int16Array%": typeof Int16Array > "u" ? r4 : Int16Array,
      "%Int32Array%": typeof Int32Array > "u" ? r4 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": u5 ? p6(p6([][Symbol.iterator]())) : r4,
      "%JSON%": typeof JSON == "object" ? JSON : r4,
      "%Map%": typeof Map > "u" ? r4 : Map,
      "%MapIteratorPrototype%": typeof Map > "u" || !u5 ? r4 : p6((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise > "u" ? r4 : Promise,
      "%Proxy%": typeof Proxy > "u" ? r4 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect > "u" ? r4 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set > "u" ? r4 : Set,
      "%SetIteratorPrototype%": typeof Set > "u" || !u5 ? r4 : p6((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r4 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": u5 ? p6(""[Symbol.iterator]()) : r4,
      "%Symbol%": u5 ? Symbol : r4,
      "%SyntaxError%": n3,
      "%ThrowTypeError%": h5,
      "%TypedArray%": g3,
      "%TypeError%": l3,
      "%Uint8Array%": typeof Uint8Array > "u" ? r4 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r4 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array > "u" ? r4 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array > "u" ? r4 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap > "u" ? r4 : WeakMap,
      "%WeakRef%": typeof WeakRef > "u" ? r4 : WeakRef,
      "%WeakSet%": typeof WeakSet > "u" ? r4 : WeakSet
    }, m4 = i3(function T4(_4) {
      var E2;
      if (_4 === "%AsyncFunction%")
        E2 = s4("async function () {}");
      else if (_4 === "%GeneratorFunction%")
        E2 = s4("function* () {}");
      else if (_4 === "%AsyncGeneratorFunction%")
        E2 = s4("async function* () {}");
      else if (_4 === "%AsyncGenerator%") {
        var S5 = T4("%AsyncGeneratorFunction%");
        S5 && (E2 = S5.prototype);
      } else if (_4 === "%AsyncIteratorPrototype%") {
        var O7 = T4("%AsyncGenerator%");
        O7 && (E2 = p6(O7.prototype));
      }
      return y4[_4] = E2, E2;
    }, "doEval2"), v6 = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }, C6 = ut(), w6 = me(), I6 = C6.call(Function.call, Array.prototype.concat), P7 = C6.call(Function.apply, Array.prototype.splice), j2 = C6.call(
      Function.call,
      String.prototype.replace
    ), V4 = C6.call(Function.call, String.prototype.slice), Vt2 = C6.call(Function.call, RegExp.prototype.exec), Kt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Yt2 = /\\(\\)?/g, Zt2 = i3(
      function(_4) {
        var E2 = V4(_4, 0, 1), S5 = V4(_4, -1);
        if (E2 === "%" && S5 !== "%")
          throw new n3("invalid intrinsic syntax, expected closing `%`");
        if (S5 === "%" && E2 !== "%")
          throw new n3("invalid intrinsic syntax, expected opening `%`");
        var O7 = [];
        return j2(_4, Kt, function(F5, R5, A4, K5) {
          O7[O7.length] = A4 ? j2(K5, Yt2, "$1") : R5 || F5;
        }), O7;
      },
      "stringToPath3"
    ), Xt2 = i3(function(_4, E2) {
      var S5 = _4, O7;
      if (w6(v6, S5) && (O7 = v6[S5], S5 = "%" + O7[0] + "%"), w6(y4, S5)) {
        var F5 = y4[S5];
        if (F5 === d3 && (F5 = m4(S5)), typeof F5 > "u" && !E2)
          throw new l3("intrinsic " + _4 + " exists, but is not available. Please file an issue!");
        return {
          alias: O7,
          name: S5,
          value: F5
        };
      }
      throw new n3("intrinsic " + _4 + " does not exist!");
    }, "getBaseIntrinsic2");
    e2.exports = i3(function(_4, E2) {
      if (typeof _4 != "string" || _4.length === 0)
        throw new l3("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof E2 != "boolean")
        throw new l3('"allowMissing" argument must be a boolean');
      if (Vt2(/^%?[^%]*%?$/, _4) === null)
        throw new n3("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var S5 = Zt2(_4), O7 = S5.length > 0 ? S5[0] : "", F5 = Xt2("%" + O7 + "%", E2), R5 = F5.name, A4 = F5.value, K5 = false, it2 = F5.alias;
      it2 && (O7 = it2[0], P7(S5, I6([0, 1], it2)));
      for (var Y4 = 1, L5 = true; Y4 < S5.length; Y4 += 1) {
        var N5 = S5[Y4], Z2 = V4(N5, 0, 1), X4 = V4(N5, -1);
        if ((Z2 === '"' || Z2 === "'" || Z2 === "`" || X4 === '"' || X4 === "'" || X4 === "`") && Z2 !== X4)
          throw new n3("property names with quotes must have matching quotes");
        if ((N5 === "constructor" || !L5) && (K5 = true), O7 += "." + N5, R5 = "%" + O7 + "%", w6(y4, R5))
          A4 = y4[R5];
        else if (A4 != null) {
          if (!(N5 in A4)) {
            if (!E2)
              throw new l3("base intrinsic for " + _4 + " exists, but the property is not available.");
            return;
          }
          if (c3 && Y4 + 1 >= S5.length) {
            var Q2 = c3(A4, N5);
            L5 = !!Q2, L5 && "get" in Q2 && !("originalValue" in Q2.get) ? A4 = Q2.get : A4 = A4[N5];
          } else
            L5 = w6(A4, N5), A4 = A4[N5];
          L5 && !K5 && (y4[R5] = A4);
        }
      }
      return A4;
    }, "GetIntrinsic");
  }
});
var ve = x2({
  "node_modules/call-bind/index.js"(t4, e2) {
    "use strict";
    var r4 = ut(), n3 = Nt(), a5 = n3("%Function.prototype.apply%"), l3 = n3("%Function.prototype.call%"), s4 = n3("%Reflect.apply%", true) || r4.call(
      l3,
      a5
    ), c3 = n3("%Object.getOwnPropertyDescriptor%", true), o3 = n3("%Object.defineProperty%", true), h5 = n3("%Math.max%");
    if (o3)
      try {
        o3({}, "a", { value: 1 });
      } catch {
        o3 = null;
      }
    e2.exports = i3(function(d3) {
      var g3 = s4(r4, l3, arguments);
      if (c3 && o3) {
        var y4 = c3(g3, "length");
        y4.configurable && o3(
          g3,
          "length",
          { value: 1 + h5(0, d3.length - (arguments.length - 1)) }
        );
      }
      return g3;
    }, "callBind");
    var u5 = i3(function() {
      return s4(r4, a5, arguments);
    }, "applyBind2");
    o3 ? o3(e2.exports, "apply", { value: u5 }) : e2.exports.apply = u5;
  }
});
var _e = x2({
  "node_modules/call-bind/callBound.js"(t4, e2) {
    "use strict";
    var r4 = Nt(), n3 = ve(), a5 = n3(r4("String.prototype.indexOf"));
    e2.exports = i3(function(s4, c3) {
      var o3 = r4(s4, !!c3);
      return typeof o3 == "function" && a5(s4, ".prototype.") > -1 ? n3(o3) : o3;
    }, "callBoundIntrinsic");
  }
});
var be = x2({
  "node_modules/has-tostringtag/shams.js"(t4, e2) {
    "use strict";
    var r4 = Tt();
    e2.exports = i3(function() {
      return r4() && !!Symbol.toStringTag;
    }, "hasToStringTagShams");
  }
});
var Se = x2({
  "node_modules/is-regex/index.js"(t4, e2) {
    "use strict";
    var r4 = _e(), n3 = be()(), a5, l3, s4, c3;
    n3 && (a5 = r4("Object.prototype.hasOwnProperty"), l3 = r4("RegExp.prototype.exec"), s4 = {}, o3 = i3(function() {
      throw s4;
    }, "throwRegexMarker"), c3 = {
      toString: o3,
      valueOf: o3
    }, typeof Symbol.toPrimitive == "symbol" && (c3[Symbol.toPrimitive] = o3));
    var o3, h5 = r4("Object.prototype.toString"), u5 = Object.getOwnPropertyDescriptor, p6 = "[object RegExp]";
    e2.exports = i3(n3 ? function(g3) {
      if (!g3 || typeof g3 != "object")
        return false;
      var y4 = u5(g3, "lastIndex"), m4 = y4 && a5(y4, "value");
      if (!m4)
        return false;
      try {
        l3(g3, c3);
      } catch (v6) {
        return v6 === s4;
      }
    } : function(g3) {
      return !g3 || typeof g3 != "object" && typeof g3 != "function" ? false : h5(g3) === p6;
    }, "isRegex");
  }
});
var we = x2({
  "node_modules/is-function/index.js"(t4, e2) {
    e2.exports = n3;
    var r4 = Object.prototype.toString;
    function n3(a5) {
      if (!a5)
        return false;
      var l3 = r4.call(a5);
      return l3 === "[object Function]" || typeof a5 == "function" && l3 !== "[object RegExp]" || typeof window < "u" && (a5 === window.setTimeout || a5 === window.alert || a5 === window.confirm || a5 === window.prompt);
    }
    i3(n3, "isFunction3");
  }
});
var Ee = x2({
  "node_modules/is-symbol/index.js"(t4, e2) {
    "use strict";
    var r4 = Object.prototype.toString, n3 = Ft()();
    n3 ? (a5 = Symbol.prototype.toString, l3 = /^Symbol\(.*\)$/, s4 = i3(function(o3) {
      return typeof o3.valueOf() != "symbol" ? false : l3.test(a5.call(o3));
    }, "isRealSymbolObject"), e2.exports = i3(function(o3) {
      if (typeof o3 == "symbol")
        return true;
      if (r4.call(o3) !== "[object Symbol]")
        return false;
      try {
        return s4(o3);
      } catch {
        return false;
      }
    }, "isSymbol3")) : e2.exports = i3(function(o3) {
      return false;
    }, "isSymbol3");
    var a5, l3, s4;
  }
});
var Oe = tt(Se());
var Ae = tt(we());
var Pe = tt(Ee());
function xe(t4) {
  return t4 != null && typeof t4 == "object" && Array.isArray(t4) === false;
}
i3(xe, "isObject");
var Ce = typeof global == "object" && global && global.Object === Object && global;
var Ie = Ce;
var je = typeof self == "object" && self && self.Object === Object && self;
var Te = Ie || je || Function("return this")();
var pt = Te;
var Fe = pt.Symbol;
var M2 = Fe;
var Rt = Object.prototype;
var Ne = Rt.hasOwnProperty;
var Re = Rt.toString;
var W2 = M2 ? M2.toStringTag : void 0;
function Me(t4) {
  var e2 = Ne.call(t4, W2), r4 = t4[W2];
  try {
    t4[W2] = void 0;
    var n3 = true;
  } catch {
  }
  var a5 = Re.call(t4);
  return n3 && (e2 ? t4[W2] = r4 : delete t4[W2]), a5;
}
i3(Me, "getRawTag");
var $e = Me;
var ke = Object.prototype;
var De = ke.toString;
function Le(t4) {
  return De.call(t4);
}
i3(Le, "objectToString");
var Ue = Le;
var ze = "[object Null]";
var We = "[object Undefined]";
var Pt = M2 ? M2.toStringTag : void 0;
function Be(t4) {
  return t4 == null ? t4 === void 0 ? We : ze : Pt && Pt in Object(t4) ? $e(t4) : Ue(t4);
}
i3(Be, "baseGetTag");
var Mt = Be;
function He(t4) {
  return t4 != null && typeof t4 == "object";
}
i3(He, "isObjectLike");
var qe = He;
var Ge = "[object Symbol]";
function Je(t4) {
  return typeof t4 == "symbol" || qe(t4) && Mt(t4) == Ge;
}
i3(Je, "isSymbol");
var yt = Je;
function Ve(t4, e2) {
  for (var r4 = -1, n3 = t4 == null ? 0 : t4.length, a5 = Array(n3); ++r4 < n3; )
    a5[r4] = e2(t4[r4], r4, t4);
  return a5;
}
i3(Ve, "arrayMap");
var Ke = Ve;
var Ye = Array.isArray;
var dt = Ye;
var Ze = 1 / 0;
var xt = M2 ? M2.prototype : void 0;
var Ct = xt ? xt.toString : void 0;
function $t(t4) {
  if (typeof t4 == "string")
    return t4;
  if (dt(t4))
    return Ke(t4, $t) + "";
  if (yt(t4))
    return Ct ? Ct.call(t4) : "";
  var e2 = t4 + "";
  return e2 == "0" && 1 / t4 == -Ze ? "-0" : e2;
}
i3($t, "baseToString");
var Xe = $t;
function Qe(t4) {
  var e2 = typeof t4;
  return t4 != null && (e2 == "object" || e2 == "function");
}
i3(Qe, "isObject2");
var kt = Qe;
var tr = "[object AsyncFunction]";
var er = "[object Function]";
var rr = "[object GeneratorFunction]";
var nr = "[object Proxy]";
function or(t4) {
  if (!kt(t4))
    return false;
  var e2 = Mt(t4);
  return e2 == er || e2 == rr || e2 == tr || e2 == nr;
}
i3(or, "isFunction");
var ar = or;
var ir = pt["__core-js_shared__"];
var ft = ir;
var It = function() {
  var t4 = /[^.]+$/.exec(ft && ft.keys && ft.keys.IE_PROTO || "");
  return t4 ? "Symbol(src)_1." + t4 : "";
}();
function sr(t4) {
  return !!It && It in t4;
}
i3(sr, "isMasked");
var lr = sr;
var cr = Function.prototype;
var fr = cr.toString;
function ur(t4) {
  if (t4 != null) {
    try {
      return fr.call(t4);
    } catch {
    }
    try {
      return t4 + "";
    } catch {
    }
  }
  return "";
}
i3(ur, "toSource");
var pr = ur;
var yr = /[\\^$.*+?()[\]{}|]/g;
var dr = /^\[object .+?Constructor\]$/;
var hr = Function.prototype;
var gr = Object.prototype;
var mr = hr.toString;
var vr = gr.hasOwnProperty;
var _r = RegExp(
  "^" + mr.call(vr).replace(yr, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function br(t4) {
  if (!kt(t4) || lr(t4))
    return false;
  var e2 = ar(t4) ? _r : dr;
  return e2.test(pr(t4));
}
i3(br, "baseIsNative");
var Sr = br;
function wr(t4, e2) {
  return t4 == null ? void 0 : t4[e2];
}
i3(wr, "getValue");
var Er = wr;
function Or(t4, e2) {
  var r4 = Er(t4, e2);
  return Sr(r4) ? r4 : void 0;
}
i3(Or, "getNative");
var Dt = Or;
function Ar(t4, e2) {
  return t4 === e2 || t4 !== t4 && e2 !== e2;
}
i3(Ar, "eq");
var Pr = Ar;
var xr = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var Cr = /^\w*$/;
function Ir(t4, e2) {
  if (dt(t4))
    return false;
  var r4 = typeof t4;
  return r4 == "number" || r4 == "symbol" || r4 == "boolean" || t4 == null || yt(t4) ? true : Cr.test(t4) || !xr.test(t4) || e2 != null && t4 in Object(
    e2
  );
}
i3(Ir, "isKey");
var jr = Ir;
var Tr = Dt(Object, "create");
var B2 = Tr;
function Fr() {
  this.__data__ = B2 ? B2(null) : {}, this.size = 0;
}
i3(Fr, "hashClear");
var Nr = Fr;
function Rr(t4) {
  var e2 = this.has(t4) && delete this.__data__[t4];
  return this.size -= e2 ? 1 : 0, e2;
}
i3(Rr, "hashDelete");
var Mr = Rr;
var $r = "__lodash_hash_undefined__";
var kr = Object.prototype;
var Dr = kr.hasOwnProperty;
function Lr(t4) {
  var e2 = this.__data__;
  if (B2) {
    var r4 = e2[t4];
    return r4 === $r ? void 0 : r4;
  }
  return Dr.call(e2, t4) ? e2[t4] : void 0;
}
i3(Lr, "hashGet");
var Ur = Lr;
var zr = Object.prototype;
var Wr = zr.hasOwnProperty;
function Br(t4) {
  var e2 = this.__data__;
  return B2 ? e2[t4] !== void 0 : Wr.call(e2, t4);
}
i3(Br, "hashHas");
var Hr = Br;
var qr = "__lodash_hash_undefined__";
function Gr(t4, e2) {
  var r4 = this.__data__;
  return this.size += this.has(t4) ? 0 : 1, r4[t4] = B2 && e2 === void 0 ? qr : e2, this;
}
i3(Gr, "hashSet");
var Jr = Gr;
function $2(t4) {
  var e2 = -1, r4 = t4 == null ? 0 : t4.length;
  for (this.clear(); ++e2 < r4; ) {
    var n3 = t4[e2];
    this.set(n3[0], n3[1]);
  }
}
i3($2, "Hash");
$2.prototype.clear = Nr;
$2.prototype.delete = Mr;
$2.prototype.get = Ur;
$2.prototype.has = Hr;
$2.prototype.set = Jr;
var jt = $2;
function Vr() {
  this.__data__ = [], this.size = 0;
}
i3(Vr, "listCacheClear");
var Kr = Vr;
function Yr(t4, e2) {
  for (var r4 = t4.length; r4--; )
    if (Pr(t4[r4][0], e2))
      return r4;
  return -1;
}
i3(Yr, "assocIndexOf");
var rt = Yr;
var Zr = Array.prototype;
var Xr = Zr.splice;
function Qr(t4) {
  var e2 = this.__data__, r4 = rt(e2, t4);
  if (r4 < 0)
    return false;
  var n3 = e2.length - 1;
  return r4 == n3 ? e2.pop() : Xr.call(e2, r4, 1), --this.size, true;
}
i3(Qr, "listCacheDelete");
var tn = Qr;
function en(t4) {
  var e2 = this.__data__, r4 = rt(e2, t4);
  return r4 < 0 ? void 0 : e2[r4][1];
}
i3(en, "listCacheGet");
var rn = en;
function nn(t4) {
  return rt(this.__data__, t4) > -1;
}
i3(nn, "listCacheHas");
var on = nn;
function an(t4, e2) {
  var r4 = this.__data__, n3 = rt(r4, t4);
  return n3 < 0 ? (++this.size, r4.push([t4, e2])) : r4[n3][1] = e2, this;
}
i3(an, "listCacheSet");
var sn = an;
function k2(t4) {
  var e2 = -1, r4 = t4 == null ? 0 : t4.length;
  for (this.clear(); ++e2 < r4; ) {
    var n3 = t4[e2];
    this.set(n3[0], n3[1]);
  }
}
i3(k2, "ListCache");
k2.prototype.clear = Kr;
k2.prototype.delete = tn;
k2.prototype.get = rn;
k2.prototype.has = on;
k2.prototype.set = sn;
var ln = k2;
var cn = Dt(pt, "Map");
var fn = cn;
function un() {
  this.size = 0, this.__data__ = {
    hash: new jt(),
    map: new (fn || ln)(),
    string: new jt()
  };
}
i3(un, "mapCacheClear");
var pn = un;
function yn(t4) {
  var e2 = typeof t4;
  return e2 == "string" || e2 == "number" || e2 == "symbol" || e2 == "boolean" ? t4 !== "__proto__" : t4 === null;
}
i3(yn, "isKeyable");
var dn = yn;
function hn(t4, e2) {
  var r4 = t4.__data__;
  return dn(e2) ? r4[typeof e2 == "string" ? "string" : "hash"] : r4.map;
}
i3(hn, "getMapData");
var nt = hn;
function gn(t4) {
  var e2 = nt(this, t4).delete(t4);
  return this.size -= e2 ? 1 : 0, e2;
}
i3(gn, "mapCacheDelete");
var mn = gn;
function vn(t4) {
  return nt(this, t4).get(t4);
}
i3(vn, "mapCacheGet");
var _n = vn;
function bn(t4) {
  return nt(this, t4).has(t4);
}
i3(bn, "mapCacheHas");
var Sn = bn;
function wn(t4, e2) {
  var r4 = nt(this, t4), n3 = r4.size;
  return r4.set(t4, e2), this.size += r4.size == n3 ? 0 : 1, this;
}
i3(wn, "mapCacheSet");
var En = wn;
function D2(t4) {
  var e2 = -1, r4 = t4 == null ? 0 : t4.length;
  for (this.clear(); ++e2 < r4; ) {
    var n3 = t4[e2];
    this.set(n3[0], n3[1]);
  }
}
i3(D2, "MapCache");
D2.prototype.clear = pn;
D2.prototype.delete = mn;
D2.prototype.get = _n;
D2.prototype.has = Sn;
D2.prototype.set = En;
var Lt = D2;
var On = "Expected a function";
function ht(t4, e2) {
  if (typeof t4 != "function" || e2 != null && typeof e2 != "function")
    throw new TypeError(On);
  var r4 = i3(function() {
    var n3 = arguments, a5 = e2 ? e2.apply(this, n3) : n3[0], l3 = r4.cache;
    if (l3.has(a5))
      return l3.get(a5);
    var s4 = t4.apply(this, n3);
    return r4.cache = l3.set(a5, s4) || l3, s4;
  }, "memoized");
  return r4.cache = new (ht.Cache || Lt)(), r4;
}
i3(ht, "memoize");
ht.Cache = Lt;
var An = ht;
var Pn = 500;
function xn(t4) {
  var e2 = An(t4, function(n3) {
    return r4.size === Pn && r4.clear(), n3;
  }), r4 = e2.cache;
  return e2;
}
i3(xn, "memoizeCapped");
var Cn = xn;
var In = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var jn = /\\(\\)?/g;
var Tn = Cn(
  function(t4) {
    var e2 = [];
    return t4.charCodeAt(0) === 46 && e2.push(""), t4.replace(In, function(r4, n3, a5, l3) {
      e2.push(a5 ? l3.replace(jn, "$1") : n3 || r4);
    }), e2;
  }
);
var Fn = Tn;
function Nn(t4) {
  return t4 == null ? "" : Xe(t4);
}
i3(Nn, "toString");
var Rn = Nn;
function Mn(t4, e2) {
  return dt(t4) ? t4 : jr(t4, e2) ? [t4] : Fn(Rn(t4));
}
i3(Mn, "castPath");
var $n = Mn;
var kn = 1 / 0;
function Dn(t4) {
  if (typeof t4 == "string" || yt(t4))
    return t4;
  var e2 = t4 + "";
  return e2 == "0" && 1 / t4 == -kn ? "-0" : e2;
}
i3(Dn, "toKey");
var Ln = Dn;
function Un(t4, e2) {
  e2 = $n(e2, t4);
  for (var r4 = 0, n3 = e2.length; t4 != null && r4 < n3; )
    t4 = t4[Ln(e2[r4++])];
  return r4 && r4 == n3 ? t4 : void 0;
}
i3(Un, "baseGet");
var zn = Un;
function Wn(t4, e2, r4) {
  var n3 = t4 == null ? void 0 : zn(t4, e2);
  return n3 === void 0 ? r4 : n3;
}
i3(Wn, "get");
var Bn = Wn;
var et = xe;
var Hn = i3((t4) => {
  let e2 = null, r4 = false, n3 = false, a5 = false, l3 = "";
  if (t4.indexOf("//") >= 0 || t4.indexOf("/*") >= 0)
    for (let s4 = 0; s4 < t4.length; s4 += 1)
      !e2 && !r4 && !n3 && !a5 ? t4[s4] === '"' || t4[s4] === "'" || t4[s4] === "`" ? e2 = t4[s4] : t4[s4] === "/" && t4[s4 + 1] === "*" ? r4 = true : t4[s4] === "/" && t4[s4 + 1] === "/" ? n3 = true : t4[s4] === "/" && t4[s4 + 1] !== "/" && (a5 = true) : (e2 && (t4[s4] === e2 && t4[s4 - 1] !== "\\" || t4[s4] === `
` && e2 !== "`") && (e2 = null), a5 && (t4[s4] === "/" && t4[s4 - 1] !== "\\" || t4[s4] === `
`) && (a5 = false), r4 && t4[s4 - 1] === "/" && t4[s4 - 2] === "*" && (r4 = false), n3 && t4[s4] === `
` && (n3 = false)), !r4 && !n3 && (l3 += t4[s4]);
  else
    l3 = t4;
  return l3;
}, "removeCodeComments");
var qn = (0, Ut.default)(1e4)(
  (t4) => Hn(t4).replace(/\n\s*/g, "").trim()
);
var Gn = i3(function(e2, r4) {
  let n3 = r4.slice(0, r4.indexOf("{")), a5 = r4.slice(r4.indexOf("{"));
  if (n3.includes("=>") || n3.includes("function"))
    return r4;
  let l3 = n3;
  return l3 = l3.replace(e2, "function"), l3 + a5;
}, "convertShorthandMethods2");
var Jn = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/;
var H2 = i3(
  (t4) => t4.match(/^[\[\{\"\}].*[\]\}\"]$/),
  "isJSON"
);
function zt(t4) {
  if (!et(t4))
    return t4;
  let e2 = t4, r4 = false;
  return typeof Event < "u" && t4 instanceof Event && (e2 = Et(e2), r4 = true), e2 = Object.keys(e2).reduce((n3, a5) => {
    try {
      e2[a5] && e2[a5].toJSON, n3[a5] = e2[a5];
    } catch {
      r4 = true;
    }
    return n3;
  }, {}), r4 ? e2 : t4;
}
i3(zt, "convertUnconventionalData");
var Vn = i3(function(e2) {
  let r4, n3, a5, l3;
  return i3(function(c3, o3) {
    try {
      if (c3 === "")
        return l3 = [], r4 = /* @__PURE__ */ new Map([[o3, "[]"]]), n3 = /* @__PURE__ */ new Map(), a5 = [], o3;
      let h5 = n3.get(this) || this;
      for (; a5.length && h5 !== a5[0]; )
        a5.shift(), l3.pop();
      if (typeof o3 == "boolean")
        return o3;
      if (o3 === void 0)
        return e2.allowUndefined ? "_undefined_" : void 0;
      if (o3 === null)
        return null;
      if (typeof o3 == "number")
        return o3 === -1 / 0 ? "_-Infinity_" : o3 === 1 / 0 ? "_Infinity_" : Number.isNaN(o3) ? "_NaN_" : o3;
      if (typeof o3 == "bigint")
        return `_bigint_${o3.toString()}`;
      if (typeof o3 == "string")
        return Jn.test(o3) ? e2.allowDate ? `_date_${o3}` : void 0 : o3;
      if ((0, Oe.default)(o3))
        return e2.allowRegExp ? `_regexp_${o3.flags}|${o3.source}` : void 0;
      if ((0, Ae.default)(o3)) {
        if (!e2.allowFunction)
          return;
        let { name: p6 } = o3, d3 = o3.toString();
        return d3.match(
          /(\[native code\]|WEBPACK_IMPORTED_MODULE|__webpack_exports__|__webpack_require__)/
        ) ? `_function_${p6}|${(() => {
        }).toString()}` : `_function_${p6}|${qn(Gn(c3, d3))}`;
      }
      if ((0, Pe.default)(o3)) {
        if (!e2.allowSymbol)
          return;
        let p6 = Symbol.keyFor(o3);
        return p6 !== void 0 ? `_gsymbol_${p6}` : `_symbol_${o3.toString().slice(7, -1)}`;
      }
      if (a5.length >= e2.maxDepth)
        return Array.isArray(o3) ? `[Array(${o3.length})]` : "[Object]";
      if (o3 === this)
        return `_duplicate_${JSON.stringify(l3)}`;
      if (o3 instanceof Error && e2.allowError)
        return {
          __isConvertedError__: true,
          errorProperties: {
            ...o3.cause ? { cause: o3.cause } : {},
            ...o3,
            name: o3.name,
            message: o3.message,
            stack: o3.stack,
            "_constructor-name_": o3.constructor.name
          }
        };
      if (o3.constructor && o3.constructor.name && o3.constructor.name !== "Object" && !Array.isArray(o3) && !e2.allowClass)
        return;
      let u5 = r4.get(o3);
      if (!u5) {
        let p6 = Array.isArray(o3) ? o3 : zt(o3);
        if (o3.constructor && o3.constructor.name && o3.constructor.name !== "Object" && !Array.isArray(o3) && e2.allowClass)
          try {
            Object.assign(p6, { "_constructor-name_": o3.constructor.name });
          } catch {
          }
        return l3.push(c3), a5.unshift(p6), r4.set(o3, JSON.stringify(l3)), o3 !== p6 && n3.set(o3, p6), p6;
      }
      return `_duplicate_${u5}`;
    } catch {
      return;
    }
  }, "replace");
}, "replacer2");
var Kn = i3(function reviver(options) {
  let refs = [], root;
  return i3(function revive(key, value) {
    if (key === "" && (root = value, refs.forEach(({ target: t4, container: e2, replacement: r4 }) => {
      let n3 = H2(r4) ? JSON.parse(r4) : r4.split(".");
      n3.length === 0 ? e2[t4] = root : e2[t4] = Bn(root, n3);
    })), key === "_constructor-name_")
      return value;
    if (et(value) && value.__isConvertedError__) {
      let { message: t4, ...e2 } = value.errorProperties, r4 = new Error(t4);
      return Object.assign(r4, e2), r4;
    }
    if (et(value) && value["_constructor-name_"] && options.allowFunction) {
      let t4 = value["_constructor-name_"];
      if (t4 !== "Object") {
        let e2 = new Function(`return function ${t4.replace(/[^a-zA-Z0-9$_]+/g, "")}(){}`)();
        Object.setPrototypeOf(value, new e2());
      }
      return delete value["_constructor-name_"], value;
    }
    if (typeof value == "string" && value.startsWith("_function_") && options.allowFunction) {
      let [, name, source] = value.match(/_function_([^|]*)\|(.*)/) || [], sourceSanitized = source.replace(/[(\(\))|\\| |\]|`]*$/, "");
      if (!options.lazyEval)
        return eval(`(${sourceSanitized})`);
      let result = i3((...args) => {
        let f = eval(`(${sourceSanitized})`);
        return f(...args);
      }, "result");
      return Object.defineProperty(result, "toString", {
        value: i3(() => sourceSanitized, "value")
      }), Object.defineProperty(result, "name", {
        value: name
      }), result;
    }
    if (typeof value == "string" && value.startsWith("_regexp_") && options.allowRegExp) {
      let [, t4, e2] = value.match(/_regexp_([^|]*)\|(.*)/) || [];
      return new RegExp(e2, t4);
    }
    return typeof value == "string" && value.startsWith("_date_") && options.allowDate ? new Date(value.replace("_date_", "")) : typeof value == "string" && value.startsWith("_duplicate_") ? (refs.push({ target: key, container: this, replacement: value.replace(/^_duplicate_/, "") }), null) : typeof value == "string" && value.startsWith("_symbol_") && options.allowSymbol ? Symbol(value.replace("_symbol_", "")) : typeof value == "string" && value.startsWith("_gsymbol_") && options.allowSymbol ? Symbol.for(value.replace("_gsymbol_", "")) : typeof value == "string" && value === "_-Infinity_" ? -1 / 0 : typeof value == "string" && value === "_Infinity_" ? 1 / 0 : typeof value == "string" && value === "_NaN_" ? NaN : typeof value == "string" && value.startsWith("_bigint_") && typeof BigInt == "function" ? BigInt(value.replace("_bigint_", "")) : value;
  }, "revive");
}, "reviver");
var Wt = {
  maxDepth: 10,
  space: void 0,
  allowFunction: true,
  allowRegExp: true,
  allowDate: true,
  allowClass: true,
  allowError: true,
  allowUndefined: true,
  allowSymbol: true,
  lazyEval: true
};
var ot = i3((t4, e2 = {}) => {
  let r4 = { ...Wt, ...e2 };
  return JSON.stringify(zt(t4), Vn(r4), e2.space);
}, "stringify");
var Yn = i3(() => {
  let t4 = /* @__PURE__ */ new Map();
  return i3(function e2(r4) {
    et(r4) && Object.entries(r4).forEach(([n3, a5]) => {
      a5 === "_undefined_" ? r4[n3] = void 0 : t4.get(a5) || (t4.set(a5, true), e2(a5));
    }), Array.isArray(r4) && r4.forEach((n3, a5) => {
      n3 === "_undefined_" ? (t4.set(n3, true), r4[a5] = void 0) : t4.get(n3) || (t4.set(n3, true), e2(n3));
    });
  }, "mutateUndefined");
}, "mutator");
var at = i3((t4, e2 = {}) => {
  let r4 = { ...Wt, ...e2 }, n3 = JSON.parse(t4, Kn(r4));
  return Yn()(n3), n3;
}, "parse");
var Zn = false;
var gt = "Invariant failed";
function q2(t4, e2) {
  if (!t4) {
    if (Zn)
      throw new Error(gt);
    var r4 = typeof e2 == "function" ? e2() : e2, n3 = r4 ? "".concat(gt, ": ").concat(r4) : gt;
    throw new Error(n3);
  }
}
i3(q2, "invariant");
var Bt = i3((t4) => {
  let e2 = Array.from(
    document.querySelectorAll("iframe[data-is-storybook]")
  ), [r4, ...n3] = e2.filter((l3) => {
    var _a2, _b;
    try {
      return ((_a2 = l3.contentWindow) == null ? void 0 : _a2.location.origin) === t4.source.location.origin && ((_b = l3.contentWindow) == null ? void 0 : _b.location.pathname) === t4.source.location.pathname;
    } catch {
    }
    try {
      return l3.contentWindow === t4.source;
    } catch {
    }
    let s4 = l3.getAttribute("src"), c3;
    try {
      if (!s4)
        return false;
      ({ origin: c3 } = new URL(s4, document.location.toString()));
    } catch {
      return false;
    }
    return c3 === t4.origin;
  }), a5 = r4 == null ? void 0 : r4.getAttribute("src");
  if (a5 && n3.length === 0) {
    let { protocol: l3, host: s4, pathname: c3 } = new URL(a5, document.location.toString());
    return `${l3}//${s4}${c3}`;
  }
  return n3.length > 0 && s.error("found multiple candidates for event source"), null;
}, "getEventSourceUrl");
var { document: mt, location: vt } = b3;
var Gt = "storybook-channel";
var to = { allowFunction: false, maxDepth: 25 };
var _t = class _t2 {
  constructor(e2) {
    this.config = e2;
    this.connected = false;
    if (this.buffer = [], typeof (b3 == null ? void 0 : b3.addEventListener) == "function" && b3.addEventListener("message", this.handleEvent.bind(this), false), e2.page !== "manager" && e2.page !== "preview")
      throw new Error(`postmsg-channel: "config.page" cannot be "${e2.page}"`);
  }
  setHandler(e2) {
    this.handler = (...r4) => {
      e2.apply(this, r4), !this.connected && this.getLocalFrame().length && (this.flush(), this.connected = true);
    };
  }
  /**
   * Sends `event` to the associated window. If the window does not yet exist the event will be
   * stored in a buffer and sent when the window exists.
   *
   * @param event
   */
  send(e2, r4) {
    let {
      target: n3,
      // telejson options
      allowRegExp: a5,
      allowFunction: l3,
      allowSymbol: s4,
      allowDate: c3,
      allowError: o3,
      allowUndefined: h5,
      allowClass: u5,
      maxDepth: p6,
      space: d3,
      lazyEval: g3
    } = r4 || {}, y4 = Object.fromEntries(
      Object.entries({
        allowRegExp: a5,
        allowFunction: l3,
        allowSymbol: s4,
        allowDate: c3,
        allowError: o3,
        allowUndefined: h5,
        allowClass: u5,
        maxDepth: p6,
        space: d3,
        lazyEval: g3
      }).filter(([I6, P7]) => typeof P7 < "u")
    ), m4 = {
      ...to,
      ...b3.CHANNEL_OPTIONS || {},
      ...y4
    }, v6 = this.getFrames(n3), C6 = new URLSearchParams((vt == null ? void 0 : vt.search) || ""), w6 = ot(
      {
        key: Gt,
        event: e2,
        refId: C6.get("refId")
      },
      m4
    );
    return v6.length ? (this.buffer.length && this.flush(), v6.forEach((I6) => {
      try {
        I6.postMessage(w6, "*");
      } catch {
        s.error("sending over postmessage fail");
      }
    }), Promise.resolve(null)) : new Promise((I6, P7) => {
      this.buffer.push({ event: e2, resolve: I6, reject: P7 });
    });
  }
  flush() {
    let { buffer: e2 } = this;
    this.buffer = [], e2.forEach((r4) => {
      this.send(r4.event).then(r4.resolve).catch(r4.reject);
    });
  }
  getFrames(e2) {
    if (this.config.page === "manager") {
      let n3 = Array.from(
        mt.querySelectorAll("iframe[data-is-storybook][data-is-loaded]")
      ).flatMap((a5) => {
        try {
          return a5.contentWindow && a5.dataset.isStorybook !== void 0 && a5.id === e2 ? [a5.contentWindow] : [];
        } catch {
          return [];
        }
      });
      return (n3 == null ? void 0 : n3.length) ? n3 : this.getCurrentFrames();
    }
    return b3 && b3.parent && b3.parent !== b3.self ? [b3.parent] : [];
  }
  getCurrentFrames() {
    return this.config.page === "manager" ? Array.from(
      mt.querySelectorAll('[data-is-storybook="true"]')
    ).flatMap((r4) => r4.contentWindow ? [r4.contentWindow] : []) : b3 && b3.parent ? [b3.parent] : [];
  }
  getLocalFrame() {
    return this.config.page === "manager" ? Array.from(
      mt.querySelectorAll("#storybook-preview-iframe")
    ).flatMap((r4) => r4.contentWindow ? [r4.contentWindow] : []) : b3 && b3.parent ? [b3.parent] : [];
  }
  handleEvent(e2) {
    try {
      let { data: r4 } = e2, { key: n3, event: a5, refId: l3 } = typeof r4 == "string" && H2(r4) ? at(r4, b3.CHANNEL_OPTIONS || {}) : r4;
      if (n3 === Gt) {
        let s4 = this.config.page === "manager" ? '<span style="color: #37D5D3; background: black"> manager </span>' : '<span style="color: #1EA7FD; background: black"> preview </span>', c3 = Object.values(core_events_exports).includes(a5.type) ? `<span style="color: #FF4785">${a5.type}</span>` : `<span style="color: #FFAE00">${a5.type}</span>`;
        if (l3 && (a5.refId = l3), a5.source = this.config.page === "preview" ? e2.origin : Bt(e2), !a5.source) {
          r.error(
            `${s4} received ${c3} but was unable to determine the source of the event`
          );
          return;
        }
        let o3 = `${s4} received ${c3} (${r4.length})`;
        r.debug(
          vt.origin !== a5.source ? o3 : `${o3} <span style="color: gray">(on ${vt.origin} from ${a5.source})</span>`,
          ...a5.args
        ), q2(this.handler, "ChannelHandler should be set"), this.handler(a5);
      }
    } catch (r4) {
      s.error(r4);
    }
  }
};
i3(_t, "PostMessageTransport");
var G2 = _t;
var { WebSocket: eo } = b3;
var bt = class bt2 {
  constructor({ url: e2, onError: r4, page: n3 }) {
    this.buffer = [];
    this.isReady = false;
    this.socket = new eo(e2), this.socket.onopen = () => {
      this.isReady = true, this.flush();
    }, this.socket.onmessage = ({ data: a5 }) => {
      let l3 = typeof a5 == "string" && H2(a5) ? at(a5) : a5;
      q2(this.handler, "WebsocketTransport handler should be set"), this.handler(l3);
    }, this.socket.onerror = (a5) => {
      r4 && r4(a5);
    }, this.socket.onclose = () => {
      q2(this.handler, "WebsocketTransport handler should be set"), this.handler({ type: S, args: [], from: n3 || "preview" });
    };
  }
  setHandler(e2) {
    this.handler = e2;
  }
  send(e2) {
    this.isReady ? this.sendNow(e2) : this.sendLater(e2);
  }
  sendLater(e2) {
    this.buffer.push(e2);
  }
  sendNow(e2) {
    let r4 = ot(e2, {
      maxDepth: 15,
      allowFunction: false,
      ...b3.CHANNEL_OPTIONS
    });
    this.socket.send(r4);
  }
  flush() {
    let { buffer: e2 } = this;
    this.buffer = [], e2.forEach((r4) => this.send(r4));
  }
};
i3(bt, "WebsocketTransport");
var J2 = bt;
var { CONFIG_TYPE: ro } = b3;
var Mo = z2;
function $o({ page: t4, extraTransports: e2 = [] }) {
  let r4 = [new G2({ page: t4 }), ...e2];
  if (ro === "DEVELOPMENT") {
    let n3 = window.location.protocol === "http:" ? "ws" : "wss", { hostname: a5, port: l3 } = window.location, s4 = `${n3}://${a5}:${l3}/storybook-server-channel`;
    r4.push(new J2({ url: s4, onError: i3(() => {
    }, "onError"), page: t4 }));
  }
  return new z2({ transports: r4 });
}
i3($o, "createBrowserChannel");

// node_modules/@storybook/core/dist/preview-errors.js
var oe2 = Object.defineProperty;
var t3 = (u5, n3) => oe2(u5, "name", { value: n3, configurable: true });
function r3(u5) {
  for (var n3 = [], e2 = 1; e2 < arguments.length; e2++)
    n3[e2 - 1] = arguments[e2];
  var a5 = Array.from(typeof u5 == "string" ? [u5] : u5);
  a5[a5.length - 1] = a5[a5.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var g3 = a5.reduce(function(i4, m4) {
    var y4 = m4.match(/\n([\t ]+|(?!\s).)/g);
    return y4 ? i4.concat(y4.map(function(E2) {
      var l3, d3;
      return (d3 = (l3 = E2.match(/[\t ]/g)) === null || l3 === void 0 ? void 0 : l3.length) !== null && d3 !== void 0 ? d3 : 0;
    })) : i4;
  }, []);
  if (g3.length) {
    var h5 = new RegExp(`
[	 ]{` + Math.min.apply(Math, g3) + "}", "g");
    a5 = a5.map(function(i4) {
      return i4.replace(h5, `
`);
    });
  }
  a5[0] = a5[0].replace(/^\r?\n/, "");
  var c3 = a5[0];
  return n3.forEach(function(i4, m4) {
    var y4 = c3.match(/(?:^|\n)( *)$/), E2 = y4 ? y4[1] : "", l3 = i4;
    typeof i4 == "string" && i4.includes(`
`) && (l3 = String(i4).split(`
`).map(function(d3, te3) {
      return te3 === 0 ? d3 : "" + E2 + d3;
    }).join(`
`)), c3 += l3 + a5[m4 + 1];
  }), c3;
}
t3(r3, "dedent");
function C2({
  code: u5,
  category: n3
}) {
  let e2 = String(u5).padStart(4, "0");
  return `SB_${n3}_${e2}`;
}
t3(C2, "parseErrorCode");
var p2 = class p3 extends Error {
  constructor(e2) {
    super(p3.getFullMessage(e2));
    this.data = {};
    this.fromStorybook = true;
    this.category = e2.category, this.documentation = e2.documentation ?? false, this.code = e2.code;
  }
  get fullErrorCode() {
    return C2({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    let e2 = this.constructor.name;
    return `${this.fullErrorCode} (${e2})`;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation: e2,
    code: a5,
    category: g3,
    message: h5
  }) {
    let c3;
    return e2 === true ? c3 = `https://storybook.js.org/error/${C2({ code: a5, category: g3 })}` : typeof e2 == "string" ? c3 = e2 : Array.isArray(e2) && (c3 = `
${e2.map((i4) => `	- ${i4}`).join(`
`)}`), `${h5}${c3 != null ? `

More info: ${c3}
` : ""}`;
  }
};
t3(p2, "StorybookError");
var o2 = p2;
var se2 = ((s4) => (s4.BLOCKS = "BLOCKS", s4.DOCS_TOOLS = "DOCS-TOOLS", s4.PREVIEW_CLIENT_LOGGER = "PREVIEW_CLIENT-LOGGER", s4.PREVIEW_CHANNELS = "PREVIEW_CHANNELS", s4.PREVIEW_CORE_EVENTS = "PREVIEW_CORE-EVENTS", s4.PREVIEW_INSTRUMENTER = "PREVIEW_INSTRUMENTER", s4.PREVIEW_API = "PREVIEW_API", s4.PREVIEW_REACT_DOM_SHIM = "PREVIEW_REACT-DOM-SHIM", s4.PREVIEW_ROUTER = "PREVIEW_ROUTER", s4.PREVIEW_THEMING = "PREVIEW_THEMING", s4.RENDERER_HTML = "RENDERER_HTML", s4.RENDERER_PREACT = "RENDERER_PREACT", s4.RENDERER_REACT = "RENDERER_REACT", s4.RENDERER_SERVER = "RENDERER_SERVER", s4.RENDERER_SVELTE = "RENDERER_SVELTE", s4.RENDERER_VUE = "RENDERER_VUE", s4.RENDERER_VUE3 = "RENDERER_VUE3", s4.RENDERER_WEB_COMPONENTS = "RENDERER_WEB-COMPONENTS", s4.FRAMEWORK_NEXTJS = "FRAMEWORK_NEXTJS", s4.ADDON_VITEST = "ADDON_VITEST", s4))(se2 || {});
var f3 = class f4 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 1,
      message: r3`
        Couldn't find story matching id '${e2.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${e2.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
    });
    this.data = e2;
  }
};
t3(f3, "MissingStoryAfterHmrError");
var D3 = f3;
var R2 = class R3 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 2,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
      message: r3`
        We detected that you use an implicit action arg while ${e2.phase} of your story.  
        ${e2.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from '@storybook/test';
          ... 
          args: {
           ${e2.name}: fn()
          }`
    });
    this.data = e2;
  }
};
t3(R2, "ImplicitActionsDuringRendering");
var b4 = class b5 extends o2 {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 3,
      message: r3`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
    });
  }
};
t3(b4, "CalledExtractOnStoreError");
var L3 = b4;
var I2 = class I3 extends o2 {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 4,
      message: r3`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    });
  }
};
t3(I2, "MissingRenderToCanvasError");
var G3 = I2;
var P2 = class P3 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 5,
      message: r3`
        Called \`Preview.${e2.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${e2.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
    });
    this.data = e2;
  }
};
t3(P2, "CalledPreviewMethodBeforeInitializationError");
var Y2 = P2;
var x3 = class x4 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 6,
      message: r3`
        Error fetching \`/index.json\`:
        
        ${e2.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
    });
    this.data = e2;
  }
};
t3(x3, "StoryIndexFetchError");
var M3 = x3;
var T2 = class T3 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 7,
      message: r3`
        Tried to render docs entry ${e2.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
    });
    this.data = e2;
  }
};
t3(T2, "MdxFileWithNoCsfReferencesError");
var H3 = T2;
var w2 = class w3 extends o2 {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 8,
      message: r3`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
    });
  }
};
t3(w2, "EmptyIndexError");
var F2 = w2;
var k3 = class k4 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 9,
      message: r3`
        Couldn't find story matching '${e2.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
    });
    this.data = e2;
  }
};
t3(k3, "NoStoryMatchError");
var K2 = k3;
var S2 = class S3 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 10,
      message: r3`
        Couldn't find story matching id '${e2.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
    });
    this.data = e2;
  }
};
t3(S2, "MissingStoryFromCsfFileError");
var X2 = S2;
var v2 = class v3 extends o2 {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 11,
      message: r3`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
    });
  }
};
t3(v2, "StoryStoreAccessedBeforeInitializationError");
var U3 = v2;
var _2 = class _3 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 12,
      message: r3`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${e2.playFunction}`
    });
    this.data = e2;
  }
};
t3(_2, "MountMustBeDestructuredError");
var J3 = _2;
var V2 = class V3 extends o2 {
  constructor(e2) {
    super({
      category: "PREVIEW_API",
      code: 14,
      message: r3`
        No render function available for storyId '${e2.id}'
      `
    });
    this.data = e2;
  }
};
t3(V2, "NoRenderFunctionError");
var q3 = V2;
var N2 = class N3 extends o2 {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 15,
      message: r3`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          //  mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
    });
  }
};
t3(N2, "NoStoryMountedError");
var z3 = N2;
var A2 = class A3 extends o2 {
  constructor() {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 1,
      documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
      message: r3`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
    });
  }
};
t3(A2, "NextJsSharpError");
var W3 = class W4 extends o2 {
  constructor(e2) {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 2,
      message: r3`
        Tried to access router mocks from "${e2.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
    });
    this.data = e2;
  }
};
t3(W3, "NextjsRouterMocksNotAvailable");
var $3 = class $4 extends o2 {
  constructor(e2) {
    super({
      category: "DOCS-TOOLS",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/issues/26606",
      message: r3`
        There was a failure when generating detailed ArgTypes in ${e2.language} for:
        ${JSON.stringify(e2.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
    });
    this.data = e2;
  }
};
t3($3, "UnknownArgTypesError");
var O2 = class O3 extends o2 {
  constructor(e2) {
    super({
      category: "ADDON_VITEST",
      code: 1,
      // TODO: Add documentation about viewports support
      // documentation: '',
      message: r3`
        Encountered an unsupported value "${e2.value}" when setting the viewport ${e2.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
    });
    this.data = e2;
  }
};
t3(O2, "UnsupportedViewportDimensionError");

// node_modules/@storybook/csf/dist/index.mjs
var C3 = Object.create;
var u3 = Object.defineProperty;
var B3 = Object.getOwnPropertyDescriptor;
var F3 = Object.getOwnPropertyNames;
var h2 = Object.getPrototypeOf;
var w4 = Object.prototype.hasOwnProperty;
var E = (r4, e2) => () => (e2 || r4((e2 = { exports: {} }).exports, e2), e2.exports);
var v4 = (r4, e2, n3, t4) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let a5 of F3(e2)) !w4.call(r4, a5) && a5 !== n3 && u3(r4, a5, { get: () => e2[a5], enumerable: !(t4 = B3(e2, a5)) || t4.enumerable });
  return r4;
};
var I4 = (r4, e2, n3) => (n3 = r4 != null ? C3(h2(r4)) : {}, v4(e2 || !r4 || !r4.__esModule ? u3(n3, "default", { value: r4, enumerable: true }) : n3, r4));
var x5 = E((T4) => {
  Object.defineProperty(T4, "__esModule", { value: true }), T4.isEqual = /* @__PURE__ */ function() {
    var r4 = Object.prototype.toString, e2 = Object.getPrototypeOf, n3 = Object.getOwnPropertySymbols ? function(t4) {
      return Object.keys(t4).concat(Object.getOwnPropertySymbols(t4));
    } : Object.keys;
    return function(t4, a5) {
      return function i4(o3, s4, p6) {
        var g3, y4, d3, c3 = r4.call(o3), b6 = r4.call(s4);
        if (o3 === s4) return true;
        if (o3 == null || s4 == null) return false;
        if (p6.indexOf(o3) > -1 && p6.indexOf(s4) > -1) return true;
        if (p6.push(o3, s4), c3 != b6 || (g3 = n3(o3), y4 = n3(s4), g3.length != y4.length || g3.some(function(A4) {
          return !i4(o3[A4], s4[A4], p6);
        }))) return false;
        switch (c3.slice(8, -1)) {
          case "Symbol":
            return o3.valueOf() == s4.valueOf();
          case "Date":
          case "Number":
            return +o3 == +s4 || +o3 != +o3 && +s4 != +s4;
          case "RegExp":
          case "Function":
          case "String":
          case "Boolean":
            return "" + o3 == "" + s4;
          case "Set":
          case "Map":
            g3 = o3.entries(), y4 = s4.entries();
            do
              if (!i4((d3 = g3.next()).value, y4.next().value, p6)) return false;
            while (!d3.done);
            return true;
          case "ArrayBuffer":
            o3 = new Uint8Array(o3), s4 = new Uint8Array(s4);
          case "DataView":
            o3 = new Uint8Array(o3.buffer), s4 = new Uint8Array(s4.buffer);
          case "Float32Array":
          case "Float64Array":
          case "Int8Array":
          case "Int16Array":
          case "Int32Array":
          case "Uint8Array":
          case "Uint16Array":
          case "Uint32Array":
          case "Uint8ClampedArray":
          case "Arguments":
          case "Array":
            if (o3.length != s4.length) return false;
            for (d3 = 0; d3 < o3.length; d3++) if ((d3 in o3 || d3 in s4) && (d3 in o3 != d3 in s4 || !i4(o3[d3], s4[d3], p6))) return false;
            return true;
          case "Object":
            return i4(e2(o3), e2(s4), p6);
          default:
            return false;
        }
      }(t4, a5, []);
    };
  }();
});
function R4(r4) {
  return r4.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (e2, n3, t4, a5) => `${n3} ${t4}${a5}`).replace(/([a-z])([A-Z])/g, (e2, n3, t4) => `${n3} ${t4}`).replace(/([a-z])([0-9])/gi, (e2, n3, t4) => `${n3} ${t4}`).replace(/([0-9])([a-z])/gi, (e2, n3, t4) => `${n3} ${t4}`).replace(/(\s|^)(\w)/g, (e2, n3, t4) => `${n3}${t4.toUpperCase()}`).replace(/ +/g, " ").trim();
}
var l2 = I4(x5());
var S4 = (r4) => r4.map((e2) => typeof e2 < "u").filter(Boolean).length;
var k5 = (r4, e2) => {
  let { exists: n3, eq: t4, neq: a5, truthy: i4 } = r4;
  if (S4([n3, t4, a5, i4]) > 1) throw new Error(`Invalid conditional test ${JSON.stringify({ exists: n3, eq: t4, neq: a5 })}`);
  if (typeof t4 < "u") return (0, l2.isEqual)(e2, t4);
  if (typeof a5 < "u") return !(0, l2.isEqual)(e2, a5);
  if (typeof n3 < "u") {
    let s4 = typeof e2 < "u";
    return n3 ? s4 : !s4;
  }
  return (typeof i4 > "u" ? true : i4) ? !!e2 : !e2;
};
var P4 = (r4, e2, n3) => {
  if (!r4.if) return true;
  let { arg: t4, global: a5 } = r4.if;
  if (S4([t4, a5]) !== 1) throw new Error(`Invalid conditional value ${JSON.stringify({ arg: t4, global: a5 })}`);
  let i4 = t4 ? e2[t4] : n3[a5];
  return k5(r4.if, i4);
};
var O4 = (r4) => r4.toLowerCase().replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
var f5 = (r4, e2) => {
  let n3 = O4(r4);
  if (n3 === "") throw new Error(`Invalid ${e2} '${r4}', must include alphanumeric characters`);
  return n3;
};
var G4 = (r4, e2) => `${f5(r4, "kind")}${e2 ? `--${f5(e2, "name")}` : ""}`;
var N4 = (r4) => R4(r4);
function m3(r4, e2) {
  return Array.isArray(e2) ? e2.includes(r4) : r4.match(e2);
}
function M4(r4, { includeStories: e2, excludeStories: n3 }) {
  return r4 !== "__esModule" && (!e2 || m3(r4, e2)) && (!n3 || !m3(r4, n3));
}
var z4 = (...r4) => {
  let e2 = r4.reduce((n3, t4) => (t4.startsWith("!") ? n3.delete(t4.slice(1)) : n3.add(t4), n3), /* @__PURE__ */ new Set());
  return Array.from(e2);
};

// node_modules/@storybook/core/dist/preview-api/index.js
var On2 = Object.create;
var ur2 = Object.defineProperty;
var Dn2 = Object.getOwnPropertyDescriptor;
var kn2 = Object.getOwnPropertyNames;
var jn2 = Object.getPrototypeOf;
var Mn2 = Object.prototype.hasOwnProperty;
var s3 = (r4, e2) => ur2(r4, "name", { value: e2, configurable: true });
var Re2 = ((r4) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(r4, {
  get: (e2, t4) => (typeof __require < "u" ? __require : e2)[t4]
}) : r4)(function(r4) {
  if (typeof __require < "u") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + r4 + '" is not supported');
});
var O5 = (r4, e2) => () => (e2 || r4((e2 = { exports: {} }).exports, e2), e2.exports);
var _n2 = (r4, e2, t4, o3) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function")
    for (let n3 of kn2(e2))
      !Mn2.call(r4, n3) && n3 !== t4 && ur2(r4, n3, { get: () => e2[n3], enumerable: !(o3 = Dn2(e2, n3)) || o3.enumerable });
  return r4;
};
var ce2 = (r4, e2, t4) => (t4 = r4 != null ? On2(jn2(r4)) : {}, _n2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e2 || !r4 || !r4.__esModule ? ur2(t4, "default", { value: r4, enumerable: true }) : t4,
  r4
));
var Ir2 = O5((Kt, Fr2) => {
  (function(r4) {
    if (typeof Kt == "object" && typeof Fr2 < "u")
      Fr2.exports = r4();
    else if (typeof define == "function" && define.amd)
      define([], r4);
    else {
      var e2;
      typeof window < "u" ? e2 = window : typeof global < "u" ? e2 = global : typeof self < "u" ? e2 = self : e2 = this, e2.memoizerific = r4();
    }
  })(function() {
    var r4, e2, t4;
    return s3(function o3(n3, i4, a5) {
      function l3(p6, u5) {
        if (!i4[p6]) {
          if (!n3[p6]) {
            var m4 = typeof Re2 == "function" && Re2;
            if (!u5 && m4) return m4(p6, true);
            if (c3) return c3(p6, true);
            var h5 = new Error("Cannot find module '" + p6 + "'");
            throw h5.code = "MODULE_NOT_FOUND", h5;
          }
          var b6 = i4[p6] = { exports: {} };
          n3[p6][0].call(b6.exports, function(y4) {
            var S5 = n3[p6][1][y4];
            return l3(S5 || y4);
          }, b6, b6.exports, o3, n3, i4, a5);
        }
        return i4[p6].exports;
      }
      s3(l3, "s");
      for (var c3 = typeof Re2 == "function" && Re2, d3 = 0; d3 < a5.length; d3++) l3(a5[d3]);
      return l3;
    }, "e")({ 1: [function(o3, n3, i4) {
      n3.exports = function(a5) {
        if (typeof Map != "function" || a5) {
          var l3 = o3("./similar");
          return new l3();
        } else
          return /* @__PURE__ */ new Map();
      };
    }, { "./similar": 2 }], 2: [function(o3, n3, i4) {
      function a5() {
        return this.list = [], this.lastItem = void 0, this.size = 0, this;
      }
      s3(a5, "Similar"), a5.prototype.get = function(l3) {
        var c3;
        if (this.lastItem && this.isEqual(this.lastItem.key, l3))
          return this.lastItem.val;
        if (c3 = this.indexOf(l3), c3 >= 0)
          return this.lastItem = this.list[c3], this.list[c3].val;
      }, a5.prototype.set = function(l3, c3) {
        var d3;
        return this.lastItem && this.isEqual(this.lastItem.key, l3) ? (this.lastItem.val = c3, this) : (d3 = this.indexOf(l3), d3 >= 0 ? (this.lastItem = this.list[d3], this.list[d3].val = c3, this) : (this.lastItem = { key: l3, val: c3 }, this.list.push(this.lastItem), this.size++, this));
      }, a5.prototype.delete = function(l3) {
        var c3;
        if (this.lastItem && this.isEqual(this.lastItem.key, l3) && (this.lastItem = void 0), c3 = this.indexOf(l3), c3 >= 0)
          return this.size--, this.list.splice(c3, 1)[0];
      }, a5.prototype.has = function(l3) {
        var c3;
        return this.lastItem && this.isEqual(this.lastItem.key, l3) ? true : (c3 = this.indexOf(l3), c3 >= 0 ? (this.lastItem = this.list[c3], true) : false);
      }, a5.prototype.forEach = function(l3, c3) {
        var d3;
        for (d3 = 0; d3 < this.size; d3++)
          l3.call(c3 || this, this.list[d3].val, this.list[d3].key, this);
      }, a5.prototype.indexOf = function(l3) {
        var c3;
        for (c3 = 0; c3 < this.size; c3++)
          if (this.isEqual(this.list[c3].key, l3))
            return c3;
        return -1;
      }, a5.prototype.isEqual = function(l3, c3) {
        return l3 === c3 || l3 !== l3 && c3 !== c3;
      }, n3.exports = a5;
    }, {}], 3: [function(o3, n3, i4) {
      var a5 = o3("map-or-similar");
      n3.exports = function(p6) {
        var u5 = new a5(false), m4 = [];
        return function(h5) {
          var b6 = s3(function() {
            var y4 = u5, S5, x7, f8 = arguments.length - 1, g3 = Array(f8 + 1), R5 = true, T4;
            if ((b6.numArgs || b6.numArgs === 0) && b6.numArgs !== f8 + 1)
              throw new Error("Memoizerific functions should always be called with the same number of arguments");
            for (T4 = 0; T4 < f8; T4++) {
              if (g3[T4] = {
                cacheItem: y4,
                arg: arguments[T4]
              }, y4.has(arguments[T4])) {
                y4 = y4.get(arguments[T4]);
                continue;
              }
              R5 = false, S5 = new a5(false), y4.set(arguments[T4], S5), y4 = S5;
            }
            return R5 && (y4.has(arguments[f8]) ? x7 = y4.get(arguments[f8]) : R5 = false), R5 || (x7 = h5.apply(null, arguments), y4.set(arguments[f8], x7)), p6 > 0 && (g3[f8] = {
              cacheItem: y4,
              arg: arguments[f8]
            }, R5 ? l3(m4, g3) : m4.push(g3), m4.length > p6 && c3(m4.shift())), b6.wasMemoized = R5, b6.numArgs = f8 + 1, x7;
          }, "memoizerific");
          return b6.limit = p6, b6.wasMemoized = false, b6.cache = u5, b6.lru = m4, b6;
        };
      };
      function l3(p6, u5) {
        var m4 = p6.length, h5 = u5.length, b6, y4, S5;
        for (y4 = 0; y4 < m4; y4++) {
          for (b6 = true, S5 = 0; S5 < h5; S5++)
            if (!d3(p6[y4][S5].arg, u5[S5].arg)) {
              b6 = false;
              break;
            }
          if (b6)
            break;
        }
        p6.push(p6.splice(y4, 1)[0]);
      }
      s3(l3, "moveToMostRecentLru");
      function c3(p6) {
        var u5 = p6.length, m4 = p6[u5 - 1], h5, b6;
        for (m4.cacheItem.delete(m4.arg), b6 = u5 - 2; b6 >= 0 && (m4 = p6[b6], h5 = m4.cacheItem.get(m4.arg), !h5 || !h5.size); b6--)
          m4.cacheItem.delete(m4.arg);
      }
      s3(c3, "removeCachedResult");
      function d3(p6, u5) {
        return p6 === u5 || p6 !== p6 && u5 !== u5;
      }
      s3(d3, "isEqual");
    }, { "map-or-similar": 1 }] }, {}, [3])(3);
  });
});
var et2 = O5((Zr2) => {
  "use strict";
  Object.defineProperty(Zr2, "__esModule", { value: true });
  Zr2.encodeString = _i;
  var B4 = Array.from({ length: 256 }, (r4, e2) => "%" + ((e2 < 16 ? "0" : "") + e2.toString(16)).toUpperCase()), Mi = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  function _i(r4) {
    let e2 = r4.length;
    if (e2 === 0)
      return "";
    let t4 = "", o3 = 0, n3 = 0;
    e: for (; n3 < e2; n3++) {
      let i4 = r4.charCodeAt(n3);
      for (; i4 < 128; ) {
        if (Mi[i4] !== 1 && (o3 < n3 && (t4 += r4.slice(o3, n3)), o3 = n3 + 1, t4 += B4[i4]), ++n3 === e2)
          break e;
        i4 = r4.charCodeAt(n3);
      }
      if (o3 < n3 && (t4 += r4.slice(o3, n3)), i4 < 2048) {
        o3 = n3 + 1, t4 += B4[192 | i4 >> 6] + B4[128 | i4 & 63];
        continue;
      }
      if (i4 < 55296 || i4 >= 57344) {
        o3 = n3 + 1, t4 += B4[224 | i4 >> 12] + B4[128 | i4 >> 6 & 63] + B4[128 | i4 & 63];
        continue;
      }
      if (++n3, n3 >= e2)
        throw new Error("URI malformed");
      let a5 = r4.charCodeAt(n3) & 1023;
      o3 = n3 + 1, i4 = 65536 + ((i4 & 1023) << 10 | a5), t4 += B4[240 | i4 >> 18] + B4[128 | i4 >> 12 & 63] + B4[128 | i4 >> 6 & 63] + B4[128 | i4 & 63];
    }
    return o3 === 0 ? r4 : o3 < e2 ? t4 + r4.slice(o3) : t4;
  }
  s3(_i, "encodeString");
});
var Qe2 = O5((z5) => {
  "use strict";
  Object.defineProperty(z5, "__esModule", { value: true });
  z5.defaultOptions = z5.defaultShouldSerializeObject = z5.defaultValueSerializer = void 0;
  var rt2 = et2(), Li = s3((r4) => {
    switch (typeof r4) {
      case "string":
        return (0, rt2.encodeString)(r4);
      case "bigint":
      case "boolean":
        return "" + r4;
      case "number":
        if (Number.isFinite(r4))
          return r4 < 1e21 ? "" + r4 : (0, rt2.encodeString)("" + r4);
        break;
    }
    return r4 instanceof Date ? (0, rt2.encodeString)(r4.toISOString()) : "";
  }, "defaultValueSerializer");
  z5.defaultValueSerializer = Li;
  var Ni = s3((r4) => r4 instanceof Date, "defaultShouldSerializeObject");
  z5.defaultShouldSerializeObject = Ni;
  var Io = s3((r4) => r4, "identityFunc");
  z5.defaultOptions = {
    nesting: true,
    nestingSyntax: "dot",
    arrayRepeat: false,
    arrayRepeatSyntax: "repeat",
    delimiter: 38,
    valueDeserializer: Io,
    valueSerializer: z5.defaultValueSerializer,
    keyDeserializer: Io,
    shouldSerializeObject: z5.defaultShouldSerializeObject
  };
});
var tt2 = O5((Ze2) => {
  "use strict";
  Object.defineProperty(Ze2, "__esModule", { value: true });
  Ze2.getDeepObject = zi;
  Ze2.stringifyObject = Oo;
  var se3 = Qe2(), qi = et2();
  function Bi(r4) {
    return r4 === "__proto__" || r4 === "constructor" || r4 === "prototype";
  }
  s3(Bi, "isPrototypeKey");
  function zi(r4, e2, t4, o3, n3) {
    if (Bi(e2))
      return r4;
    let i4 = r4[e2];
    return typeof i4 == "object" && i4 !== null ? i4 : !o3 && (n3 || typeof t4 == "number" || typeof t4 == "string" && t4 * 0 === 0 && t4.indexOf(".") === -1) ? r4[e2] = [] : r4[e2] = {};
  }
  s3(zi, "getDeepObject");
  var Gi = 20, Vi = "[]", Ui = "[", Hi = "]", Wi = ".";
  function Oo(r4, e2, t4 = 0, o3, n3) {
    let { nestingSyntax: i4 = se3.defaultOptions.nestingSyntax, arrayRepeat: a5 = se3.defaultOptions.arrayRepeat, arrayRepeatSyntax: l3 = se3.defaultOptions.arrayRepeatSyntax, nesting: c3 = se3.defaultOptions.nesting, delimiter: d3 = se3.defaultOptions.delimiter, valueSerializer: p6 = se3.defaultOptions.valueSerializer, shouldSerializeObject: u5 = se3.defaultOptions.shouldSerializeObject } = e2, m4 = typeof d3 == "number" ? String.fromCharCode(
      d3
    ) : d3, h5 = n3 === true && a5, b6 = i4 === "dot" || i4 === "js" && !n3;
    if (t4 > Gi)
      return "";
    let y4 = "", S5 = true, x7 = false;
    for (let f8 in r4) {
      let g3 = r4[f8], R5;
      o3 ? (R5 = o3, h5 ? l3 === "bracket" && (R5 += Vi) : b6 ? (R5 += Wi, R5 += f8) : (R5 += Ui, R5 += f8, R5 += Hi)) : R5 = f8, S5 || (y4 += m4), typeof g3 == "object" && g3 !== null && !u5(g3) ? (x7 = g3.pop !== void 0, (c3 || a5 && x7) && (y4 += Oo(g3, e2, t4 + 1, R5, x7))) : (y4 += (0, qi.encodeString)(R5), y4 += "=", y4 += p6(g3, f8)), S5 && (S5 = false);
    }
    return y4;
  }
  s3(Oo, "stringifyObject");
});
var Mo2 = O5((gu, jo) => {
  "use strict";
  var Do = 12, $i = 0, ot2 = [
    // The first part of the table maps bytes to character to a transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    // The second part of the table maps a state to a new state when adding a
    // transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // The third part maps the current transition to a mask that needs to apply
    // to the byte.
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  function Yi(r4) {
    var e2 = r4.indexOf("%");
    if (e2 === -1) return r4;
    for (var t4 = r4.length, o3 = "", n3 = 0, i4 = 0, a5 = e2, l3 = Do; e2 > -1 && e2 < t4; ) {
      var c3 = ko(r4[e2 + 1], 4), d3 = ko(r4[e2 + 2], 0), p6 = c3 | d3, u5 = ot2[p6];
      if (l3 = ot2[256 + l3 + u5], i4 = i4 << 6 | p6 & ot2[364 + u5], l3 === Do)
        o3 += r4.slice(n3, a5), o3 += i4 <= 65535 ? String.fromCharCode(i4) : String.fromCharCode(
          55232 + (i4 >> 10),
          56320 + (i4 & 1023)
        ), i4 = 0, n3 = e2 + 3, e2 = a5 = r4.indexOf("%", n3);
      else {
        if (l3 === $i)
          return null;
        if (e2 += 3, e2 < t4 && r4.charCodeAt(e2) === 37) continue;
        return null;
      }
    }
    return o3 + r4.slice(n3);
  }
  s3(Yi, "decodeURIComponent");
  var Ki = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  function ko(r4, e2) {
    var t4 = Ki[r4];
    return t4 === void 0 ? 255 : t4 << e2;
  }
  s3(ko, "hexCodeToInt");
  jo.exports = Yi;
});
var qo = O5((W5) => {
  "use strict";
  var Xi = W5 && W5.__importDefault || function(r4) {
    return r4 && r4.__esModule ? r4 : { default: r4 };
  };
  Object.defineProperty(W5, "__esModule", { value: true });
  W5.numberValueDeserializer = W5.numberKeyDeserializer = void 0;
  W5.parse = Zi;
  var er2 = tt2(), ie2 = Qe2(), _o = Xi(Mo2()), Ji = s3((r4) => {
    let e2 = Number(r4);
    return Number.isNaN(e2) ? r4 : e2;
  }, "numberKeyDeserializer");
  W5.numberKeyDeserializer = Ji;
  var Qi = s3((r4) => {
    let e2 = Number(r4);
    return Number.isNaN(e2) ? r4 : e2;
  }, "numberValueDeserializer");
  W5.numberValueDeserializer = Qi;
  var Lo = /\+/g, No = s3(function() {
  }, "Empty");
  No.prototype = /* @__PURE__ */ Object.create(null);
  function rr2(r4, e2, t4, o3, n3) {
    let i4 = r4.substring(e2, t4);
    return o3 && (i4 = i4.replace(Lo, " ")), n3 && (i4 = (0, _o.default)(i4) || i4), i4;
  }
  s3(rr2, "computeKeySlice");
  function Zi(r4, e2) {
    let { valueDeserializer: t4 = ie2.defaultOptions.valueDeserializer, keyDeserializer: o3 = ie2.defaultOptions.keyDeserializer, arrayRepeatSyntax: n3 = ie2.defaultOptions.arrayRepeatSyntax, nesting: i4 = ie2.defaultOptions.nesting, arrayRepeat: a5 = ie2.defaultOptions.arrayRepeat, nestingSyntax: l3 = ie2.defaultOptions.nestingSyntax, delimiter: c3 = ie2.defaultOptions.delimiter } = e2 ?? {}, d3 = typeof c3 == "string" ? c3.charCodeAt(0) : c3, p6 = l3 === "js", u5 = new No();
    if (typeof r4 != "string")
      return u5;
    let m4 = r4.length, h5 = "", b6 = -1, y4 = -1, S5 = -1, x7 = u5, f8, g3 = "", R5 = "", T4 = false, E2 = false, C6 = false, A4 = false, j2 = false, Z2 = false, Le2 = false, V4 = 0, Se2 = -1, Te2 = -1, bt3 = -1;
    for (let I6 = 0; I6 < m4 + 1; I6++) {
      if (V4 = I6 !== m4 ? r4.charCodeAt(I6) : d3, V4 === d3) {
        if (Le2 = y4 > b6, Le2 || (y4 = I6), S5 !== y4 - 1 && (R5 = rr2(r4, S5 + 1, Se2 > -1 ? Se2 : y4, C6, T4), g3 = o3(R5), f8 !== void 0 && (x7 = (0, er2.getDeepObject)(
          x7,
          f8,
          g3,
          p6 && j2,
          p6 && Z2
        ))), Le2 || g3 !== "") {
          Le2 && (h5 = r4.slice(y4 + 1, I6), A4 && (h5 = h5.replace(Lo, " ")), E2 && (h5 = (0, _o.default)(h5) || h5));
          let xe2 = t4(h5, g3);
          if (a5) {
            let Ne2 = x7[g3];
            Ne2 === void 0 ? Se2 > -1 ? x7[g3] = [xe2] : x7[g3] = xe2 : Ne2.pop ? Ne2.push(xe2) : x7[g3] = [Ne2, xe2];
          } else
            x7[g3] = xe2;
        }
        h5 = "", b6 = I6, y4 = I6, T4 = false, E2 = false, C6 = false, A4 = false, j2 = false, Z2 = false, Se2 = -1, S5 = I6, x7 = u5, f8 = void 0, g3 = "";
      } else V4 === 93 ? (a5 && n3 === "bracket" && bt3 === 91 && (Se2 = Te2), i4 && (l3 === "index" || p6) && y4 <= b6 && (S5 !== Te2 && (R5 = rr2(
        r4,
        S5 + 1,
        I6,
        C6,
        T4
      ), g3 = o3(R5), f8 !== void 0 && (x7 = (0, er2.getDeepObject)(x7, f8, g3, void 0, p6)), f8 = g3, C6 = false, T4 = false), S5 = I6, Z2 = true, j2 = false)) : V4 === 46 ? i4 && (l3 === "dot" || p6) && y4 <= b6 && (S5 !== Te2 && (R5 = rr2(r4, S5 + 1, I6, C6, T4), g3 = o3(R5), f8 !== void 0 && (x7 = (0, er2.getDeepObject)(
        x7,
        f8,
        g3,
        p6
      )), f8 = g3, C6 = false, T4 = false), j2 = true, Z2 = false, S5 = I6) : V4 === 91 ? i4 && (l3 === "index" || p6) && y4 <= b6 && (S5 !== Te2 && (R5 = rr2(
        r4,
        S5 + 1,
        I6,
        C6,
        T4
      ), g3 = o3(R5), p6 && f8 !== void 0 && (x7 = (0, er2.getDeepObject)(x7, f8, g3, p6)), f8 = g3, C6 = false, T4 = false, j2 = false, Z2 = true), S5 = I6) : V4 === 61 ? y4 <= b6 ? y4 = I6 : E2 = true : V4 === 43 ? y4 > b6 ? A4 = true : C6 = true : V4 === 37 && (y4 > b6 ? E2 = true : T4 = true);
      Te2 = I6, bt3 = V4;
    }
    return u5;
  }
  s3(Zi, "parse");
});
var Bo = O5((nt2) => {
  "use strict";
  Object.defineProperty(nt2, "__esModule", { value: true });
  nt2.stringify = ra;
  var ea = tt2();
  function ra(r4, e2) {
    if (r4 === null || typeof r4 != "object")
      return "";
    let t4 = e2 ?? {};
    return (0, ea.stringifyObject)(r4, t4);
  }
  s3(ra, "stringify");
});
var tr2 = O5((N5) => {
  "use strict";
  var ta = N5 && N5.__createBinding || (Object.create ? function(r4, e2, t4, o3) {
    o3 === void 0 && (o3 = t4);
    var n3 = Object.getOwnPropertyDescriptor(e2, t4);
    (!n3 || ("get" in n3 ? !e2.__esModule : n3.writable || n3.configurable)) && (n3 = { enumerable: true, get: s3(function() {
      return e2[t4];
    }, "get") }), Object.defineProperty(r4, o3, n3);
  } : function(r4, e2, t4, o3) {
    o3 === void 0 && (o3 = t4), r4[o3] = e2[t4];
  }), oa = N5 && N5.__exportStar || function(r4, e2) {
    for (var t4 in r4) t4 !== "default" && !Object.prototype.hasOwnProperty.call(e2, t4) && ta(e2, r4, t4);
  };
  Object.defineProperty(N5, "__esModule", { value: true });
  N5.stringify = N5.parse = void 0;
  var na = qo();
  Object.defineProperty(N5, "parse", { enumerable: true, get: s3(function() {
    return na.parse;
  }, "get") });
  var sa = Bo();
  Object.defineProperty(N5, "stringify", { enumerable: true, get: s3(function() {
    return sa.stringify;
  }, "get") });
  oa(Qe2(), N5);
});
var lt3 = O5((ju, fa) => {
  fa.exports = {
    Aacute: "",
    aacute: "",
    Abreve: "",
    abreve: "",
    ac: "",
    acd: "",
    acE: "",
    Acirc: "",
    acirc: "",
    acute: "",
    Acy: "",
    acy: "",
    AElig: "",
    aelig: "",
    af: "",
    Afr: "",
    afr: "",
    Agrave: "",
    agrave: "",
    alefsym: "",
    aleph: "",
    Alpha: "",
    alpha: "",
    Amacr: "",
    amacr: "",
    amalg: "",
    amp: "&",
    AMP: "&",
    andand: "",
    And: "",
    and: "",
    andd: "",
    andslope: "",
    andv: "",
    ang: "",
    ange: "",
    angle: "",
    angmsdaa: "",
    angmsdab: "",
    angmsdac: "",
    angmsdad: "",
    angmsdae: "",
    angmsdaf: "",
    angmsdag: "",
    angmsdah: "",
    angmsd: "",
    angrt: "",
    angrtvb: "",
    angrtvbd: "",
    angsph: "",
    angst: "",
    angzarr: "",
    Aogon: "",
    aogon: "",
    Aopf: "",
    aopf: "",
    apacir: "",
    ap: "",
    apE: "",
    ape: "",
    apid: "",
    apos: "'",
    ApplyFunction: "",
    approx: "",
    approxeq: "",
    Aring: "",
    aring: "",
    Ascr: "",
    ascr: "",
    Assign: "",
    ast: "*",
    asymp: "",
    asympeq: "",
    Atilde: "",
    atilde: "",
    Auml: "",
    auml: "",
    awconint: "",
    awint: "",
    backcong: "",
    backepsilon: "",
    backprime: "",
    backsim: "",
    backsimeq: "",
    Backslash: "",
    Barv: "",
    barvee: "",
    barwed: "",
    Barwed: "",
    barwedge: "",
    bbrk: "",
    bbrktbrk: "",
    bcong: "",
    Bcy: "",
    bcy: "",
    bdquo: "",
    becaus: "",
    because: "",
    Because: "",
    bemptyv: "",
    bepsi: "",
    bernou: "",
    Bernoullis: "",
    Beta: "",
    beta: "",
    beth: "",
    between: "",
    Bfr: "",
    bfr: "",
    bigcap: "",
    bigcirc: "",
    bigcup: "",
    bigodot: "",
    bigoplus: "",
    bigotimes: "",
    bigsqcup: "",
    bigstar: "",
    bigtriangledown: "",
    bigtriangleup: "",
    biguplus: "",
    bigvee: "",
    bigwedge: "",
    bkarow: "",
    blacklozenge: "",
    blacksquare: "",
    blacktriangle: "",
    blacktriangledown: "",
    blacktriangleleft: "",
    blacktriangleright: "",
    blank: "",
    blk12: "",
    blk14: "",
    blk34: "",
    block: "",
    bne: "=",
    bnequiv: "",
    bNot: "",
    bnot: "",
    Bopf: "",
    bopf: "",
    bot: "",
    bottom: "",
    bowtie: "",
    boxbox: "",
    boxdl: "",
    boxdL: "",
    boxDl: "",
    boxDL: "",
    boxdr: "",
    boxdR: "",
    boxDr: "",
    boxDR: "",
    boxh: "",
    boxH: "",
    boxhd: "",
    boxHd: "",
    boxhD: "",
    boxHD: "",
    boxhu: "",
    boxHu: "",
    boxhU: "",
    boxHU: "",
    boxminus: "",
    boxplus: "",
    boxtimes: "",
    boxul: "",
    boxuL: "",
    boxUl: "",
    boxUL: "",
    boxur: "",
    boxuR: "",
    boxUr: "",
    boxUR: "",
    boxv: "",
    boxV: "",
    boxvh: "",
    boxvH: "",
    boxVh: "",
    boxVH: "",
    boxvl: "",
    boxvL: "",
    boxVl: "",
    boxVL: "",
    boxvr: "",
    boxvR: "",
    boxVr: "",
    boxVR: "",
    bprime: "",
    breve: "",
    Breve: "",
    brvbar: "",
    bscr: "",
    Bscr: "",
    bsemi: "",
    bsim: "",
    bsime: "",
    bsolb: "",
    bsol: "\\",
    bsolhsub: "",
    bull: "",
    bullet: "",
    bump: "",
    bumpE: "",
    bumpe: "",
    Bumpeq: "",
    bumpeq: "",
    Cacute: "",
    cacute: "",
    capand: "",
    capbrcup: "",
    capcap: "",
    cap: "",
    Cap: "",
    capcup: "",
    capdot: "",
    CapitalDifferentialD: "",
    caps: "",
    caret: "",
    caron: "",
    Cayleys: "",
    ccaps: "",
    Ccaron: "",
    ccaron: "",
    Ccedil: "",
    ccedil: "",
    Ccirc: "",
    ccirc: "",
    Cconint: "",
    ccups: "",
    ccupssm: "",
    Cdot: "",
    cdot: "",
    cedil: "",
    Cedilla: "",
    cemptyv: "",
    cent: "",
    centerdot: "",
    CenterDot: "",
    cfr: "",
    Cfr: "",
    CHcy: "",
    chcy: "",
    check: "",
    checkmark: "",
    Chi: "",
    chi: "",
    circ: "",
    circeq: "",
    circlearrowleft: "",
    circlearrowright: "",
    circledast: "",
    circledcirc: "",
    circleddash: "",
    CircleDot: "",
    circledR: "",
    circledS: "",
    CircleMinus: "",
    CirclePlus: "",
    CircleTimes: "",
    cir: "",
    cirE: "",
    cire: "",
    cirfnint: "",
    cirmid: "",
    cirscir: "",
    ClockwiseContourIntegral: "",
    CloseCurlyDoubleQuote: "",
    CloseCurlyQuote: "",
    clubs: "",
    clubsuit: "",
    colon: ":",
    Colon: "",
    Colone: "",
    colone: "",
    coloneq: "",
    comma: ",",
    commat: "@",
    comp: "",
    compfn: "",
    complement: "",
    complexes: "",
    cong: "",
    congdot: "",
    Congruent: "",
    conint: "",
    Conint: "",
    ContourIntegral: "",
    copf: "",
    Copf: "",
    coprod: "",
    Coproduct: "",
    copy: "",
    COPY: "",
    copysr: "",
    CounterClockwiseContourIntegral: "",
    crarr: "",
    cross: "",
    Cross: "",
    Cscr: "",
    cscr: "",
    csub: "",
    csube: "",
    csup: "",
    csupe: "",
    ctdot: "",
    cudarrl: "",
    cudarrr: "",
    cuepr: "",
    cuesc: "",
    cularr: "",
    cularrp: "",
    cupbrcap: "",
    cupcap: "",
    CupCap: "",
    cup: "",
    Cup: "",
    cupcup: "",
    cupdot: "",
    cupor: "",
    cups: "",
    curarr: "",
    curarrm: "",
    curlyeqprec: "",
    curlyeqsucc: "",
    curlyvee: "",
    curlywedge: "",
    curren: "",
    curvearrowleft: "",
    curvearrowright: "",
    cuvee: "",
    cuwed: "",
    cwconint: "",
    cwint: "",
    cylcty: "",
    dagger: "",
    Dagger: "",
    daleth: "",
    darr: "",
    Darr: "",
    dArr: "",
    dash: "",
    Dashv: "",
    dashv: "",
    dbkarow: "",
    dblac: "",
    Dcaron: "",
    dcaron: "",
    Dcy: "",
    dcy: "",
    ddagger: "",
    ddarr: "",
    DD: "",
    dd: "",
    DDotrahd: "",
    ddotseq: "",
    deg: "",
    Del: "",
    Delta: "",
    delta: "",
    demptyv: "",
    dfisht: "",
    Dfr: "",
    dfr: "",
    dHar: "",
    dharl: "",
    dharr: "",
    DiacriticalAcute: "",
    DiacriticalDot: "",
    DiacriticalDoubleAcute: "",
    DiacriticalGrave: "`",
    DiacriticalTilde: "",
    diam: "",
    diamond: "",
    Diamond: "",
    diamondsuit: "",
    diams: "",
    die: "",
    DifferentialD: "",
    digamma: "",
    disin: "",
    div: "",
    divide: "",
    divideontimes: "",
    divonx: "",
    DJcy: "",
    djcy: "",
    dlcorn: "",
    dlcrop: "",
    dollar: "$",
    Dopf: "",
    dopf: "",
    Dot: "",
    dot: "",
    DotDot: "",
    doteq: "",
    doteqdot: "",
    DotEqual: "",
    dotminus: "",
    dotplus: "",
    dotsquare: "",
    doublebarwedge: "",
    DoubleContourIntegral: "",
    DoubleDot: "",
    DoubleDownArrow: "",
    DoubleLeftArrow: "",
    DoubleLeftRightArrow: "",
    DoubleLeftTee: "",
    DoubleLongLeftArrow: "",
    DoubleLongLeftRightArrow: "",
    DoubleLongRightArrow: "",
    DoubleRightArrow: "",
    DoubleRightTee: "",
    DoubleUpArrow: "",
    DoubleUpDownArrow: "",
    DoubleVerticalBar: "",
    DownArrowBar: "",
    downarrow: "",
    DownArrow: "",
    Downarrow: "",
    DownArrowUpArrow: "",
    DownBreve: "",
    downdownarrows: "",
    downharpoonleft: "",
    downharpoonright: "",
    DownLeftRightVector: "",
    DownLeftTeeVector: "",
    DownLeftVectorBar: "",
    DownLeftVector: "",
    DownRightTeeVector: "",
    DownRightVectorBar: "",
    DownRightVector: "",
    DownTeeArrow: "",
    DownTee: "",
    drbkarow: "",
    drcorn: "",
    drcrop: "",
    Dscr: "",
    dscr: "",
    DScy: "",
    dscy: "",
    dsol: "",
    Dstrok: "",
    dstrok: "",
    dtdot: "",
    dtri: "",
    dtrif: "",
    duarr: "",
    duhar: "",
    dwangle: "",
    DZcy: "",
    dzcy: "",
    dzigrarr: "",
    Eacute: "",
    eacute: "",
    easter: "",
    Ecaron: "",
    ecaron: "",
    Ecirc: "",
    ecirc: "",
    ecir: "",
    ecolon: "",
    Ecy: "",
    ecy: "",
    eDDot: "",
    Edot: "",
    edot: "",
    eDot: "",
    ee: "",
    efDot: "",
    Efr: "",
    efr: "",
    eg: "",
    Egrave: "",
    egrave: "",
    egs: "",
    egsdot: "",
    el: "",
    Element: "",
    elinters: "",
    ell: "",
    els: "",
    elsdot: "",
    Emacr: "",
    emacr: "",
    empty: "",
    emptyset: "",
    EmptySmallSquare: "",
    emptyv: "",
    EmptyVerySmallSquare: "",
    emsp13: "",
    emsp14: "",
    emsp: "",
    ENG: "",
    eng: "",
    ensp: "",
    Eogon: "",
    eogon: "",
    Eopf: "",
    eopf: "",
    epar: "",
    eparsl: "",
    eplus: "",
    epsi: "",
    Epsilon: "",
    epsilon: "",
    epsiv: "",
    eqcirc: "",
    eqcolon: "",
    eqsim: "",
    eqslantgtr: "",
    eqslantless: "",
    Equal: "",
    equals: "=",
    EqualTilde: "",
    equest: "",
    Equilibrium: "",
    equiv: "",
    equivDD: "",
    eqvparsl: "",
    erarr: "",
    erDot: "",
    escr: "",
    Escr: "",
    esdot: "",
    Esim: "",
    esim: "",
    Eta: "",
    eta: "",
    ETH: "",
    eth: "",
    Euml: "",
    euml: "",
    euro: "",
    excl: "!",
    exist: "",
    Exists: "",
    expectation: "",
    exponentiale: "",
    ExponentialE: "",
    fallingdotseq: "",
    Fcy: "",
    fcy: "",
    female: "",
    ffilig: "",
    fflig: "",
    ffllig: "",
    Ffr: "",
    ffr: "",
    filig: "",
    FilledSmallSquare: "",
    FilledVerySmallSquare: "",
    fjlig: "fj",
    flat: "",
    fllig: "",
    fltns: "",
    fnof: "",
    Fopf: "",
    fopf: "",
    forall: "",
    ForAll: "",
    fork: "",
    forkv: "",
    Fouriertrf: "",
    fpartint: "",
    frac12: "",
    frac13: "",
    frac14: "",
    frac15: "",
    frac16: "",
    frac18: "",
    frac23: "",
    frac25: "",
    frac34: "",
    frac35: "",
    frac38: "",
    frac45: "",
    frac56: "",
    frac58: "",
    frac78: "",
    frasl: "",
    frown: "",
    fscr: "",
    Fscr: "",
    gacute: "",
    Gamma: "",
    gamma: "",
    Gammad: "",
    gammad: "",
    gap: "",
    Gbreve: "",
    gbreve: "",
    Gcedil: "",
    Gcirc: "",
    gcirc: "",
    Gcy: "",
    gcy: "",
    Gdot: "",
    gdot: "",
    ge: "",
    gE: "",
    gEl: "",
    gel: "",
    geq: "",
    geqq: "",
    geqslant: "",
    gescc: "",
    ges: "",
    gesdot: "",
    gesdoto: "",
    gesdotol: "",
    gesl: "",
    gesles: "",
    Gfr: "",
    gfr: "",
    gg: "",
    Gg: "",
    ggg: "",
    gimel: "",
    GJcy: "",
    gjcy: "",
    gla: "",
    gl: "",
    glE: "",
    glj: "",
    gnap: "",
    gnapprox: "",
    gne: "",
    gnE: "",
    gneq: "",
    gneqq: "",
    gnsim: "",
    Gopf: "",
    gopf: "",
    grave: "`",
    GreaterEqual: "",
    GreaterEqualLess: "",
    GreaterFullEqual: "",
    GreaterGreater: "",
    GreaterLess: "",
    GreaterSlantEqual: "",
    GreaterTilde: "",
    Gscr: "",
    gscr: "",
    gsim: "",
    gsime: "",
    gsiml: "",
    gtcc: "",
    gtcir: "",
    gt: ">",
    GT: ">",
    Gt: "",
    gtdot: "",
    gtlPar: "",
    gtquest: "",
    gtrapprox: "",
    gtrarr: "",
    gtrdot: "",
    gtreqless: "",
    gtreqqless: "",
    gtrless: "",
    gtrsim: "",
    gvertneqq: "",
    gvnE: "",
    Hacek: "",
    hairsp: "",
    half: "",
    hamilt: "",
    HARDcy: "",
    hardcy: "",
    harrcir: "",
    harr: "",
    hArr: "",
    harrw: "",
    Hat: "^",
    hbar: "",
    Hcirc: "",
    hcirc: "",
    hearts: "",
    heartsuit: "",
    hellip: "",
    hercon: "",
    hfr: "",
    Hfr: "",
    HilbertSpace: "",
    hksearow: "",
    hkswarow: "",
    hoarr: "",
    homtht: "",
    hookleftarrow: "",
    hookrightarrow: "",
    hopf: "",
    Hopf: "",
    horbar: "",
    HorizontalLine: "",
    hscr: "",
    Hscr: "",
    hslash: "",
    Hstrok: "",
    hstrok: "",
    HumpDownHump: "",
    HumpEqual: "",
    hybull: "",
    hyphen: "",
    Iacute: "",
    iacute: "",
    ic: "",
    Icirc: "",
    icirc: "",
    Icy: "",
    icy: "",
    Idot: "",
    IEcy: "",
    iecy: "",
    iexcl: "",
    iff: "",
    ifr: "",
    Ifr: "",
    Igrave: "",
    igrave: "",
    ii: "",
    iiiint: "",
    iiint: "",
    iinfin: "",
    iiota: "",
    IJlig: "",
    ijlig: "",
    Imacr: "",
    imacr: "",
    image: "",
    ImaginaryI: "",
    imagline: "",
    imagpart: "",
    imath: "",
    Im: "",
    imof: "",
    imped: "",
    Implies: "",
    incare: "",
    in: "",
    infin: "",
    infintie: "",
    inodot: "",
    intcal: "",
    int: "",
    Int: "",
    integers: "",
    Integral: "",
    intercal: "",
    Intersection: "",
    intlarhk: "",
    intprod: "",
    InvisibleComma: "",
    InvisibleTimes: "",
    IOcy: "",
    iocy: "",
    Iogon: "",
    iogon: "",
    Iopf: "",
    iopf: "",
    Iota: "",
    iota: "",
    iprod: "",
    iquest: "",
    iscr: "",
    Iscr: "",
    isin: "",
    isindot: "",
    isinE: "",
    isins: "",
    isinsv: "",
    isinv: "",
    it: "",
    Itilde: "",
    itilde: "",
    Iukcy: "",
    iukcy: "",
    Iuml: "",
    iuml: "",
    Jcirc: "",
    jcirc: "",
    Jcy: "",
    jcy: "",
    Jfr: "",
    jfr: "",
    jmath: "",
    Jopf: "",
    jopf: "",
    Jscr: "",
    jscr: "",
    Jsercy: "",
    jsercy: "",
    Jukcy: "",
    jukcy: "",
    Kappa: "",
    kappa: "",
    kappav: "",
    Kcedil: "",
    kcedil: "",
    Kcy: "",
    kcy: "",
    Kfr: "",
    kfr: "",
    kgreen: "",
    KHcy: "",
    khcy: "",
    KJcy: "",
    kjcy: "",
    Kopf: "",
    kopf: "",
    Kscr: "",
    kscr: "",
    lAarr: "",
    Lacute: "",
    lacute: "",
    laemptyv: "",
    lagran: "",
    Lambda: "",
    lambda: "",
    lang: "",
    Lang: "",
    langd: "",
    langle: "",
    lap: "",
    Laplacetrf: "",
    laquo: "",
    larrb: "",
    larrbfs: "",
    larr: "",
    Larr: "",
    lArr: "",
    larrfs: "",
    larrhk: "",
    larrlp: "",
    larrpl: "",
    larrsim: "",
    larrtl: "",
    latail: "",
    lAtail: "",
    lat: "",
    late: "",
    lates: "",
    lbarr: "",
    lBarr: "",
    lbbrk: "",
    lbrace: "{",
    lbrack: "[",
    lbrke: "",
    lbrksld: "",
    lbrkslu: "",
    Lcaron: "",
    lcaron: "",
    Lcedil: "",
    lcedil: "",
    lceil: "",
    lcub: "{",
    Lcy: "",
    lcy: "",
    ldca: "",
    ldquo: "",
    ldquor: "",
    ldrdhar: "",
    ldrushar: "",
    ldsh: "",
    le: "",
    lE: "",
    LeftAngleBracket: "",
    LeftArrowBar: "",
    leftarrow: "",
    LeftArrow: "",
    Leftarrow: "",
    LeftArrowRightArrow: "",
    leftarrowtail: "",
    LeftCeiling: "",
    LeftDoubleBracket: "",
    LeftDownTeeVector: "",
    LeftDownVectorBar: "",
    LeftDownVector: "",
    LeftFloor: "",
    leftharpoondown: "",
    leftharpoonup: "",
    leftleftarrows: "",
    leftrightarrow: "",
    LeftRightArrow: "",
    Leftrightarrow: "",
    leftrightarrows: "",
    leftrightharpoons: "",
    leftrightsquigarrow: "",
    LeftRightVector: "",
    LeftTeeArrow: "",
    LeftTee: "",
    LeftTeeVector: "",
    leftthreetimes: "",
    LeftTriangleBar: "",
    LeftTriangle: "",
    LeftTriangleEqual: "",
    LeftUpDownVector: "",
    LeftUpTeeVector: "",
    LeftUpVectorBar: "",
    LeftUpVector: "",
    LeftVectorBar: "",
    LeftVector: "",
    lEg: "",
    leg: "",
    leq: "",
    leqq: "",
    leqslant: "",
    lescc: "",
    les: "",
    lesdot: "",
    lesdoto: "",
    lesdotor: "",
    lesg: "",
    lesges: "",
    lessapprox: "",
    lessdot: "",
    lesseqgtr: "",
    lesseqqgtr: "",
    LessEqualGreater: "",
    LessFullEqual: "",
    LessGreater: "",
    lessgtr: "",
    LessLess: "",
    lesssim: "",
    LessSlantEqual: "",
    LessTilde: "",
    lfisht: "",
    lfloor: "",
    Lfr: "",
    lfr: "",
    lg: "",
    lgE: "",
    lHar: "",
    lhard: "",
    lharu: "",
    lharul: "",
    lhblk: "",
    LJcy: "",
    ljcy: "",
    llarr: "",
    ll: "",
    Ll: "",
    llcorner: "",
    Lleftarrow: "",
    llhard: "",
    lltri: "",
    Lmidot: "",
    lmidot: "",
    lmoustache: "",
    lmoust: "",
    lnap: "",
    lnapprox: "",
    lne: "",
    lnE: "",
    lneq: "",
    lneqq: "",
    lnsim: "",
    loang: "",
    loarr: "",
    lobrk: "",
    longleftarrow: "",
    LongLeftArrow: "",
    Longleftarrow: "",
    longleftrightarrow: "",
    LongLeftRightArrow: "",
    Longleftrightarrow: "",
    longmapsto: "",
    longrightarrow: "",
    LongRightArrow: "",
    Longrightarrow: "",
    looparrowleft: "",
    looparrowright: "",
    lopar: "",
    Lopf: "",
    lopf: "",
    loplus: "",
    lotimes: "",
    lowast: "",
    lowbar: "_",
    LowerLeftArrow: "",
    LowerRightArrow: "",
    loz: "",
    lozenge: "",
    lozf: "",
    lpar: "(",
    lparlt: "",
    lrarr: "",
    lrcorner: "",
    lrhar: "",
    lrhard: "",
    lrm: "",
    lrtri: "",
    lsaquo: "",
    lscr: "",
    Lscr: "",
    lsh: "",
    Lsh: "",
    lsim: "",
    lsime: "",
    lsimg: "",
    lsqb: "[",
    lsquo: "",
    lsquor: "",
    Lstrok: "",
    lstrok: "",
    ltcc: "",
    ltcir: "",
    lt: "<",
    LT: "<",
    Lt: "",
    ltdot: "",
    lthree: "",
    ltimes: "",
    ltlarr: "",
    ltquest: "",
    ltri: "",
    ltrie: "",
    ltrif: "",
    ltrPar: "",
    lurdshar: "",
    luruhar: "",
    lvertneqq: "",
    lvnE: "",
    macr: "",
    male: "",
    malt: "",
    maltese: "",
    Map: "",
    map: "",
    mapsto: "",
    mapstodown: "",
    mapstoleft: "",
    mapstoup: "",
    marker: "",
    mcomma: "",
    Mcy: "",
    mcy: "",
    mdash: "",
    mDDot: "",
    measuredangle: "",
    MediumSpace: "",
    Mellintrf: "",
    Mfr: "",
    mfr: "",
    mho: "",
    micro: "",
    midast: "*",
    midcir: "",
    mid: "",
    middot: "",
    minusb: "",
    minus: "",
    minusd: "",
    minusdu: "",
    MinusPlus: "",
    mlcp: "",
    mldr: "",
    mnplus: "",
    models: "",
    Mopf: "",
    mopf: "",
    mp: "",
    mscr: "",
    Mscr: "",
    mstpos: "",
    Mu: "",
    mu: "",
    multimap: "",
    mumap: "",
    nabla: "",
    Nacute: "",
    nacute: "",
    nang: "",
    nap: "",
    napE: "",
    napid: "",
    napos: "",
    napprox: "",
    natural: "",
    naturals: "",
    natur: "",
    nbsp: "",
    nbump: "",
    nbumpe: "",
    ncap: "",
    Ncaron: "",
    ncaron: "",
    Ncedil: "",
    ncedil: "",
    ncong: "",
    ncongdot: "",
    ncup: "",
    Ncy: "",
    ncy: "",
    ndash: "",
    nearhk: "",
    nearr: "",
    neArr: "",
    nearrow: "",
    ne: "",
    nedot: "",
    NegativeMediumSpace: "",
    NegativeThickSpace: "",
    NegativeThinSpace: "",
    NegativeVeryThinSpace: "",
    nequiv: "",
    nesear: "",
    nesim: "",
    NestedGreaterGreater: "",
    NestedLessLess: "",
    NewLine: `
`,
    nexist: "",
    nexists: "",
    Nfr: "",
    nfr: "",
    ngE: "",
    nge: "",
    ngeq: "",
    ngeqq: "",
    ngeqslant: "",
    nges: "",
    nGg: "",
    ngsim: "",
    nGt: "",
    ngt: "",
    ngtr: "",
    nGtv: "",
    nharr: "",
    nhArr: "",
    nhpar: "",
    ni: "",
    nis: "",
    nisd: "",
    niv: "",
    NJcy: "",
    njcy: "",
    nlarr: "",
    nlArr: "",
    nldr: "",
    nlE: "",
    nle: "",
    nleftarrow: "",
    nLeftarrow: "",
    nleftrightarrow: "",
    nLeftrightarrow: "",
    nleq: "",
    nleqq: "",
    nleqslant: "",
    nles: "",
    nless: "",
    nLl: "",
    nlsim: "",
    nLt: "",
    nlt: "",
    nltri: "",
    nltrie: "",
    nLtv: "",
    nmid: "",
    NoBreak: "",
    NonBreakingSpace: "",
    nopf: "",
    Nopf: "",
    Not: "",
    not: "",
    NotCongruent: "",
    NotCupCap: "",
    NotDoubleVerticalBar: "",
    NotElement: "",
    NotEqual: "",
    NotEqualTilde: "",
    NotExists: "",
    NotGreater: "",
    NotGreaterEqual: "",
    NotGreaterFullEqual: "",
    NotGreaterGreater: "",
    NotGreaterLess: "",
    NotGreaterSlantEqual: "",
    NotGreaterTilde: "",
    NotHumpDownHump: "",
    NotHumpEqual: "",
    notin: "",
    notindot: "",
    notinE: "",
    notinva: "",
    notinvb: "",
    notinvc: "",
    NotLeftTriangleBar: "",
    NotLeftTriangle: "",
    NotLeftTriangleEqual: "",
    NotLess: "",
    NotLessEqual: "",
    NotLessGreater: "",
    NotLessLess: "",
    NotLessSlantEqual: "",
    NotLessTilde: "",
    NotNestedGreaterGreater: "",
    NotNestedLessLess: "",
    notni: "",
    notniva: "",
    notnivb: "",
    notnivc: "",
    NotPrecedes: "",
    NotPrecedesEqual: "",
    NotPrecedesSlantEqual: "",
    NotReverseElement: "",
    NotRightTriangleBar: "",
    NotRightTriangle: "",
    NotRightTriangleEqual: "",
    NotSquareSubset: "",
    NotSquareSubsetEqual: "",
    NotSquareSuperset: "",
    NotSquareSupersetEqual: "",
    NotSubset: "",
    NotSubsetEqual: "",
    NotSucceeds: "",
    NotSucceedsEqual: "",
    NotSucceedsSlantEqual: "",
    NotSucceedsTilde: "",
    NotSuperset: "",
    NotSupersetEqual: "",
    NotTilde: "",
    NotTildeEqual: "",
    NotTildeFullEqual: "",
    NotTildeTilde: "",
    NotVerticalBar: "",
    nparallel: "",
    npar: "",
    nparsl: "",
    npart: "",
    npolint: "",
    npr: "",
    nprcue: "",
    nprec: "",
    npreceq: "",
    npre: "",
    nrarrc: "",
    nrarr: "",
    nrArr: "",
    nrarrw: "",
    nrightarrow: "",
    nRightarrow: "",
    nrtri: "",
    nrtrie: "",
    nsc: "",
    nsccue: "",
    nsce: "",
    Nscr: "",
    nscr: "",
    nshortmid: "",
    nshortparallel: "",
    nsim: "",
    nsime: "",
    nsimeq: "",
    nsmid: "",
    nspar: "",
    nsqsube: "",
    nsqsupe: "",
    nsub: "",
    nsubE: "",
    nsube: "",
    nsubset: "",
    nsubseteq: "",
    nsubseteqq: "",
    nsucc: "",
    nsucceq: "",
    nsup: "",
    nsupE: "",
    nsupe: "",
    nsupset: "",
    nsupseteq: "",
    nsupseteqq: "",
    ntgl: "",
    Ntilde: "",
    ntilde: "",
    ntlg: "",
    ntriangleleft: "",
    ntrianglelefteq: "",
    ntriangleright: "",
    ntrianglerighteq: "",
    Nu: "",
    nu: "",
    num: "#",
    numero: "",
    numsp: "",
    nvap: "",
    nvdash: "",
    nvDash: "",
    nVdash: "",
    nVDash: "",
    nvge: "",
    nvgt: ">",
    nvHarr: "",
    nvinfin: "",
    nvlArr: "",
    nvle: "",
    nvlt: "<",
    nvltrie: "",
    nvrArr: "",
    nvrtrie: "",
    nvsim: "",
    nwarhk: "",
    nwarr: "",
    nwArr: "",
    nwarrow: "",
    nwnear: "",
    Oacute: "",
    oacute: "",
    oast: "",
    Ocirc: "",
    ocirc: "",
    ocir: "",
    Ocy: "",
    ocy: "",
    odash: "",
    Odblac: "",
    odblac: "",
    odiv: "",
    odot: "",
    odsold: "",
    OElig: "",
    oelig: "",
    ofcir: "",
    Ofr: "",
    ofr: "",
    ogon: "",
    Ograve: "",
    ograve: "",
    ogt: "",
    ohbar: "",
    ohm: "",
    oint: "",
    olarr: "",
    olcir: "",
    olcross: "",
    oline: "",
    olt: "",
    Omacr: "",
    omacr: "",
    Omega: "",
    omega: "",
    Omicron: "",
    omicron: "",
    omid: "",
    ominus: "",
    Oopf: "",
    oopf: "",
    opar: "",
    OpenCurlyDoubleQuote: "",
    OpenCurlyQuote: "",
    operp: "",
    oplus: "",
    orarr: "",
    Or: "",
    or: "",
    ord: "",
    order: "",
    orderof: "",
    ordf: "",
    ordm: "",
    origof: "",
    oror: "",
    orslope: "",
    orv: "",
    oS: "",
    Oscr: "",
    oscr: "",
    Oslash: "",
    oslash: "",
    osol: "",
    Otilde: "",
    otilde: "",
    otimesas: "",
    Otimes: "",
    otimes: "",
    Ouml: "",
    ouml: "",
    ovbar: "",
    OverBar: "",
    OverBrace: "",
    OverBracket: "",
    OverParenthesis: "",
    para: "",
    parallel: "",
    par: "",
    parsim: "",
    parsl: "",
    part: "",
    PartialD: "",
    Pcy: "",
    pcy: "",
    percnt: "%",
    period: ".",
    permil: "",
    perp: "",
    pertenk: "",
    Pfr: "",
    pfr: "",
    Phi: "",
    phi: "",
    phiv: "",
    phmmat: "",
    phone: "",
    Pi: "",
    pi: "",
    pitchfork: "",
    piv: "",
    planck: "",
    planckh: "",
    plankv: "",
    plusacir: "",
    plusb: "",
    pluscir: "",
    plus: "+",
    plusdo: "",
    plusdu: "",
    pluse: "",
    PlusMinus: "",
    plusmn: "",
    plussim: "",
    plustwo: "",
    pm: "",
    Poincareplane: "",
    pointint: "",
    popf: "",
    Popf: "",
    pound: "",
    prap: "",
    Pr: "",
    pr: "",
    prcue: "",
    precapprox: "",
    prec: "",
    preccurlyeq: "",
    Precedes: "",
    PrecedesEqual: "",
    PrecedesSlantEqual: "",
    PrecedesTilde: "",
    preceq: "",
    precnapprox: "",
    precneqq: "",
    precnsim: "",
    pre: "",
    prE: "",
    precsim: "",
    prime: "",
    Prime: "",
    primes: "",
    prnap: "",
    prnE: "",
    prnsim: "",
    prod: "",
    Product: "",
    profalar: "",
    profline: "",
    profsurf: "",
    prop: "",
    Proportional: "",
    Proportion: "",
    propto: "",
    prsim: "",
    prurel: "",
    Pscr: "",
    pscr: "",
    Psi: "",
    psi: "",
    puncsp: "",
    Qfr: "",
    qfr: "",
    qint: "",
    qopf: "",
    Qopf: "",
    qprime: "",
    Qscr: "",
    qscr: "",
    quaternions: "",
    quatint: "",
    quest: "?",
    questeq: "",
    quot: '"',
    QUOT: '"',
    rAarr: "",
    race: "",
    Racute: "",
    racute: "",
    radic: "",
    raemptyv: "",
    rang: "",
    Rang: "",
    rangd: "",
    range: "",
    rangle: "",
    raquo: "",
    rarrap: "",
    rarrb: "",
    rarrbfs: "",
    rarrc: "",
    rarr: "",
    Rarr: "",
    rArr: "",
    rarrfs: "",
    rarrhk: "",
    rarrlp: "",
    rarrpl: "",
    rarrsim: "",
    Rarrtl: "",
    rarrtl: "",
    rarrw: "",
    ratail: "",
    rAtail: "",
    ratio: "",
    rationals: "",
    rbarr: "",
    rBarr: "",
    RBarr: "",
    rbbrk: "",
    rbrace: "}",
    rbrack: "]",
    rbrke: "",
    rbrksld: "",
    rbrkslu: "",
    Rcaron: "",
    rcaron: "",
    Rcedil: "",
    rcedil: "",
    rceil: "",
    rcub: "}",
    Rcy: "",
    rcy: "",
    rdca: "",
    rdldhar: "",
    rdquo: "",
    rdquor: "",
    rdsh: "",
    real: "",
    realine: "",
    realpart: "",
    reals: "",
    Re: "",
    rect: "",
    reg: "",
    REG: "",
    ReverseElement: "",
    ReverseEquilibrium: "",
    ReverseUpEquilibrium: "",
    rfisht: "",
    rfloor: "",
    rfr: "",
    Rfr: "",
    rHar: "",
    rhard: "",
    rharu: "",
    rharul: "",
    Rho: "",
    rho: "",
    rhov: "",
    RightAngleBracket: "",
    RightArrowBar: "",
    rightarrow: "",
    RightArrow: "",
    Rightarrow: "",
    RightArrowLeftArrow: "",
    rightarrowtail: "",
    RightCeiling: "",
    RightDoubleBracket: "",
    RightDownTeeVector: "",
    RightDownVectorBar: "",
    RightDownVector: "",
    RightFloor: "",
    rightharpoondown: "",
    rightharpoonup: "",
    rightleftarrows: "",
    rightleftharpoons: "",
    rightrightarrows: "",
    rightsquigarrow: "",
    RightTeeArrow: "",
    RightTee: "",
    RightTeeVector: "",
    rightthreetimes: "",
    RightTriangleBar: "",
    RightTriangle: "",
    RightTriangleEqual: "",
    RightUpDownVector: "",
    RightUpTeeVector: "",
    RightUpVectorBar: "",
    RightUpVector: "",
    RightVectorBar: "",
    RightVector: "",
    ring: "",
    risingdotseq: "",
    rlarr: "",
    rlhar: "",
    rlm: "",
    rmoustache: "",
    rmoust: "",
    rnmid: "",
    roang: "",
    roarr: "",
    robrk: "",
    ropar: "",
    ropf: "",
    Ropf: "",
    roplus: "",
    rotimes: "",
    RoundImplies: "",
    rpar: ")",
    rpargt: "",
    rppolint: "",
    rrarr: "",
    Rrightarrow: "",
    rsaquo: "",
    rscr: "",
    Rscr: "",
    rsh: "",
    Rsh: "",
    rsqb: "]",
    rsquo: "",
    rsquor: "",
    rthree: "",
    rtimes: "",
    rtri: "",
    rtrie: "",
    rtrif: "",
    rtriltri: "",
    RuleDelayed: "",
    ruluhar: "",
    rx: "",
    Sacute: "",
    sacute: "",
    sbquo: "",
    scap: "",
    Scaron: "",
    scaron: "",
    Sc: "",
    sc: "",
    sccue: "",
    sce: "",
    scE: "",
    Scedil: "",
    scedil: "",
    Scirc: "",
    scirc: "",
    scnap: "",
    scnE: "",
    scnsim: "",
    scpolint: "",
    scsim: "",
    Scy: "",
    scy: "",
    sdotb: "",
    sdot: "",
    sdote: "",
    searhk: "",
    searr: "",
    seArr: "",
    searrow: "",
    sect: "",
    semi: ";",
    seswar: "",
    setminus: "",
    setmn: "",
    sext: "",
    Sfr: "",
    sfr: "",
    sfrown: "",
    sharp: "",
    SHCHcy: "",
    shchcy: "",
    SHcy: "",
    shcy: "",
    ShortDownArrow: "",
    ShortLeftArrow: "",
    shortmid: "",
    shortparallel: "",
    ShortRightArrow: "",
    ShortUpArrow: "",
    shy: "",
    Sigma: "",
    sigma: "",
    sigmaf: "",
    sigmav: "",
    sim: "",
    simdot: "",
    sime: "",
    simeq: "",
    simg: "",
    simgE: "",
    siml: "",
    simlE: "",
    simne: "",
    simplus: "",
    simrarr: "",
    slarr: "",
    SmallCircle: "",
    smallsetminus: "",
    smashp: "",
    smeparsl: "",
    smid: "",
    smile: "",
    smt: "",
    smte: "",
    smtes: "",
    SOFTcy: "",
    softcy: "",
    solbar: "",
    solb: "",
    sol: "/",
    Sopf: "",
    sopf: "",
    spades: "",
    spadesuit: "",
    spar: "",
    sqcap: "",
    sqcaps: "",
    sqcup: "",
    sqcups: "",
    Sqrt: "",
    sqsub: "",
    sqsube: "",
    sqsubset: "",
    sqsubseteq: "",
    sqsup: "",
    sqsupe: "",
    sqsupset: "",
    sqsupseteq: "",
    square: "",
    Square: "",
    SquareIntersection: "",
    SquareSubset: "",
    SquareSubsetEqual: "",
    SquareSuperset: "",
    SquareSupersetEqual: "",
    SquareUnion: "",
    squarf: "",
    squ: "",
    squf: "",
    srarr: "",
    Sscr: "",
    sscr: "",
    ssetmn: "",
    ssmile: "",
    sstarf: "",
    Star: "",
    star: "",
    starf: "",
    straightepsilon: "",
    straightphi: "",
    strns: "",
    sub: "",
    Sub: "",
    subdot: "",
    subE: "",
    sube: "",
    subedot: "",
    submult: "",
    subnE: "",
    subne: "",
    subplus: "",
    subrarr: "",
    subset: "",
    Subset: "",
    subseteq: "",
    subseteqq: "",
    SubsetEqual: "",
    subsetneq: "",
    subsetneqq: "",
    subsim: "",
    subsub: "",
    subsup: "",
    succapprox: "",
    succ: "",
    succcurlyeq: "",
    Succeeds: "",
    SucceedsEqual: "",
    SucceedsSlantEqual: "",
    SucceedsTilde: "",
    succeq: "",
    succnapprox: "",
    succneqq: "",
    succnsim: "",
    succsim: "",
    SuchThat: "",
    sum: "",
    Sum: "",
    sung: "",
    sup1: "",
    sup2: "",
    sup3: "",
    sup: "",
    Sup: "",
    supdot: "",
    supdsub: "",
    supE: "",
    supe: "",
    supedot: "",
    Superset: "",
    SupersetEqual: "",
    suphsol: "",
    suphsub: "",
    suplarr: "",
    supmult: "",
    supnE: "",
    supne: "",
    supplus: "",
    supset: "",
    Supset: "",
    supseteq: "",
    supseteqq: "",
    supsetneq: "",
    supsetneqq: "",
    supsim: "",
    supsub: "",
    supsup: "",
    swarhk: "",
    swarr: "",
    swArr: "",
    swarrow: "",
    swnwar: "",
    szlig: "",
    Tab: "	",
    target: "",
    Tau: "",
    tau: "",
    tbrk: "",
    Tcaron: "",
    tcaron: "",
    Tcedil: "",
    tcedil: "",
    Tcy: "",
    tcy: "",
    tdot: "",
    telrec: "",
    Tfr: "",
    tfr: "",
    there4: "",
    therefore: "",
    Therefore: "",
    Theta: "",
    theta: "",
    thetasym: "",
    thetav: "",
    thickapprox: "",
    thicksim: "",
    ThickSpace: "",
    ThinSpace: "",
    thinsp: "",
    thkap: "",
    thksim: "",
    THORN: "",
    thorn: "",
    tilde: "",
    Tilde: "",
    TildeEqual: "",
    TildeFullEqual: "",
    TildeTilde: "",
    timesbar: "",
    timesb: "",
    times: "",
    timesd: "",
    tint: "",
    toea: "",
    topbot: "",
    topcir: "",
    top: "",
    Topf: "",
    topf: "",
    topfork: "",
    tosa: "",
    tprime: "",
    trade: "",
    TRADE: "",
    triangle: "",
    triangledown: "",
    triangleleft: "",
    trianglelefteq: "",
    triangleq: "",
    triangleright: "",
    trianglerighteq: "",
    tridot: "",
    trie: "",
    triminus: "",
    TripleDot: "",
    triplus: "",
    trisb: "",
    tritime: "",
    trpezium: "",
    Tscr: "",
    tscr: "",
    TScy: "",
    tscy: "",
    TSHcy: "",
    tshcy: "",
    Tstrok: "",
    tstrok: "",
    twixt: "",
    twoheadleftarrow: "",
    twoheadrightarrow: "",
    Uacute: "",
    uacute: "",
    uarr: "",
    Uarr: "",
    uArr: "",
    Uarrocir: "",
    Ubrcy: "",
    ubrcy: "",
    Ubreve: "",
    ubreve: "",
    Ucirc: "",
    ucirc: "",
    Ucy: "",
    ucy: "",
    udarr: "",
    Udblac: "",
    udblac: "",
    udhar: "",
    ufisht: "",
    Ufr: "",
    ufr: "",
    Ugrave: "",
    ugrave: "",
    uHar: "",
    uharl: "",
    uharr: "",
    uhblk: "",
    ulcorn: "",
    ulcorner: "",
    ulcrop: "",
    ultri: "",
    Umacr: "",
    umacr: "",
    uml: "",
    UnderBar: "_",
    UnderBrace: "",
    UnderBracket: "",
    UnderParenthesis: "",
    Union: "",
    UnionPlus: "",
    Uogon: "",
    uogon: "",
    Uopf: "",
    uopf: "",
    UpArrowBar: "",
    uparrow: "",
    UpArrow: "",
    Uparrow: "",
    UpArrowDownArrow: "",
    updownarrow: "",
    UpDownArrow: "",
    Updownarrow: "",
    UpEquilibrium: "",
    upharpoonleft: "",
    upharpoonright: "",
    uplus: "",
    UpperLeftArrow: "",
    UpperRightArrow: "",
    upsi: "",
    Upsi: "",
    upsih: "",
    Upsilon: "",
    upsilon: "",
    UpTeeArrow: "",
    UpTee: "",
    upuparrows: "",
    urcorn: "",
    urcorner: "",
    urcrop: "",
    Uring: "",
    uring: "",
    urtri: "",
    Uscr: "",
    uscr: "",
    utdot: "",
    Utilde: "",
    utilde: "",
    utri: "",
    utrif: "",
    uuarr: "",
    Uuml: "",
    uuml: "",
    uwangle: "",
    vangrt: "",
    varepsilon: "",
    varkappa: "",
    varnothing: "",
    varphi: "",
    varpi: "",
    varpropto: "",
    varr: "",
    vArr: "",
    varrho: "",
    varsigma: "",
    varsubsetneq: "",
    varsubsetneqq: "",
    varsupsetneq: "",
    varsupsetneqq: "",
    vartheta: "",
    vartriangleleft: "",
    vartriangleright: "",
    vBar: "",
    Vbar: "",
    vBarv: "",
    Vcy: "",
    vcy: "",
    vdash: "",
    vDash: "",
    Vdash: "",
    VDash: "",
    Vdashl: "",
    veebar: "",
    vee: "",
    Vee: "",
    veeeq: "",
    vellip: "",
    verbar: "|",
    Verbar: "",
    vert: "|",
    Vert: "",
    VerticalBar: "",
    VerticalLine: "|",
    VerticalSeparator: "",
    VerticalTilde: "",
    VeryThinSpace: "",
    Vfr: "",
    vfr: "",
    vltri: "",
    vnsub: "",
    vnsup: "",
    Vopf: "",
    vopf: "",
    vprop: "",
    vrtri: "",
    Vscr: "",
    vscr: "",
    vsubnE: "",
    vsubne: "",
    vsupnE: "",
    vsupne: "",
    Vvdash: "",
    vzigzag: "",
    Wcirc: "",
    wcirc: "",
    wedbar: "",
    wedge: "",
    Wedge: "",
    wedgeq: "",
    weierp: "",
    Wfr: "",
    wfr: "",
    Wopf: "",
    wopf: "",
    wp: "",
    wr: "",
    wreath: "",
    Wscr: "",
    wscr: "",
    xcap: "",
    xcirc: "",
    xcup: "",
    xdtri: "",
    Xfr: "",
    xfr: "",
    xharr: "",
    xhArr: "",
    Xi: "",
    xi: "",
    xlarr: "",
    xlArr: "",
    xmap: "",
    xnis: "",
    xodot: "",
    Xopf: "",
    xopf: "",
    xoplus: "",
    xotime: "",
    xrarr: "",
    xrArr: "",
    Xscr: "",
    xscr: "",
    xsqcup: "",
    xuplus: "",
    xutri: "",
    xvee: "",
    xwedge: "",
    Yacute: "",
    yacute: "",
    YAcy: "",
    yacy: "",
    Ycirc: "",
    ycirc: "",
    Ycy: "",
    ycy: "",
    yen: "",
    Yfr: "",
    yfr: "",
    YIcy: "",
    yicy: "",
    Yopf: "",
    yopf: "",
    Yscr: "",
    yscr: "",
    YUcy: "",
    yucy: "",
    yuml: "",
    Yuml: "",
    Zacute: "",
    zacute: "",
    Zcaron: "",
    zcaron: "",
    Zcy: "",
    zcy: "",
    Zdot: "",
    zdot: "",
    zeetrf: "",
    ZeroWidthSpace: "",
    Zeta: "",
    zeta: "",
    zfr: "",
    Zfr: "",
    ZHcy: "",
    zhcy: "",
    zigrarr: "",
    zopf: "",
    Zopf: "",
    Zscr: "",
    zscr: "",
    zwj: "",
    zwnj: ""
  };
});
var $o2 = O5((Mu, ya) => {
  ya.exports = {
    Aacute: "",
    aacute: "",
    Acirc: "",
    acirc: "",
    acute: "",
    AElig: "",
    aelig: "",
    Agrave: "",
    agrave: "",
    amp: "&",
    AMP: "&",
    Aring: "",
    aring: "",
    Atilde: "",
    atilde: "",
    Auml: "",
    auml: "",
    brvbar: "",
    Ccedil: "",
    ccedil: "",
    cedil: "",
    cent: "",
    copy: "",
    COPY: "",
    curren: "",
    deg: "",
    divide: "",
    Eacute: "",
    eacute: "",
    Ecirc: "",
    ecirc: "",
    Egrave: "",
    egrave: "",
    ETH: "",
    eth: "",
    Euml: "",
    euml: "",
    frac12: "",
    frac14: "",
    frac34: "",
    gt: ">",
    GT: ">",
    Iacute: "",
    iacute: "",
    Icirc: "",
    icirc: "",
    iexcl: "",
    Igrave: "",
    igrave: "",
    iquest: "",
    Iuml: "",
    iuml: "",
    laquo: "",
    lt: "<",
    LT: "<",
    macr: "",
    micro: "",
    middot: "",
    nbsp: "",
    not: "",
    Ntilde: "",
    ntilde: "",
    Oacute: "",
    oacute: "",
    Ocirc: "",
    ocirc: "",
    Ograve: "",
    ograve: "",
    ordf: "",
    ordm: "",
    Oslash: "",
    oslash: "",
    Otilde: "",
    otilde: "",
    Ouml: "",
    ouml: "",
    para: "",
    plusmn: "",
    pound: "",
    quot: '"',
    QUOT: '"',
    raquo: "",
    reg: "",
    REG: "",
    sect: "",
    shy: "",
    sup1: "",
    sup2: "",
    sup3: "",
    szlig: "",
    THORN: "",
    thorn: "",
    times: "",
    Uacute: "",
    uacute: "",
    Ucirc: "",
    ucirc: "",
    Ugrave: "",
    ugrave: "",
    uml: "",
    Uuml: "",
    uuml: "",
    Yacute: "",
    yacute: "",
    yen: "",
    yuml: ""
  };
});
var ct = O5((_u, ma) => {
  ma.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
});
var Yo = O5((Lu, ha) => {
  ha.exports = {
    "0": 65533,
    "128": 8364,
    "130": 8218,
    "131": 402,
    "132": 8222,
    "133": 8230,
    "134": 8224,
    "135": 8225,
    "136": 710,
    "137": 8240,
    "138": 352,
    "139": 8249,
    "140": 338,
    "142": 381,
    "145": 8216,
    "146": 8217,
    "147": 8220,
    "148": 8221,
    "149": 8226,
    "150": 8211,
    "151": 8212,
    "152": 732,
    "153": 8482,
    "154": 353,
    "155": 8250,
    "156": 339,
    "158": 382,
    "159": 376
  };
});
var Xo = O5((_e2) => {
  "use strict";
  var ga = _e2 && _e2.__importDefault || function(r4) {
    return r4 && r4.__esModule ? r4 : { default: r4 };
  };
  Object.defineProperty(_e2, "__esModule", { value: true });
  var Ko = ga(Yo()), ba = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.fromCodePoint || function(r4) {
      var e2 = "";
      return r4 > 65535 && (r4 -= 65536, e2 += String.fromCharCode(r4 >>> 10 & 1023 | 55296), r4 = 56320 | r4 & 1023), e2 += String.fromCharCode(r4), e2;
    }
  );
  function Sa(r4) {
    return r4 >= 55296 && r4 <= 57343 || r4 > 1114111 ? "" : (r4 in Ko.default && (r4 = Ko.default[r4]), ba(r4));
  }
  s3(Sa, "decodeCodePoint");
  _e2.default = Sa;
});
var pt2 = O5((G5) => {
  "use strict";
  var or2 = G5 && G5.__importDefault || function(r4) {
    return r4 && r4.__esModule ? r4 : { default: r4 };
  };
  Object.defineProperty(G5, "__esModule", { value: true });
  G5.decodeHTML = G5.decodeHTMLStrict = G5.decodeXML = void 0;
  var dt2 = or2(lt3()), Ta = or2($o2()), xa = or2(ct()), Jo = or2(Xo()), Ra = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  G5.decodeXML = Zo(xa.default);
  G5.decodeHTMLStrict = Zo(dt2.default);
  function Zo(r4) {
    var e2 = en2(r4);
    return function(t4) {
      return String(t4).replace(Ra, e2);
    };
  }
  s3(Zo, "getStrictDecoder");
  var Qo = s3(function(r4, e2) {
    return r4 < e2 ? 1 : -1;
  }, "sorter");
  G5.decodeHTML = function() {
    for (var r4 = Object.keys(Ta.default).sort(Qo), e2 = Object.keys(dt2.default).sort(Qo), t4 = 0, o3 = 0; t4 < e2.length; t4++)
      r4[o3] === e2[t4] ? (e2[t4] += ";?", o3++) : e2[t4] += ";";
    var n3 = new RegExp("&(?:" + e2.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), i4 = en2(dt2.default);
    function a5(l3) {
      return l3.substr(-1) !== ";" && (l3 += ";"), i4(l3);
    }
    return s3(a5, "replacer"), function(l3) {
      return String(l3).replace(n3, a5);
    };
  }();
  function en2(r4) {
    return s3(function(t4) {
      if (t4.charAt(1) === "#") {
        var o3 = t4.charAt(2);
        return o3 === "X" || o3 === "x" ? Jo.default(parseInt(t4.substr(3), 16)) : Jo.default(parseInt(t4.substr(2), 10));
      }
      return r4[t4.slice(1, -1)] || t4;
    }, "replace");
  }
  s3(en2, "getReplacer");
});
var ft2 = O5((_4) => {
  "use strict";
  var rn2 = _4 && _4.__importDefault || function(r4) {
    return r4 && r4.__esModule ? r4 : { default: r4 };
  };
  Object.defineProperty(_4, "__esModule", { value: true });
  _4.escapeUTF8 = _4.escape = _4.encodeNonAsciiHTML = _4.encodeHTML = _4.encodeXML = void 0;
  var wa = rn2(ct()), tn2 = nn2(wa.default), on2 = sn2(tn2);
  _4.encodeXML = cn2(tn2);
  var Ea = rn2(lt3()), ut2 = nn2(Ea.default), Aa = sn2(ut2);
  _4.encodeHTML = Ca(ut2, Aa);
  _4.encodeNonAsciiHTML = cn2(ut2);
  function nn2(r4) {
    return Object.keys(r4).sort().reduce(function(e2, t4) {
      return e2[r4[t4]] = "&" + t4 + ";", e2;
    }, {});
  }
  s3(nn2, "getInverseObj");
  function sn2(r4) {
    for (var e2 = [], t4 = [], o3 = 0, n3 = Object.keys(r4); o3 < n3.length; o3++) {
      var i4 = n3[o3];
      i4.length === 1 ? e2.push("\\" + i4) : t4.push(i4);
    }
    e2.sort();
    for (var a5 = 0; a5 < e2.length - 1; a5++) {
      for (var l3 = a5; l3 < e2.length - 1 && e2[l3].charCodeAt(1) + 1 === e2[l3 + 1].charCodeAt(1); )
        l3 += 1;
      var c3 = 1 + l3 - a5;
      c3 < 3 || e2.splice(a5, c3, e2[a5] + "-" + e2[l3]);
    }
    return t4.unshift("[" + e2.join("") + "]"), new RegExp(t4.join("|"), "g");
  }
  s3(sn2, "getInverseReplacer");
  var an3 = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, va = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      function(r4) {
        return r4.codePointAt(0);
      }
    ) : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(r4) {
        return (r4.charCodeAt(0) - 55296) * 1024 + r4.charCodeAt(1) - 56320 + 65536;
      }
    )
  );
  function nr2(r4) {
    return "&#x" + (r4.length > 1 ? va(r4) : r4.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  s3(nr2, "singleCharReplacer");
  function Ca(r4, e2) {
    return function(t4) {
      return t4.replace(e2, function(o3) {
        return r4[o3];
      }).replace(an3, nr2);
    };
  }
  s3(Ca, "getInverse");
  var ln2 = new RegExp(on2.source + "|" + an3.source, "g");
  function Pa(r4) {
    return r4.replace(ln2, nr2);
  }
  s3(Pa, "escape");
  _4.escape = Pa;
  function Fa(r4) {
    return r4.replace(on2, nr2);
  }
  s3(Fa, "escapeUTF8");
  _4.escapeUTF8 = Fa;
  function cn2(r4) {
    return function(e2) {
      return e2.replace(ln2, function(t4) {
        return r4[t4] || nr2(t4);
      });
    };
  }
  s3(cn2, "getASCIIEncoder");
});
var pn2 = O5((w6) => {
  "use strict";
  Object.defineProperty(w6, "__esModule", { value: true });
  w6.decodeXMLStrict = w6.decodeHTML5Strict = w6.decodeHTML4Strict = w6.decodeHTML5 = w6.decodeHTML4 = w6.decodeHTMLStrict = w6.decodeHTML = w6.decodeXML = w6.encodeHTML5 = w6.encodeHTML4 = w6.escapeUTF8 = w6.escape = w6.encodeNonAsciiHTML = w6.encodeHTML = w6.encodeXML = w6.encode = w6.decodeStrict = w6.decode = void 0;
  var sr2 = pt2(), dn2 = ft2();
  function Ia(r4, e2) {
    return (!e2 || e2 <= 0 ? sr2.decodeXML : sr2.decodeHTML)(r4);
  }
  s3(Ia, "decode");
  w6.decode = Ia;
  function Oa(r4, e2) {
    return (!e2 || e2 <= 0 ? sr2.decodeXML : sr2.decodeHTMLStrict)(r4);
  }
  s3(Oa, "decodeStrict");
  w6.decodeStrict = Oa;
  function Da(r4, e2) {
    return (!e2 || e2 <= 0 ? dn2.encodeXML : dn2.encodeHTML)(r4);
  }
  s3(Da, "encode");
  w6.encode = Da;
  var ae2 = ft2();
  Object.defineProperty(w6, "encodeXML", { enumerable: true, get: s3(function() {
    return ae2.encodeXML;
  }, "get") });
  Object.defineProperty(w6, "encodeHTML", { enumerable: true, get: s3(function() {
    return ae2.encodeHTML;
  }, "get") });
  Object.defineProperty(w6, "encodeNonAsciiHTML", { enumerable: true, get: s3(function() {
    return ae2.encodeNonAsciiHTML;
  }, "get") });
  Object.defineProperty(w6, "escape", { enumerable: true, get: s3(function() {
    return ae2.escape;
  }, "get") });
  Object.defineProperty(w6, "escapeUTF8", { enumerable: true, get: s3(function() {
    return ae2.escapeUTF8;
  }, "get") });
  Object.defineProperty(w6, "encodeHTML4", { enumerable: true, get: s3(function() {
    return ae2.encodeHTML;
  }, "get") });
  Object.defineProperty(w6, "encodeHTML5", { enumerable: true, get: s3(function() {
    return ae2.encodeHTML;
  }, "get") });
  var J4 = pt2();
  Object.defineProperty(w6, "decodeXML", { enumerable: true, get: s3(function() {
    return J4.decodeXML;
  }, "get") });
  Object.defineProperty(w6, "decodeHTML", { enumerable: true, get: s3(function() {
    return J4.decodeHTML;
  }, "get") });
  Object.defineProperty(w6, "decodeHTMLStrict", { enumerable: true, get: s3(function() {
    return J4.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(w6, "decodeHTML4", { enumerable: true, get: s3(function() {
    return J4.decodeHTML;
  }, "get") });
  Object.defineProperty(w6, "decodeHTML5", { enumerable: true, get: s3(function() {
    return J4.decodeHTML;
  }, "get") });
  Object.defineProperty(w6, "decodeHTML4Strict", { enumerable: true, get: s3(function() {
    return J4.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(w6, "decodeHTML5Strict", { enumerable: true, get: s3(function() {
    return J4.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(w6, "decodeXMLStrict", { enumerable: true, get: s3(function() {
    return J4.decodeXML;
  }, "get") });
});
var Rn2 = O5((Wu, xn2) => {
  "use strict";
  function ka(r4, e2) {
    if (!(r4 instanceof e2))
      throw new TypeError("Cannot call a class as a function");
  }
  s3(ka, "_classCallCheck");
  function un2(r4, e2) {
    for (var t4 = 0; t4 < e2.length; t4++) {
      var o3 = e2[t4];
      o3.enumerable = o3.enumerable || false, o3.configurable = true, "value" in o3 && (o3.writable = true), Object.defineProperty(r4, o3.key, o3);
    }
  }
  s3(un2, "_defineProperties");
  function ja(r4, e2, t4) {
    return e2 && un2(r4.prototype, e2), t4 && un2(r4, t4), r4;
  }
  s3(ja, "_createClass");
  function bn2(r4, e2) {
    var t4 = typeof Symbol < "u" && r4[Symbol.iterator] || r4["@@iterator"];
    if (!t4) {
      if (Array.isArray(r4) || (t4 = Ma(r4)) || e2 && r4 && typeof r4.length == "number") {
        t4 && (r4 = t4);
        var o3 = 0, n3 = s3(function() {
        }, "F");
        return { s: n3, n: s3(function() {
          return o3 >= r4.length ? { done: true } : { done: false, value: r4[o3++] };
        }, "n"), e: s3(function(d3) {
          throw d3;
        }, "e"), f: n3 };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var i4 = true, a5 = false, l3;
    return { s: s3(function() {
      t4 = t4.call(r4);
    }, "s"), n: s3(function() {
      var d3 = t4.next();
      return i4 = d3.done, d3;
    }, "n"), e: s3(function(d3) {
      a5 = true, l3 = d3;
    }, "e"), f: s3(function() {
      try {
        !i4 && t4.return != null && t4.return();
      } finally {
        if (a5) throw l3;
      }
    }, "f") };
  }
  s3(bn2, "_createForOfIteratorHelper");
  function Ma(r4, e2) {
    if (r4) {
      if (typeof r4 == "string") return fn3(r4, e2);
      var t4 = Object.prototype.toString.call(r4).slice(8, -1);
      if (t4 === "Object" && r4.constructor && (t4 = r4.constructor.name), t4 === "Map" || t4 === "Set") return Array.from(r4);
      if (t4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t4)) return fn3(r4, e2);
    }
  }
  s3(Ma, "_unsupportedIterableToArray");
  function fn3(r4, e2) {
    (e2 == null || e2 > r4.length) && (e2 = r4.length);
    for (var t4 = 0, o3 = new Array(e2); t4 < e2; t4++)
      o3[t4] = r4[t4];
    return o3;
  }
  s3(fn3, "_arrayLikeToArray");
  var _a2 = pn2(), yn2 = {
    fg: "#FFF",
    bg: "#000",
    newline: false,
    escapeXML: false,
    stream: false,
    colors: La()
  };
  function La() {
    var r4 = {
      0: "#000",
      1: "#A00",
      2: "#0A0",
      3: "#A50",
      4: "#00A",
      5: "#A0A",
      6: "#0AA",
      7: "#AAA",
      8: "#555",
      9: "#F55",
      10: "#5F5",
      11: "#FF5",
      12: "#55F",
      13: "#F5F",
      14: "#5FF",
      15: "#FFF"
    };
    return ir2(0, 5).forEach(function(e2) {
      ir2(0, 5).forEach(function(t4) {
        ir2(0, 5).forEach(function(o3) {
          return Na(e2, t4, o3, r4);
        });
      });
    }), ir2(0, 23).forEach(function(e2) {
      var t4 = e2 + 232, o3 = Sn2(e2 * 10 + 8);
      r4[t4] = "#" + o3 + o3 + o3;
    }), r4;
  }
  s3(La, "getDefaultColors");
  function Na(r4, e2, t4, o3) {
    var n3 = 16 + r4 * 36 + e2 * 6 + t4, i4 = r4 > 0 ? r4 * 40 + 55 : 0, a5 = e2 > 0 ? e2 * 40 + 55 : 0, l3 = t4 > 0 ? t4 * 40 + 55 : 0;
    o3[n3] = qa([i4, a5, l3]);
  }
  s3(Na, "setStyleColor");
  function Sn2(r4) {
    for (var e2 = r4.toString(16); e2.length < 2; )
      e2 = "0" + e2;
    return e2;
  }
  s3(Sn2, "toHexString");
  function qa(r4) {
    var e2 = [], t4 = bn2(r4), o3;
    try {
      for (t4.s(); !(o3 = t4.n()).done; ) {
        var n3 = o3.value;
        e2.push(Sn2(n3));
      }
    } catch (i4) {
      t4.e(i4);
    } finally {
      t4.f();
    }
    return "#" + e2.join("");
  }
  s3(qa, "toColorHexString");
  function mn2(r4, e2, t4, o3) {
    var n3;
    return e2 === "text" ? n3 = Va(t4, o3) : e2 === "display" ? n3 = za(r4, t4, o3) : e2 === "xterm256Foreground" ? n3 = lr2(r4, o3.colors[t4]) : e2 === "xterm256Background" ? n3 = cr2(r4, o3.colors[t4]) : e2 === "rgb" && (n3 = Ba(r4, t4)), n3;
  }
  s3(mn2, "generateOutput");
  function Ba(r4, e2) {
    e2 = e2.substring(2).slice(0, -1);
    var t4 = +e2.substr(0, 2), o3 = e2.substring(5).split(";"), n3 = o3.map(function(i4) {
      return ("0" + Number(i4).toString(16)).substr(-2);
    }).join("");
    return ar2(r4, (t4 === 38 ? "color:#" : "background-color:#") + n3);
  }
  s3(Ba, "handleRgb");
  function za(r4, e2, t4) {
    e2 = parseInt(e2, 10);
    var o3 = {
      "-1": s3(function() {
        return "<br/>";
      }, "_"),
      0: s3(function() {
        return r4.length && Tn2(r4);
      }, "_"),
      1: s3(function() {
        return Q2(r4, "b");
      }, "_"),
      3: s3(function() {
        return Q2(r4, "i");
      }, "_"),
      4: s3(function() {
        return Q2(r4, "u");
      }, "_"),
      8: s3(function() {
        return ar2(r4, "display:none");
      }, "_"),
      9: s3(function() {
        return Q2(r4, "strike");
      }, "_"),
      22: s3(function() {
        return ar2(r4, "font-weight:normal;text-decoration:none;font-style:normal");
      }, "_"),
      23: s3(function() {
        return gn2(r4, "i");
      }, "_"),
      24: s3(function() {
        return gn2(r4, "u");
      }, "_"),
      39: s3(function() {
        return lr2(r4, t4.fg);
      }, "_"),
      49: s3(function() {
        return cr2(r4, t4.bg);
      }, "_"),
      53: s3(function() {
        return ar2(r4, "text-decoration:overline");
      }, "_")
    }, n3;
    return o3[e2] ? n3 = o3[e2]() : 4 < e2 && e2 < 7 ? n3 = Q2(r4, "blink") : 29 < e2 && e2 < 38 ? n3 = lr2(r4, t4.colors[e2 - 30]) : 39 < e2 && e2 < 48 ? n3 = cr2(
      r4,
      t4.colors[e2 - 40]
    ) : 89 < e2 && e2 < 98 ? n3 = lr2(r4, t4.colors[8 + (e2 - 90)]) : 99 < e2 && e2 < 108 && (n3 = cr2(r4, t4.colors[8 + (e2 - 100)])), n3;
  }
  s3(za, "handleDisplay");
  function Tn2(r4) {
    var e2 = r4.slice(0);
    return r4.length = 0, e2.reverse().map(function(t4) {
      return "</" + t4 + ">";
    }).join("");
  }
  s3(Tn2, "resetStyles");
  function ir2(r4, e2) {
    for (var t4 = [], o3 = r4; o3 <= e2; o3++)
      t4.push(o3);
    return t4;
  }
  s3(ir2, "range");
  function Ga(r4) {
    return function(e2) {
      return (r4 === null || e2.category !== r4) && r4 !== "all";
    };
  }
  s3(Ga, "notCategory");
  function hn2(r4) {
    r4 = parseInt(r4, 10);
    var e2 = null;
    return r4 === 0 ? e2 = "all" : r4 === 1 ? e2 = "bold" : 2 < r4 && r4 < 5 ? e2 = "underline" : 4 < r4 && r4 < 7 ? e2 = "blink" : r4 === 8 ? e2 = "hide" : r4 === 9 ? e2 = "strike" : 29 < r4 && r4 < 38 || r4 === 39 || 89 < r4 && r4 < 98 ? e2 = "foreground-color" : (39 < r4 && r4 < 48 || r4 === 49 || 99 < r4 && r4 < 108) && (e2 = "background-color"), e2;
  }
  s3(hn2, "categoryForCode");
  function Va(r4, e2) {
    return e2.escapeXML ? _a2.encodeXML(r4) : r4;
  }
  s3(Va, "pushText");
  function Q2(r4, e2, t4) {
    return t4 || (t4 = ""), r4.push(e2), "<".concat(e2).concat(t4 ? ' style="'.concat(t4, '"') : "", ">");
  }
  s3(Q2, "pushTag");
  function ar2(r4, e2) {
    return Q2(r4, "span", e2);
  }
  s3(ar2, "pushStyle");
  function lr2(r4, e2) {
    return Q2(r4, "span", "color:" + e2);
  }
  s3(lr2, "pushForegroundColor");
  function cr2(r4, e2) {
    return Q2(r4, "span", "background-color:" + e2);
  }
  s3(cr2, "pushBackgroundColor");
  function gn2(r4, e2) {
    var t4;
    if (r4.slice(-1)[0] === e2 && (t4 = r4.pop()), t4)
      return "</" + e2 + ">";
  }
  s3(gn2, "closeTag");
  function Ua(r4, e2, t4) {
    var o3 = false, n3 = 3;
    function i4() {
      return "";
    }
    s3(i4, "remove");
    function a5(T4, E2) {
      return t4("xterm256Foreground", E2), "";
    }
    s3(a5, "removeXterm256Foreground");
    function l3(T4, E2) {
      return t4("xterm256Background", E2), "";
    }
    s3(l3, "removeXterm256Background");
    function c3(T4) {
      return e2.newline ? t4("display", -1) : t4("text", T4), "";
    }
    s3(c3, "newline");
    function d3(T4, E2) {
      o3 = true, E2.trim().length === 0 && (E2 = "0"), E2 = E2.trimRight(";").split(";");
      var C6 = bn2(E2), A4;
      try {
        for (C6.s(); !(A4 = C6.n()).done; ) {
          var j2 = A4.value;
          t4("display", j2);
        }
      } catch (Z2) {
        C6.e(Z2);
      } finally {
        C6.f();
      }
      return "";
    }
    s3(d3, "ansiMess");
    function p6(T4) {
      return t4("text", T4), "";
    }
    s3(p6, "realText");
    function u5(T4) {
      return t4("rgb", T4), "";
    }
    s3(u5, "rgb");
    var m4 = [{
      pattern: /^\x08+/,
      sub: i4
    }, {
      pattern: /^\x1b\[[012]?K/,
      sub: i4
    }, {
      pattern: /^\x1b\[\(B/,
      sub: i4
    }, {
      pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
      sub: u5
    }, {
      pattern: /^\x1b\[38;5;(\d+)m/,
      sub: a5
    }, {
      pattern: /^\x1b\[48;5;(\d+)m/,
      sub: l3
    }, {
      pattern: /^\n/,
      sub: c3
    }, {
      pattern: /^\r+\n/,
      sub: c3
    }, {
      pattern: /^\r/,
      sub: c3
    }, {
      pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
      sub: d3
    }, {
      // CSI n J
      // ED - Erase in Display Clears part of the screen.
      // If n is 0 (or missing), clear from cursor to end of screen.
      // If n is 1, clear from cursor to beginning of the screen.
      // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
      // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
      //   (this feature was added for xterm and is supported by other terminal applications).
      pattern: /^\x1b\[\d?J/,
      sub: i4
    }, {
      // CSI n ; m f
      // HVP - Horizontal Vertical Position Same as CUP
      pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
      sub: i4
    }, {
      // catch-all for CSI sequences?
      pattern: /^\x1b\[?[\d;]{0,3}/,
      sub: i4
    }, {
      /**
       * extracts real text - not containing:
       * - `\x1b' - ESC - escape (Ascii 27)
       * - '\x08' - BS - backspace (Ascii 8)
       * - `\n` - Newline - linefeed (LF) (ascii 10)
       * - `\r` - Windows Carriage Return (CR)
       */
      pattern: /^(([^\x1b\x08\r\n])+)/,
      sub: p6
    }];
    function h5(T4, E2) {
      E2 > n3 && o3 || (o3 = false, r4 = r4.replace(T4.pattern, T4.sub));
    }
    s3(h5, "process");
    var b6 = [], y4 = r4, S5 = y4.length;
    e: for (; S5 > 0; ) {
      for (var x7 = 0, f8 = 0, g3 = m4.length; f8 < g3; x7 = ++f8) {
        var R5 = m4[x7];
        if (h5(R5, x7), r4.length !== S5) {
          S5 = r4.length;
          continue e;
        }
      }
      if (r4.length === S5)
        break;
      b6.push(0), S5 = r4.length;
    }
    return b6;
  }
  s3(Ua, "tokenize");
  function Ha(r4, e2, t4) {
    return e2 !== "text" && (r4 = r4.filter(Ga(hn2(t4))), r4.push({
      token: e2,
      data: t4,
      category: hn2(t4)
    })), r4;
  }
  s3(Ha, "updateStickyStack");
  var Wa = function() {
    function r4(e2) {
      ka(this, r4), e2 = e2 || {}, e2.colors && (e2.colors = Object.assign({}, yn2.colors, e2.colors)), this.options = Object.assign({}, yn2, e2), this.stack = [], this.stickyStack = [];
    }
    return s3(r4, "Filter"), ja(r4, [{
      key: "toHtml",
      value: s3(function(t4) {
        var o3 = this;
        t4 = typeof t4 == "string" ? [t4] : t4;
        var n3 = this.stack, i4 = this.options, a5 = [];
        return this.stickyStack.forEach(function(l3) {
          var c3 = mn2(n3, l3.token, l3.data, i4);
          c3 && a5.push(c3);
        }), Ua(t4.join(""), i4, function(l3, c3) {
          var d3 = mn2(n3, l3, c3, i4);
          d3 && a5.push(d3), i4.stream && (o3.stickyStack = Ha(o3.stickyStack, l3, c3));
        }), n3.length && a5.push(Tn2(n3)), a5.join("");
      }, "toHtml")
    }]), r4;
  }();
  xn2.exports = Wa;
});
var v5 = (() => {
  let r4;
  return typeof window < "u" ? r4 = window : typeof globalThis < "u" ? r4 = globalThis : typeof global < "u" ? r4 = global : typeof self < "u" ? r4 = self : r4 = {}, r4;
})();
function fr2() {
  let r4 = {
    setHandler: s3(() => {
    }, "setHandler"),
    send: s3(() => {
    }, "send")
  };
  return new z2({ transport: r4 });
}
s3(fr2, "mockChannel");
var hr2 = class hr3 {
  constructor() {
    this.getChannel = s3(() => {
      if (!this.channel) {
        let e2 = fr2();
        return this.setChannel(e2), e2;
      }
      return this.channel;
    }, "getChannel");
    this.ready = s3(() => this.promise, "ready");
    this.hasChannel = s3(() => !!this.channel, "hasChannel");
    this.setChannel = s3((e2) => {
      this.channel = e2, this.resolve();
    }, "setChannel");
    this.promise = new Promise((e2) => {
      this.resolve = () => e2(this.getChannel());
    });
  }
};
s3(hr2, "AddonStore");
var mr2 = hr2;
var yr2 = "__STORYBOOK_ADDONS_PREVIEW";
function Nn2() {
  return v5[yr2] || (v5[yr2] = new mr2()), v5[yr2];
}
s3(Nn2, "getAddonsStore");
var q4 = Nn2();
var xr2 = class xr3 {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = s3((e2) => {
      var _a2;
      e2 === ((_a2 = this.currentContext) == null ? void 0 : _a2.id) && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    }, "renderListener");
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = false, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((e2) => {
      e2.destroy && e2.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let e2 = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, e2;
  }
  triggerEffects() {
    this.prevEffects.forEach((e2) => {
      !this.currentEffects.includes(e2) && e2.destroy && e2.destroy();
    }), this.currentEffects.forEach((e2) => {
      this.prevEffects.includes(e2) || (e2.destroy = e2.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), q4.getChannel().on(X, this.renderListener);
  }
  removeRenderListeners() {
    q4.getChannel().removeListener(X, this.renderListener);
  }
};
s3(xr2, "HooksContext");
var ee2 = xr2;
function Tt2(r4) {
  let e2 = s3((...t4) => {
    let { hooks: o3 } = typeof t4[0] == "function" ? t4[1] : t4[0], n3 = o3.currentPhase, i4 = o3.currentHooks, a5 = o3.nextHookIndex, l3 = o3.currentDecoratorName;
    o3.currentDecoratorName = r4.name, o3.prevMountedDecorators.has(r4) ? (o3.currentPhase = "UPDATE", o3.currentHooks = o3.hookListsMap.get(r4) || []) : (o3.currentPhase = "MOUNT", o3.currentHooks = [], o3.hookListsMap.set(r4, o3.currentHooks), o3.prevMountedDecorators.add(r4)), o3.nextHookIndex = 0;
    let c3 = v5.STORYBOOK_HOOKS_CONTEXT;
    v5.STORYBOOK_HOOKS_CONTEXT = o3;
    let d3 = r4(...t4);
    if (v5.STORYBOOK_HOOKS_CONTEXT = c3, o3.currentPhase === "UPDATE" && o3.getNextHook() != null)
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    return o3.currentPhase = n3, o3.currentHooks = i4, o3.nextHookIndex = a5, o3.currentDecoratorName = l3, d3;
  }, "hookified");
  return e2.originalFn = r4, e2;
}
s3(Tt2, "hookify");
var gr2 = 0;
var Vn2 = 25;
var br2 = s3((r4) => (e2, t4) => {
  let o3 = r4(
    Tt2(e2),
    t4.map((n3) => Tt2(n3))
  );
  return (n3) => {
    let { hooks: i4 } = n3;
    i4.prevMountedDecorators ?? (i4.prevMountedDecorators = /* @__PURE__ */ new Set()), i4.mountedDecorators = /* @__PURE__ */ new Set([e2, ...t4]), i4.currentContext = n3, i4.hasUpdates = false;
    let a5 = o3(n3);
    for (gr2 = 1; i4.hasUpdates; )
      if (i4.hasUpdates = false, i4.currentEffects = [], a5 = o3(n3), gr2 += 1, gr2 > Vn2)
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
    return i4.addRenderListeners(), a5;
  };
}, "applyHooks");
var Un2 = s3((r4, e2) => r4.length === e2.length && r4.every((t4, o3) => t4 === e2[o3]), "areDepsEqual");
var Sr2 = s3(
  () => new Error("Storybook preview hooks can only be called inside decorators and story functions."),
  "invalidHooksError"
);
function xt2() {
  return v5.STORYBOOK_HOOKS_CONTEXT || null;
}
s3(xt2, "getHooksContextOrNull");
function Tr2() {
  let r4 = xt2();
  if (r4 == null)
    throw Sr2();
  return r4;
}
s3(Tr2, "getHooksContextOrThrow");
function Hn2(r4, e2, t4) {
  let o3 = Tr2();
  if (o3.currentPhase === "MOUNT") {
    t4 != null && !Array.isArray(t4) && s.warn(
      `${r4} received a final argument that is not an array (instead, received ${t4}). When specified, the final argument must be an array.`
    );
    let n3 = { name: r4, deps: t4 };
    return o3.currentHooks.push(n3), e2(n3), n3;
  }
  if (o3.currentPhase === "UPDATE") {
    let n3 = o3.getNextHook();
    if (n3 == null)
      throw new Error("Rendered more hooks than during the previous render.");
    return n3.name !== r4 && s.warn(
      `Storybook has detected a change in the order of Hooks${o3.currentDecoratorName ? ` called by ${o3.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
    ), t4 != null && n3.deps == null && s.warn(
      `${r4} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
    ), t4 != null && n3.deps != null && t4.length !== n3.deps.length && s.warn(`The final argument passed to ${r4} changed size between renders. The order and size of this array must remain constant.
Previous: ${n3.deps}
Incoming: ${t4}`), (t4 == null || n3.deps == null || !Un2(t4, n3.deps)) && (e2(n3), n3.deps = t4), n3;
  }
  throw Sr2();
}
s3(Hn2, "useHook");
function qe2(r4, e2, t4) {
  let { memoizedState: o3 } = Hn2(
    r4,
    (n3) => {
      n3.memoizedState = e2();
    },
    t4
  );
  return o3;
}
s3(qe2, "useMemoLike");
function Wn2(r4, e2) {
  return qe2("useMemo", r4, e2);
}
s3(Wn2, "useMemo");
function Ee2(r4, e2) {
  return qe2("useCallback", () => r4, e2);
}
s3(Ee2, "useCallback");
function Rt2(r4, e2) {
  return qe2(r4, () => ({ current: e2 }), []);
}
s3(Rt2, "useRefLike");
function $n2(r4) {
  return Rt2("useRef", r4);
}
s3($n2, "useRef");
function Yn2() {
  let r4 = xt2();
  if (r4 != null && r4.currentPhase !== "NONE")
    r4.hasUpdates = true;
  else
    try {
      q4.getChannel().emit(L2);
    } catch {
      s.warn("State updates of Storybook preview hooks work only in browser");
    }
}
s3(Yn2, "triggerUpdate");
function wt2(r4, e2) {
  let t4 = Rt2(
    r4,
    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
    typeof e2 == "function" ? e2() : e2
  ), o3 = s3((n3) => {
    t4.current = typeof n3 == "function" ? n3(t4.current) : n3, Yn2();
  }, "setState");
  return [t4.current, o3];
}
s3(wt2, "useStateLike");
function Kn2(r4) {
  return wt2("useState", r4);
}
s3(Kn2, "useState");
function Xn(r4, e2, t4) {
  let o3 = t4 != null ? () => t4(e2) : e2, [n3, i4] = wt2("useReducer", o3);
  return [n3, s3((l3) => i4((c3) => r4(c3, l3)), "dispatch")];
}
s3(Xn, "useReducer");
function Et2(r4, e2) {
  let t4 = Tr2(), o3 = qe2("useEffect", () => ({ create: r4 }), e2);
  t4.currentEffects.includes(o3) || t4.currentEffects.push(o3);
}
s3(Et2, "useEffect");
function Jn2(r4, e2 = []) {
  let t4 = q4.getChannel();
  return Et2(() => (Object.entries(r4).forEach(([o3, n3]) => t4.on(o3, n3)), () => {
    Object.entries(r4).forEach(
      ([o3, n3]) => t4.removeListener(o3, n3)
    );
  }), [...Object.keys(r4), ...e2]), Ee2(t4.emit.bind(t4), [t4]);
}
s3(Jn2, "useChannel");
function Be2() {
  let { currentContext: r4 } = Tr2();
  if (r4 == null)
    throw Sr2();
  return r4;
}
s3(Be2, "useStoryContext");
function Qn(r4, e2) {
  let { parameters: t4 } = Be2();
  if (r4)
    return t4[r4] ?? e2;
}
s3(Qn, "useParameter");
function Zn2() {
  let r4 = q4.getChannel(), { id: e2, args: t4 } = Be2(), o3 = Ee2(
    (i4) => r4.emit(n2, { storyId: e2, updatedArgs: i4 }),
    [r4, e2]
  ), n3 = Ee2(
    (i4) => r4.emit(H, { storyId: e2, argNames: i4 }),
    [r4, e2]
  );
  return [t4, o3, n3];
}
s3(Zn2, "useArgs");
function es() {
  let r4 = q4.getChannel(), { globals: e2 } = Be2(), t4 = Ee2(
    (o3) => r4.emit(j, { globals: o3 }),
    [r4]
  );
  return [e2, t4];
}
s3(es, "useGlobals");
var rs = s3(({
  name: r4,
  parameterName: e2,
  wrapper: t4,
  skipIfNoParametersOrOptions: o3 = false
}) => {
  let n3 = s3((i4) => (a5, l3) => {
    let c3 = l3.parameters && l3.parameters[e2];
    return c3 && c3.disable || o3 && !i4 && !c3 ? a5(l3) : t4(a5, l3, {
      options: i4,
      parameters: c3
    });
  }, "decorator");
  return (...i4) => typeof i4[0] == "function" ? n3()(...i4) : (...a5) => {
    if (a5.length > 1)
      return i4.length > 1 ? n3(i4)(...a5) : n3(...i4)(...a5);
    throw new Error(
      `Passing stories directly into ${r4}() is not allowed,
        instead use addDecorator(${r4}) and pass options with the '${e2}' parameter`
    );
  };
}, "makeDecorator");
function Rr2(r4, e2) {
  let t4 = {}, o3 = Object.entries(r4);
  for (let n3 = 0; n3 < o3.length; n3++) {
    let [i4, a5] = o3[n3];
    e2(a5, i4) || (t4[i4] = a5);
  }
  return t4;
}
s3(Rr2, "omitBy");
function wr2(r4, e2) {
  let t4 = {};
  for (let o3 = 0; o3 < e2.length; o3++) {
    let n3 = e2[o3];
    Object.prototype.hasOwnProperty.call(r4, n3) && (t4[n3] = r4[n3]);
  }
  return t4;
}
s3(wr2, "pick");
function Er2(r4, e2) {
  let t4 = {}, o3 = Object.entries(r4);
  for (let n3 = 0; n3 < o3.length; n3++) {
    let [i4, a5] = o3[n3];
    e2(a5, i4) && (t4[i4] = a5);
  }
  return t4;
}
s3(Er2, "pickBy");
function k6(r4) {
  if (typeof r4 != "object" || r4 == null)
    return false;
  if (Object.getPrototypeOf(r4) === null)
    return true;
  if (r4.toString() !== "[object Object]")
    return false;
  let e2 = r4;
  for (; Object.getPrototypeOf(e2) !== null; )
    e2 = Object.getPrototypeOf(e2);
  return Object.getPrototypeOf(r4) === e2;
}
s3(k6, "isPlainObject");
function L4(r4, e2) {
  let t4 = {}, o3 = Object.keys(r4);
  for (let n3 = 0; n3 < o3.length; n3++) {
    let i4 = o3[n3], a5 = r4[i4];
    t4[i4] = e2(a5, i4, r4);
  }
  return t4;
}
s3(L4, "mapValues");
var At2 = "[object RegExp]";
var vt2 = "[object String]";
var Ct2 = "[object Number]";
var Pt2 = "[object Boolean]";
var Ar2 = "[object Arguments]";
var Ft2 = "[object Symbol]";
var It2 = "[object Date]";
var Ot = "[object Map]";
var Dt2 = "[object Set]";
var kt2 = "[object Array]";
var jt2 = "[object Function]";
var Mt2 = "[object ArrayBuffer]";
var ze2 = "[object Object]";
var _t3 = "[object Error]";
var Lt2 = "[object DataView]";
var Nt2 = "[object Uint8Array]";
var qt = "[object Uint8ClampedArray]";
var Bt2 = "[object Uint16Array]";
var zt2 = "[object Uint32Array]";
var Gt2 = "[object BigUint64Array]";
var Vt = "[object Int8Array]";
var Ut2 = "[object Int16Array]";
var Ht = "[object Int32Array]";
var Wt2 = "[object BigInt64Array]";
var $t2 = "[object Float32Array]";
var Yt = "[object Float64Array]";
function vr2(r4) {
  return Object.getOwnPropertySymbols(r4).filter((e2) => Object.prototype.propertyIsEnumerable.call(r4, e2));
}
s3(vr2, "getSymbols");
function Cr2(r4) {
  return r4 == null ? r4 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r4);
}
s3(Cr2, "getTag");
function Pr2(r4, e2) {
  if (typeof r4 == typeof e2)
    switch (typeof r4) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return r4 === e2;
      case "number":
        return r4 === e2 || Object.is(r4, e2);
      case "function":
        return r4 === e2;
      case "object":
        return U4(r4, e2);
    }
  return U4(r4, e2);
}
s3(Pr2, "isEqual");
function U4(r4, e2, t4) {
  if (Object.is(r4, e2))
    return true;
  let o3 = Cr2(r4), n3 = Cr2(e2);
  if (o3 === Ar2 && (o3 = ze2), n3 === Ar2 && (n3 = ze2), o3 !== n3)
    return false;
  switch (o3) {
    case vt2:
      return r4.toString() === e2.toString();
    case Ct2: {
      let l3 = r4.valueOf(), c3 = e2.valueOf();
      return l3 === c3 || Number.isNaN(l3) && Number.isNaN(c3);
    }
    case Pt2:
    case It2:
    case Ft2:
      return Object.is(r4.valueOf(), e2.valueOf());
    case At2:
      return r4.source === e2.source && r4.flags === e2.flags;
    case jt2:
      return r4 === e2;
  }
  t4 = t4 ?? /* @__PURE__ */ new Map();
  let i4 = t4.get(r4), a5 = t4.get(e2);
  if (i4 != null && a5 != null)
    return i4 === e2;
  t4.set(r4, e2), t4.set(e2, r4);
  try {
    switch (o3) {
      case Ot: {
        if (r4.size !== e2.size)
          return false;
        for (let [l3, c3] of r4.entries())
          if (!e2.has(l3) || !U4(c3, e2.get(l3), t4))
            return false;
        return true;
      }
      case Dt2: {
        if (r4.size !== e2.size)
          return false;
        let l3 = Array.from(r4.values()), c3 = Array.from(e2.values());
        for (let d3 = 0; d3 < l3.length; d3++) {
          let p6 = l3[d3], u5 = c3.findIndex((m4) => U4(p6, m4, t4));
          if (u5 === -1)
            return false;
          c3.splice(u5, 1);
        }
        return true;
      }
      case kt2:
      case Nt2:
      case qt:
      case Bt2:
      case zt2:
      case Gt2:
      case Vt:
      case Ut2:
      case Ht:
      case Wt2:
      case $t2:
      case Yt: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r4) !== Buffer.isBuffer(e2) || r4.length !== e2.length)
          return false;
        for (let l3 = 0; l3 < r4.length; l3++)
          if (!U4(r4[l3], e2[l3], t4))
            return false;
        return true;
      }
      case Mt2:
        return r4.byteLength !== e2.byteLength ? false : U4(new Uint8Array(r4), new Uint8Array(e2), t4);
      case Lt2:
        return r4.byteLength !== e2.byteLength || r4.byteOffset !== e2.byteOffset ? false : U4(r4.buffer, e2.buffer, t4);
      case _t3:
        return r4.name === e2.name && r4.message === e2.message;
      case ze2: {
        if (!(U4(r4.constructor, e2.constructor, t4) || k6(r4) && k6(e2)))
          return false;
        let c3 = [...Object.keys(r4), ...vr2(r4)], d3 = [...Object.keys(e2), ...vr2(e2)];
        if (c3.length !== d3.length)
          return false;
        for (let p6 = 0; p6 < c3.length; p6++) {
          let u5 = c3[p6], m4 = r4[u5];
          if (!Object.prototype.hasOwnProperty.call(e2, u5))
            return false;
          let h5 = e2[u5];
          if (!U4(m4, h5, t4))
            return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t4.delete(r4), t4.delete(e2);
  }
}
s3(U4, "areObjectsEqual");
var Ke2 = ce2(Ir2(), 1);
function F4(r4) {
  for (var e2 = [], t4 = 1; t4 < arguments.length; t4++)
    e2[t4 - 1] = arguments[t4];
  var o3 = Array.from(typeof r4 == "string" ? [r4] : r4);
  o3[o3.length - 1] = o3[o3.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var n3 = o3.reduce(function(l3, c3) {
    var d3 = c3.match(/\n([\t ]+|(?!\s).)/g);
    return d3 ? l3.concat(d3.map(function(p6) {
      var u5, m4;
      return (m4 = (u5 = p6.match(/[\t ]/g)) === null || u5 === void 0 ? void 0 : u5.length) !== null && m4 !== void 0 ? m4 : 0;
    })) : l3;
  }, []);
  if (n3.length) {
    var i4 = new RegExp(`
[	 ]{` + Math.min.apply(Math, n3) + "}", "g");
    o3 = o3.map(function(l3) {
      return l3.replace(i4, `
`);
    });
  }
  o3[0] = o3[0].replace(/^\r?\n/, "");
  var a5 = o3[0];
  return e2.forEach(function(l3, c3) {
    var d3 = a5.match(/(?:^|\n)( *)$/), p6 = d3 ? d3[1] : "", u5 = l3;
    typeof l3 == "string" && l3.includes(`
`) && (u5 = String(l3).split(`
`).map(function(m4, h5) {
      return h5 === 0 ? m4 : "" + p6 + m4;
    }).join(`
`)), a5 += u5 + o3[c3 + 1];
  }), a5;
}
s3(F4, "dedent");
var de2 = Symbol("incompatible");
var Dr2 = s3((r4, e2) => {
  let t4 = e2.type;
  if (r4 == null || !t4 || e2.mapping)
    return r4;
  switch (t4.name) {
    case "string":
      return String(r4);
    case "enum":
      return r4;
    case "number":
      return Number(r4);
    case "boolean":
      return String(r4) === "true";
    case "array":
      return !t4.value || !Array.isArray(r4) ? de2 : r4.reduce((o3, n3, i4) => {
        let a5 = Dr2(n3, { type: t4.value });
        return a5 !== de2 && (o3[i4] = a5), o3;
      }, new Array(r4.length));
    case "object":
      return typeof r4 == "string" || typeof r4 == "number" ? r4 : !t4.value || typeof r4 != "object" ? de2 : Object.entries(r4).reduce((o3, [n3, i4]) => {
        let a5 = Dr2(i4, { type: t4.value[n3] });
        return a5 === de2 ? o3 : Object.assign(o3, { [n3]: a5 });
      }, {});
    default:
      return de2;
  }
}, "map");
var Xt = s3((r4, e2) => Object.entries(r4).reduce((t4, [o3, n3]) => {
  if (!e2[o3])
    return t4;
  let i4 = Dr2(n3, e2[o3]);
  return i4 === de2 ? t4 : Object.assign(t4, { [o3]: i4 });
}, {}), "mapArgsToTypes");
var Ae2 = s3((r4, e2) => Array.isArray(r4) && Array.isArray(e2) ? e2.reduce(
  (t4, o3, n3) => (t4[n3] = Ae2(r4[n3], e2[n3]), t4),
  [...r4]
).filter((t4) => t4 !== void 0) : !k6(r4) || !k6(e2) ? e2 : Object.keys({ ...r4, ...e2 }).reduce((t4, o3) => {
  if (o3 in e2) {
    let n3 = Ae2(r4[o3], e2[o3]);
    n3 !== void 0 && (t4[o3] = n3);
  } else
    t4[o3] = r4[o3];
  return t4;
}, {}), "combineArgs");
var Jt = s3((r4, e2) => Object.entries(e2).reduce((t4, [o3, { options: n3 }]) => {
  function i4() {
    return o3 in r4 && (t4[o3] = r4[o3]), t4;
  }
  if (s3(i4, "allowArg"), !n3)
    return i4();
  if (!Array.isArray(n3))
    return n.error(F4`
        Invalid argType: '${o3}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types
      `), i4();
  if (n3.some((u5) => u5 && ["object", "function"].includes(typeof u5)))
    return n.error(F4`
        Invalid argType: '${o3}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
      `), i4();
  let a5 = Array.isArray(r4[o3]), l3 = a5 && r4[o3].findIndex((u5) => !n3.includes(u5)), c3 = a5 && l3 === -1;
  if (r4[o3] === void 0 || n3.includes(r4[o3]) || c3)
    return i4();
  let d3 = a5 ? `${o3}[${l3}]` : o3, p6 = n3.map((u5) => typeof u5 == "string" ? `'${u5}'` : String(u5)).join(", ");
  return n.warn(`Received illegal value for '${d3}'. Supported options: ${p6}`), t4;
}, {}), "validateOptions");
var re2 = Symbol("Deeply equal");
var pe2 = s3((r4, e2) => {
  if (typeof r4 != typeof e2)
    return e2;
  if (Pr2(r4, e2))
    return re2;
  if (Array.isArray(r4) && Array.isArray(e2)) {
    let t4 = e2.reduce((o3, n3, i4) => {
      let a5 = pe2(r4[i4], n3);
      return a5 !== re2 && (o3[i4] = a5), o3;
    }, new Array(e2.length));
    return e2.length >= r4.length ? t4 : t4.concat(new Array(r4.length - e2.length).fill(void 0));
  }
  return k6(r4) && k6(e2) ? Object.keys({ ...r4, ...e2 }).reduce((t4, o3) => {
    let n3 = pe2(r4 == null ? void 0 : r4[o3], e2 == null ? void 0 : e2[o3]);
    return n3 === re2 ? t4 : Object.assign(t4, { [o3]: n3 });
  }, {}) : e2;
}, "deepDiff");
var kr2 = "UNTARGETED";
function Qt2({
  args: r4,
  argTypes: e2
}) {
  let t4 = {};
  return Object.entries(r4).forEach(([o3, n3]) => {
    let { target: i4 = kr2 } = e2[o3] || {};
    t4[i4] = t4[i4] || {}, t4[i4][o3] = n3;
  }), t4;
}
s3(Qt2, "groupArgsByTarget");
function ts(r4) {
  return Object.keys(r4).forEach((e2) => r4[e2] === void 0 && delete r4[e2]), r4;
}
s3(ts, "deleteUndefined");
var jr2 = class jr3 {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(e2) {
    if (!(e2 in this.argsByStoryId))
      throw new Error(`No args known for ${e2} -- has it been rendered yet?`);
    return this.argsByStoryId[e2];
  }
  setInitial(e2) {
    if (!this.initialArgsByStoryId[e2.id])
      this.initialArgsByStoryId[e2.id] = e2.initialArgs, this.argsByStoryId[e2.id] = e2.initialArgs;
    else if (this.initialArgsByStoryId[e2.id] !== e2.initialArgs) {
      let t4 = pe2(this.initialArgsByStoryId[e2.id], this.argsByStoryId[e2.id]);
      this.initialArgsByStoryId[e2.id] = e2.initialArgs, this.argsByStoryId[e2.id] = e2.initialArgs, t4 !== re2 && this.updateFromDelta(e2, t4);
    }
  }
  updateFromDelta(e2, t4) {
    let o3 = Jt(t4, e2.argTypes);
    this.argsByStoryId[e2.id] = Ae2(this.argsByStoryId[e2.id], o3);
  }
  updateFromPersisted(e2, t4) {
    let o3 = Xt(t4, e2.argTypes);
    return this.updateFromDelta(e2, o3);
  }
  update(e2, t4) {
    if (!(e2 in this.argsByStoryId))
      throw new Error(`No args known for ${e2} -- has it been rendered yet?`);
    this.argsByStoryId[e2] = ts({
      ...this.argsByStoryId[e2],
      ...t4
    });
  }
};
s3(jr2, "ArgsStore");
var Ge2 = jr2;
var Ve2 = s3((r4 = {}) => Object.entries(r4).reduce((e2, [t4, { defaultValue: o3 }]) => (typeof o3 < "u" && (e2[t4] = o3), e2), {}), "getValuesFromArgTypes");
var Mr2 = class Mr3 {
  constructor({
    globals: e2 = {},
    globalTypes: t4 = {}
  }) {
    this.set({ globals: e2, globalTypes: t4 });
  }
  set({ globals: e2 = {}, globalTypes: t4 = {} }) {
    let o3 = this.initialGlobals && pe2(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(e2), ...Object.keys(t4)]);
    let n3 = Ve2(t4);
    this.initialGlobals = { ...n3, ...e2 }, this.globals = this.initialGlobals, o3 && o3 !== re2 && this.updateFromPersisted(o3);
  }
  filterAllowedGlobals(e2) {
    return Object.entries(e2).reduce((t4, [o3, n3]) => (this.allowedGlobalNames.has(o3) ? t4[o3] = n3 : s.warn(
      `Attempted to set a global (${o3}) that is not defined in initial globals or globalTypes`
    ), t4), {});
  }
  updateFromPersisted(e2) {
    let t4 = this.filterAllowedGlobals(e2);
    this.globals = { ...this.globals, ...t4 };
  }
  get() {
    return this.globals;
  }
  update(e2) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(e2) };
  }
};
s3(Mr2, "GlobalsStore");
var Ue2 = Mr2;
var Zt = ce2(Ir2(), 1);
var ss = (0, Zt.default)(1)(
  (r4) => Object.values(r4).reduce(
    (e2, t4) => (e2[t4.importPath] = e2[t4.importPath] || t4, e2),
    {}
  )
);
var _r2 = class _r3 {
  constructor({ entries: e2 } = { v: 5, entries: {} }) {
    this.entries = e2;
  }
  entryFromSpecifier(e2) {
    let t4 = Object.values(this.entries);
    if (e2 === "*")
      return t4[0];
    if (typeof e2 == "string")
      return this.entries[e2] ? this.entries[e2] : t4.find((i4) => i4.id.startsWith(e2));
    let { name: o3, title: n3 } = e2;
    return t4.find((i4) => i4.name === o3 && i4.title === n3);
  }
  storyIdToEntry(e2) {
    let t4 = this.entries[e2];
    if (!t4)
      throw new D3({ storyId: e2 });
    return t4;
  }
  importPathToEntry(e2) {
    return ss(this.entries)[e2];
  }
};
s3(_r2, "StoryIndexStore");
var He2 = _r2;
var is = s3((r4) => typeof r4 == "string" ? { name: r4 } : r4, "normalizeType");
var as = s3((r4) => typeof r4 == "string" ? { type: r4 } : r4, "normalizeControl");
var ls = s3((r4, e2) => {
  let { type: t4, control: o3, ...n3 } = r4, i4 = {
    name: e2,
    ...n3
  };
  return t4 && (i4.type = is(t4)), o3 ? i4.control = as(o3) : o3 === false && (i4.control = { disable: true }), i4;
}, "normalizeInputType");
var te2 = s3((r4) => L4(r4, ls), "normalizeInputTypes");
var P5 = s3((r4) => Array.isArray(r4) ? r4 : r4 ? [r4] : [], "normalizeArrays");
var fs = F4`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function ve2(r4, e2, t4) {
  let o3 = e2, n3 = typeof e2 == "function" ? e2 : null, { story: i4 } = o3;
  i4 && (s.debug("deprecated story", i4), m(fs));
  let a5 = N4(r4), l3 = typeof o3 != "function" && o3.name || o3.storyName || (i4 == null ? void 0 : i4.name) || a5, c3 = [
    ...P5(o3.decorators),
    ...P5(i4 == null ? void 0 : i4.decorators)
  ], d3 = { ...i4 == null ? void 0 : i4.parameters, ...o3.parameters }, p6 = { ...i4 == null ? void 0 : i4.args, ...o3.args }, u5 = { ...i4 == null ? void 0 : i4.argTypes, ...o3.argTypes }, m4 = [...P5(o3.loaders), ...P5(
    i4 == null ? void 0 : i4.loaders
  )], h5 = [
    ...P5(o3.beforeEach),
    ...P5(i4 == null ? void 0 : i4.beforeEach)
  ], { render: b6, play: y4, tags: S5 = [], globals: x7 = {} } = o3, f8 = d3.__id || G4(t4.id, a5);
  return {
    moduleExport: e2,
    id: f8,
    name: l3,
    tags: S5,
    decorators: c3,
    parameters: d3,
    args: p6,
    argTypes: te2(u5),
    loaders: m4,
    beforeEach: h5,
    globals: x7,
    ...b6 && { render: b6 },
    ...n3 && { userStoryFn: n3 },
    ...y4 && { play: y4 }
  };
}
s3(ve2, "normalizeStory");
function We2(r4, e2 = r4.title, t4) {
  let { id: o3, argTypes: n3 } = r4;
  return {
    id: O4(o3 || e2),
    ...r4,
    title: e2,
    ...n3 && { argTypes: te2(n3) },
    parameters: {
      fileName: t4,
      ...r4.parameters
    }
  };
}
s3(We2, "normalizeComponentAnnotations");
var hs = s3((r4) => {
  let { globals: e2, globalTypes: t4 } = r4;
  (e2 || t4) && s.error(
    "Global args/argTypes can only be set globally",
    JSON.stringify({
      globals: e2,
      globalTypes: t4
    })
  );
}, "checkGlobals");
var gs = s3((r4) => {
  let { options: e2 } = r4;
  (e2 == null ? void 0 : e2.storySort) && s.error("The storySort option parameter can only be set globally");
}, "checkStorySort");
var eo2 = s3((r4) => {
  r4 && (hs(r4), gs(r4));
}, "checkDisallowedParameters");
function to2(r4, e2, t4) {
  let { default: o3, __namedExportsOrder: n3, ...i4 } = r4, a5 = We2(
    o3,
    t4,
    e2
  );
  eo2(a5.parameters);
  let l3 = { meta: a5, stories: {}, moduleExports: r4 };
  return Object.keys(i4).forEach((c3) => {
    if (M4(c3, a5)) {
      let d3 = ve2(c3, i4[c3], a5);
      eo2(d3.parameters), l3.stories[d3.id] = d3;
    }
  }), l3;
}
s3(to2, "processCSFFile");
function no(r4) {
  return r4 != null && bs(r4).includes("mount");
}
s3(no, "mountDestructured");
function bs(r4) {
  let e2 = r4.toString().match(/[^(]*\(([^)]*)/);
  if (!e2)
    return [];
  let t4 = oo(e2[1]);
  if (!t4.length)
    return [];
  let o3 = t4[0];
  return o3.startsWith("{") && o3.endsWith("}") ? oo(o3.slice(1, -1).replace(/\s/g, "")).map((i4) => i4.replace(/:.*|=.*/g, "")) : [];
}
s3(bs, "getUsedProps");
function oo(r4) {
  let e2 = [], t4 = [], o3 = 0;
  for (let i4 = 0; i4 < r4.length; i4++)
    if (r4[i4] === "{" || r4[i4] === "[")
      t4.push(r4[i4] === "{" ? "}" : "]");
    else if (r4[i4] === t4[t4.length - 1])
      t4.pop();
    else if (!t4.length && r4[i4] === ",") {
      let a5 = r4.substring(o3, i4).trim();
      a5 && e2.push(a5), o3 = i4 + 1;
    }
  let n3 = r4.substring(o3).trim();
  return n3 && e2.push(n3), e2;
}
s3(oo, "splitByComma");
function so(r4, e2, t4) {
  let o3 = t4(r4);
  return (n3) => e2(o3, n3);
}
s3(so, "decorateStory");
function io({
  componentId: r4,
  title: e2,
  kind: t4,
  id: o3,
  name: n3,
  story: i4,
  parameters: a5,
  initialArgs: l3,
  argTypes: c3,
  ...d3
} = {}) {
  return d3;
}
s3(io, "sanitizeStoryContextUpdate");
function Lr2(r4, e2) {
  let t4 = {}, o3 = s3((i4) => (a5) => {
    if (!t4.value)
      throw new Error("Decorated function called without init");
    return t4.value = {
      ...t4.value,
      ...io(a5)
    }, i4(t4.value);
  }, "bindWithContext"), n3 = e2.reduce(
    (i4, a5) => so(i4, a5, o3),
    r4
  );
  return (i4) => (t4.value = i4, n3(i4));
}
s3(Lr2, "defaultDecorateStory");
var M5 = s3((...r4) => {
  let e2 = {}, t4 = r4.filter(Boolean), o3 = t4.reduce((n3, i4) => (Object.entries(i4).forEach(([a5, l3]) => {
    let c3 = n3[a5];
    Array.isArray(l3) || typeof c3 > "u" ? n3[a5] = l3 : k6(l3) && k6(c3) ? e2[a5] = true : typeof l3 < "u" && (n3[a5] = l3);
  }), n3), {});
  return Object.keys(e2).forEach((n3) => {
    let i4 = t4.filter(Boolean).map((a5) => a5[n3]).filter((a5) => typeof a5 < "u");
    i4.every((a5) => k6(a5)) ? o3[n3] = M5(...i4) : o3[n3] = i4[i4.length - 1];
  }), o3;
}, "combineParameters");
function Ce2(r4, e2, t4) {
  let { moduleExport: o3, id: n3, name: i4 } = r4 || {}, a5 = ao(
    r4,
    e2,
    t4
  ), l3 = s3(async (T4) => {
    let E2 = {};
    for (let C6 of [
      ..."__STORYBOOK_TEST_LOADERS__" in v5 && Array.isArray(v5.__STORYBOOK_TEST_LOADERS__) ? [v5.__STORYBOOK_TEST_LOADERS__] : [],
      P5(t4.loaders),
      P5(e2.loaders),
      P5(r4.loaders)
    ]) {
      if (T4.abortSignal.aborted)
        return E2;
      let A4 = await Promise.all(C6.map((j2) => j2(T4)));
      Object.assign(E2, ...A4);
    }
    return E2;
  }, "applyLoaders"), c3 = s3(async (T4) => {
    let E2 = new Array();
    for (let C6 of [
      ...P5(t4.beforeEach),
      ...P5(e2.beforeEach),
      ...P5(r4.beforeEach)
    ]) {
      if (T4.abortSignal.aborted)
        return E2;
      let A4 = await C6(T4);
      A4 && E2.push(A4);
    }
    return E2;
  }, "applyBeforeEach"), d3 = s3((T4) => T4.originalStoryFn(T4.args, T4), "undecoratedStoryFn"), { applyDecorators: p6 = Lr2, runStep: u5 } = t4, m4 = [
    ...P5(r4 == null ? void 0 : r4.decorators),
    ...P5(e2 == null ? void 0 : e2.decorators),
    ...P5(t4 == null ? void 0 : t4.decorators)
  ], h5 = (r4 == null ? void 0 : r4.userStoryFn) || (r4 == null ? void 0 : r4.render) || e2.render || t4.render, b6 = br2(p6)(d3, m4), y4 = s3((T4) => b6(T4), "unboundStoryFn"), S5 = (r4 == null ? void 0 : r4.play) ?? (e2 == null ? void 0 : e2.play), x7 = no(S5);
  if (!h5 && !x7)
    throw new q3({ id: n3 });
  let f8 = s3((T4) => async () => (await T4.renderToCanvas(), T4.canvas), "defaultMount"), g3 = r4.mount ?? e2.mount ?? t4.mount ?? f8, R5 = t4.testingLibraryRender;
  return {
    storyGlobals: {},
    ...a5,
    moduleExport: o3,
    id: n3,
    name: i4,
    story: i4,
    originalStoryFn: h5,
    undecoratedStoryFn: d3,
    unboundStoryFn: y4,
    applyLoaders: l3,
    applyBeforeEach: c3,
    playFunction: S5,
    runStep: u5,
    mount: g3,
    testingLibraryRender: R5,
    renderToCanvas: t4.renderToCanvas,
    usesMount: x7
  };
}
s3(Ce2, "prepareStory");
function Nr2(r4, e2, t4) {
  return {
    ...ao(void 0, r4, e2),
    moduleExport: t4
  };
}
s3(Nr2, "prepareMeta");
function ao(r4, e2, t4) {
  var _a2;
  let o3 = ["dev", "test"], n3 = ((_a2 = v5.DOCS_OPTIONS) == null ? void 0 : _a2.autodocs) === true ? ["autodocs"] : [], i4 = z4(
    ...o3,
    ...n3,
    ...t4.tags ?? [],
    ...e2.tags ?? [],
    ...(r4 == null ? void 0 : r4.tags) ?? []
  ), a5 = M5(
    t4.parameters,
    e2.parameters,
    r4 == null ? void 0 : r4.parameters
  ), { argTypesEnhancers: l3 = [], argsEnhancers: c3 = [] } = t4, d3 = M5(
    t4.argTypes,
    e2.argTypes,
    r4 == null ? void 0 : r4.argTypes
  );
  if (r4) {
    let x7 = (r4 == null ? void 0 : r4.userStoryFn) || (r4 == null ? void 0 : r4.render) || e2.render || t4.render;
    a5.__isArgsStory = x7 && x7.length > 0;
  }
  let p6 = {
    ...t4.args,
    ...e2.args,
    ...r4 == null ? void 0 : r4.args
  }, u5 = {
    ...e2.globals,
    ...r4 == null ? void 0 : r4.globals
  }, m4 = {
    componentId: e2.id,
    title: e2.title,
    kind: e2.title,
    // Back compat
    id: (r4 == null ? void 0 : r4.id) || e2.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: (r4 == null ? void 0 : r4.name) || "__meta",
    story: (r4 == null ? void 0 : r4.name) || "__meta",
    // Back compat
    component: e2.component,
    subcomponents: e2.subcomponents,
    tags: i4,
    parameters: a5,
    initialArgs: p6,
    argTypes: d3,
    storyGlobals: u5
  };
  m4.argTypes = l3.reduce(
    (x7, f8) => f8({ ...m4, argTypes: x7 }),
    m4.argTypes
  );
  let h5 = { ...p6 };
  m4.initialArgs = c3.reduce(
    (x7, f8) => ({
      ...x7,
      ...f8({
        ...m4,
        initialArgs: x7
      })
    }),
    h5
  );
  let { name: b6, story: y4, ...S5 } = m4;
  return S5;
}
s3(ao, "preparePartialAnnotations");
function $e2(r4) {
  var _a2;
  let { args: e2 } = r4, t4 = {
    ...r4,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if ((_a2 = v5.FEATURES) == null ? void 0 : _a2.argTypeTargetsV7) {
    let i4 = Qt2(r4);
    t4 = {
      ...r4,
      allArgs: r4.args,
      argsByTarget: i4,
      args: i4[kr2] || {}
    };
  }
  let o3 = Object.entries(t4.args).reduce((i4, [a5, l3]) => {
    var _a3;
    if (!((_a3 = t4.argTypes[a5]) == null ? void 0 : _a3.mapping))
      return i4[a5] = l3, i4;
    let c3 = s3((d3) => {
      let p6 = t4.argTypes[a5].mapping;
      return p6 && d3 in p6 ? p6[d3] : d3;
    }, "mappingFn");
    return i4[a5] = Array.isArray(l3) ? l3.map(c3) : c3(l3), i4;
  }, {}), n3 = Object.entries(o3).reduce((i4, [a5, l3]) => {
    let c3 = t4.argTypes[a5] || {};
    return P4(c3, o3, t4.globals) && (i4[a5] = l3), i4;
  }, {});
  return { ...t4, unmappedArgs: e2, args: n3 };
}
s3($e2, "prepareContext");
var qr2 = s3((r4, e2, t4) => {
  let o3 = typeof r4;
  switch (o3) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: o3 };
    default:
      break;
  }
  return r4 ? t4.has(r4) ? (s.warn(F4`
        We've detected a cycle in arg '${e2}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (t4.add(r4), Array.isArray(r4) ? { name: "array", value: r4.length > 0 ? qr2(r4[0], e2, new Set(
    t4
  )) : { name: "other", value: "unknown" } } : { name: "object", value: L4(r4, (i4) => qr2(i4, e2, new Set(t4))) }) : { name: "object", value: {} };
}, "inferType");
var Br2 = s3((r4) => {
  let { id: e2, argTypes: t4 = {}, initialArgs: o3 = {} } = r4, n3 = L4(o3, (a5, l3) => ({
    name: l3,
    type: qr2(a5, `${e2}.${l3}`, /* @__PURE__ */ new Set())
  })), i4 = L4(t4, (a5, l3) => ({
    name: l3
  }));
  return M5(n3, i4, t4);
}, "inferArgTypes");
Br2.secondPass = true;
var lo = s3((r4, e2) => Array.isArray(e2) ? e2.includes(r4) : r4.match(e2), "matches");
var Ye2 = s3((r4, e2, t4) => !e2 && !t4 ? r4 : r4 && Er2(r4, (o3, n3) => {
  let i4 = o3.name || n3.toString();
  return !!(!e2 || lo(i4, e2)) && (!t4 || !lo(i4, t4));
}), "filterArgTypes");
var Es = s3((r4, e2, t4) => {
  let { type: o3, options: n3 } = r4;
  if (o3) {
    if (t4.color && t4.color.test(e2)) {
      let i4 = o3.name;
      if (i4 === "string")
        return { control: { type: "color" } };
      i4 !== "enum" && s.warn(
        `Addon controls: Control of type color only supports string, received "${i4}" instead`
      );
    }
    if (t4.date && t4.date.test(e2))
      return { control: { type: "date" } };
    switch (o3.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value: i4 } = o3;
        return { control: { type: (i4 == null ? void 0 : i4.length) <= 5 ? "radio" : "select" }, options: i4 };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: n3 ? "select" : "object" } };
    }
  }
}, "inferControl");
var Pe2 = s3((r4) => {
  let {
    argTypes: e2,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    parameters: { __isArgsStory: t4, controls: { include: o3 = null, exclude: n3 = null, matchers: i4 = {} } = {} }
  } = r4;
  if (!t4)
    return e2;
  let a5 = Ye2(e2, o3, n3), l3 = L4(a5, (c3, d3) => (c3 == null ? void 0 : c3.type) && Es(c3, d3.toString(), i4));
  return M5(l3, a5);
}, "inferControls");
Pe2.secondPass = true;
function Fe2({
  argTypes: r4,
  globalTypes: e2,
  argTypesEnhancers: t4,
  decorators: o3,
  loaders: n3,
  beforeEach: i4,
  globals: a5,
  initialGlobals: l3,
  ...c3
}) {
  return a5 && Object.keys(a5).length > 0 && m(F4`
      The preview.js 'globals' field is deprecated and will be removed in Storybook 9.0.
      Please use 'initialGlobals' instead. Learn more:

      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#previewjs-globals-renamed-to-initialglobals
    `), {
    ...r4 && { argTypes: te2(r4) },
    ...e2 && { globalTypes: te2(e2) },
    decorators: P5(o3),
    loaders: P5(n3),
    beforeEach: P5(i4),
    argTypesEnhancers: [
      ...t4 || [],
      Br2,
      // inferControls technically should only run if the user is using the controls addon,
      // and so should be added by a preset there. However, as it seems some code relies on controls
      // annotations (in particular the angular implementation's `cleanArgsDecorator`), for backwards
      // compatibility reasons, we will leave this in the store until 7.0
      Pe2
    ],
    initialGlobals: M5(l3, a5),
    ...c3
  };
}
s3(Fe2, "normalizeProjectAnnotations");
var co = s3((r4) => async () => {
  let e2 = [];
  for (let t4 of r4) {
    let o3 = await t4();
    o3 && e2.unshift(o3);
  }
  return async () => {
    for (let t4 of e2)
      await t4();
  };
}, "composeBeforeAllHooks");
function zr2(r4) {
  return async (e2, t4, o3) => {
    await r4.reduceRight(
      (i4, a5) => async () => a5(e2, i4, o3),
      async () => t4(o3)
    )();
  };
}
s3(zr2, "composeStepRunners");
function Oe2(r4, e2) {
  return r4.map((t4) => {
    var _a2;
    return ((_a2 = t4.default) == null ? void 0 : _a2[e2]) ?? t4[e2];
  }).filter(Boolean);
}
s3(Oe2, "getField");
function oe3(r4, e2, t4 = {}) {
  return Oe2(r4, e2).reduce((o3, n3) => {
    let i4 = P5(n3);
    return t4.reverseFileOrder ? [...i4, ...o3] : [...o3, ...i4];
  }, []);
}
s3(oe3, "getArrayField");
function Ie2(r4, e2) {
  return Object.assign({}, ...Oe2(r4, e2));
}
s3(Ie2, "getObjectField");
function ue2(r4, e2) {
  return Oe2(r4, e2).pop();
}
s3(ue2, "getSingletonField");
function fe2(r4) {
  var _a2;
  let e2 = oe3(r4, "argTypesEnhancers"), t4 = Oe2(r4, "runStep"), o3 = oe3(r4, "beforeAll");
  return {
    parameters: M5(...Oe2(r4, "parameters")),
    decorators: oe3(r4, "decorators", {
      reverseFileOrder: !(((_a2 = v5.FEATURES) == null ? void 0 : _a2.legacyDecoratorFileOrder) ?? false)
    }),
    args: Ie2(r4, "args"),
    argsEnhancers: oe3(r4, "argsEnhancers"),
    argTypes: Ie2(r4, "argTypes"),
    argTypesEnhancers: [
      ...e2.filter((n3) => !n3.secondPass),
      ...e2.filter((n3) => n3.secondPass)
    ],
    globals: Ie2(r4, "globals"),
    initialGlobals: Ie2(r4, "initialGlobals"),
    globalTypes: Ie2(r4, "globalTypes"),
    loaders: oe3(r4, "loaders"),
    beforeAll: co(o3),
    beforeEach: oe3(r4, "beforeEach"),
    render: ue2(r4, "render"),
    renderToCanvas: ue2(r4, "renderToCanvas"),
    renderToDOM: ue2(r4, "renderToDOM"),
    // deprecated
    applyDecorators: ue2(r4, "applyDecorators"),
    runStep: zr2(t4),
    tags: oe3(r4, "tags"),
    mount: ue2(r4, "mount"),
    testingLibraryRender: ue2(r4, "testingLibraryRender")
  };
}
s3(fe2, "composeConfigs");
function Ps(r4) {
  globalThis.defaultProjectAnnotations = r4;
}
s3(Ps, "setDefaultProjectAnnotations");
var Fs = "ComposedStory";
var Is = "Unnamed Story";
function Os(r4) {
  return r4 ? fe2([r4]) : {};
}
s3(Os, "extractAnnotation");
function Ds(r4) {
  let e2 = Array.isArray(r4) ? r4 : [r4];
  return globalThis.globalProjectAnnotations = fe2(e2.map(Os)), fe2([
    globalThis.defaultProjectAnnotations ?? {},
    globalThis.globalProjectAnnotations ?? {}
  ]);
}
s3(Ds, "setProjectAnnotations");
var $5 = [];
function po(r4, e2, t4, o3, n3) {
  var _a2;
  if (r4 === void 0)
    throw new Error("Expected a story but received undefined.");
  e2.title = e2.title ?? Fs;
  let i4 = We2(e2), a5 = n3 || r4.storyName || ((_a2 = r4.story) == null ? void 0 : _a2.name) || r4.name || Is, l3 = ve2(
    a5,
    r4,
    i4
  ), c3 = Fe2(
    fe2([
      o3 && Object.keys(o3).length > 0 ? o3 : globalThis.defaultProjectAnnotations ?? {},
      globalThis.globalProjectAnnotations ?? {},
      t4 ?? {}
    ])
  ), d3 = Ce2(
    l3,
    i4,
    c3
  ), u5 = {
    // TODO: remove loading from globalTypes in 9.0
    ...Ve2(c3.globalTypes),
    ...c3.initialGlobals,
    ...d3.storyGlobals
  }, m4 = s3(() => {
    let f8 = $e2({
      hooks: new ee2(),
      globals: u5,
      args: { ...d3.initialArgs },
      viewMode: "story",
      loaded: {},
      abortSignal: new AbortController().signal,
      step: s3((g3, R5) => d3.runStep(g3, R5, f8), "step"),
      canvasElement: null,
      canvas: {},
      globalTypes: c3.globalTypes,
      ...d3,
      context: null,
      mount: null
    });
    return f8.context = f8, d3.renderToCanvas && (f8.renderToCanvas = async () => {
      var _a3;
      let g3 = await ((_a3 = d3.renderToCanvas) == null ? void 0 : _a3.call(
        d3,
        {
          componentId: d3.componentId,
          title: d3.title,
          id: d3.id,
          name: d3.name,
          tags: d3.tags,
          showMain: s3(() => {
          }, "showMain"),
          showError: s3((R5) => {
            throw new Error(`${R5.title}
${R5.description}`);
          }, "showError"),
          showException: s3((R5) => {
            throw R5;
          }, "showException"),
          forceRemount: true,
          storyContext: f8,
          storyFn: s3(() => d3.unboundStoryFn(f8), "storyFn"),
          unboundStoryFn: d3.unboundStoryFn
        },
        f8.canvasElement
      ));
      g3 && $5.push(g3);
    }), f8.mount = d3.mount(f8), f8;
  }, "initializeContext"), h5, b6 = s3(async (f8) => {
    var _a3;
    let g3 = m4();
    return g3.canvasElement ?? (g3.canvasElement = (_a3 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a3.body), h5 && (g3.loaded = h5.loaded), Object.assign(g3, f8), d3.playFunction(g3);
  }, "play"), y4 = s3((f8) => {
    let g3 = m4();
    return Object.assign(g3, f8), _s(d3, g3);
  }, "run"), S5 = d3.playFunction ? b6 : void 0;
  return Object.assign(
    s3(function(g3) {
      let R5 = m4();
      return h5 && (R5.loaded = h5.loaded), R5.args = {
        ...R5.initialArgs,
        ...g3
      }, d3.unboundStoryFn(R5);
    }, "storyFn"),
    {
      id: d3.id,
      storyName: a5,
      load: s3(async () => {
        for (let g3 of [...$5].reverse())
          await g3();
        $5.length = 0;
        let f8 = m4();
        f8.loaded = await d3.applyLoaders(f8), $5.push(...(await d3.applyBeforeEach(f8)).filter(Boolean)), h5 = f8;
      }, "load"),
      globals: u5,
      args: d3.initialArgs,
      parameters: d3.parameters,
      argTypes: d3.argTypes,
      play: S5,
      run: y4,
      tags: d3.tags
    }
  );
}
s3(po, "composeStory");
var ks = s3((r4, e2, t4, o3) => po(r4, e2, t4, {}, o3), "defaultComposeStory");
function js(r4, e2, t4 = ks) {
  let { default: o3, __esModule: n3, __namedExportsOrder: i4, ...a5 } = r4;
  return Object.entries(a5).reduce((c3, [d3, p6]) => M4(d3, o3) ? Object.assign(c3, {
    [d3]: t4(
      p6,
      o3,
      e2,
      d3
    )
  }) : c3, {});
}
s3(js, "composeStories");
function Ms(r4) {
  return r4.extend({
    mount: s3(async ({ mount: e2, page: t4 }, o3) => {
      await o3(async (n3, ...i4) => {
        if (!("__pw_type" in n3) || "__pw_type" in n3 && n3.__pw_type !== "jsx")
          throw new Error(F4`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories-playwright
            `);
        await t4.evaluate(async (l3) => {
          var _a2, _b, _c;
          let c3 = await ((_a2 = globalThis.__pwUnwrapObject) == null ? void 0 : _a2.call(globalThis, l3));
          return (_c = (_b = "__pw_type" in c3 ? c3.type : c3) == null ? void 0 : _b.load) == null ? void 0 : _c.call(_b);
        }, n3);
        let a5 = await e2(n3, ...i4);
        return await t4.evaluate(async (l3) => {
          var _a2, _b;
          let c3 = await ((_a2 = globalThis.__pwUnwrapObject) == null ? void 0 : _a2.call(globalThis, l3)), d3 = "__pw_type" in c3 ? c3.type : c3, p6 = document.querySelector("#root");
          return (_b = d3 == null ? void 0 : d3.play) == null ? void 0 : _b.call(d3, { canvasElement: p6 });
        }, n3), a5;
      });
    }, "mount")
  });
}
s3(Ms, "createPlaywrightTest");
async function _s(r4, e2) {
  var _a2, _b;
  for (let n3 of [...$5].reverse())
    await n3();
  if ($5.length = 0, !e2.canvasElement) {
    let n3 = document.createElement("div");
    (_b = (_a2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a2.body) == null ? void 0 : _b.appendChild(n3), e2.canvasElement = n3, $5.push(() => {
      var _a3, _b2, _c, _d;
      ((_b2 = (_a3 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a3.body) == null ? void 0 : _b2.contains(n3)) && ((_d = (_c = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _c.body) == null ? void 0 : _d.removeChild(n3));
    });
  }
  if (e2.loaded = await r4.applyLoaders(e2), e2.abortSignal.aborted)
    return;
  $5.push(...(await r4.applyBeforeEach(e2)).filter(Boolean));
  let t4 = r4.playFunction, o3 = r4.usesMount;
  o3 || await e2.mount(), !e2.abortSignal.aborted && t4 && (o3 || (e2.mount = async () => {
    throw new J3({ playFunction: t4.toString() });
  }), await t4(e2));
}
s3(_s, "runStory");
function fo(r4, e2) {
  return Rr2(wr2(r4, e2), (t4) => t4 === void 0);
}
s3(fo, "picky");
var yo = 1e3;
var qs = 1e4;
var Gr2 = class Gr3 {
  constructor(e2, t4, o3) {
    this.importFn = t4;
    this.getStoriesJsonData = s3(() => {
      let e3 = this.getSetStoriesPayload(), t5 = ["fileName", "docsOnly", "framework", "__id", "__isArgsStory"];
      return {
        v: 3,
        stories: L4(e3.stories, (n4) => {
          let { importPath: i5 } = this.storyIndex.entries[n4.id];
          return {
            ...fo(n4, ["id", "name", "title"]),
            importPath: i5,
            // These 3 fields were going to be dropped in v7, but instead we will keep them for the
            // 7.x cycle so that v7 Storybooks can be composed successfully in v6 Storybook.
            // In v8 we will (likely) completely drop support for `extract` and `getStoriesJsonData`
            kind: n4.title,
            story: n4.name,
            parameters: {
              ...fo(n4.parameters, t5),
              fileName: i5
            }
          };
        })
      };
    }, "getStoriesJsonData");
    this.storyIndex = new He2(e2), this.projectAnnotations = Fe2(o3);
    let { initialGlobals: n3, globalTypes: i4 } = this.projectAnnotations;
    this.args = new Ge2(), this.userGlobals = new Ue2({ globals: n3, globalTypes: i4 }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, Ke2.default)(yo)(to2), this.prepareMetaWithCache = (0, Ke2.default)(yo)(Nr2), this.prepareStoryWithCache = (0, Ke2.default)(qs)(Ce2);
  }
  setProjectAnnotations(e2) {
    this.projectAnnotations = Fe2(e2);
    let { initialGlobals: t4, globalTypes: o3 } = e2;
    this.userGlobals.set({ globals: t4, globalTypes: o3 });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn: e2,
    storyIndex: t4
  }) {
    e2 && (this.importFn = e2), t4 && (this.storyIndex.entries = t4.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(e2) {
    return this.storyIndex.storyIdToEntry(e2);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(e2) {
    let { importPath: t4, title: o3 } = this.storyIndex.storyIdToEntry(e2), n3 = await this.importFn(t4);
    return this.processCSFFileWithCache(n3, t4, o3);
  }
  async loadAllCSFFiles() {
    let e2 = {};
    return Object.entries(this.storyIndex.entries).forEach(([o3, { importPath: n3 }]) => {
      e2[n3] = o3;
    }), (await Promise.all(
      Object.entries(e2).map(async ([o3, n3]) => ({
        importPath: o3,
        csfFile: await this.loadCSFFileByStoryId(n3)
      }))
    )).reduce(
      (o3, { importPath: n3, csfFile: i4 }) => (o3[n3] = i4, o3),
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile: e2 }) {
    let t4 = e2.meta;
    return this.prepareMetaWithCache(
      t4,
      this.projectAnnotations,
      e2.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId: e2 }) {
    let t4 = await this.loadCSFFileByStoryId(e2);
    return this.storyFromCSFFile({ storyId: e2, csfFile: t4 });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId: e2,
    csfFile: t4
  }) {
    let o3 = t4.stories[e2];
    if (!o3)
      throw new X2({ storyId: e2 });
    let n3 = t4.meta, i4 = this.prepareStoryWithCache(
      o3,
      n3,
      this.projectAnnotations
    );
    return this.args.setInitial(i4), this.hooks[i4.id] = this.hooks[i4.id] || new ee2(), i4;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile: e2
  }) {
    return Object.keys(this.storyIndex.entries).filter((t4) => !!e2.stories[t4]).map((t4) => this.storyFromCSFFile({ storyId: t4, csfFile: e2 }));
  }
  async loadEntry(e2) {
    let t4 = await this.storyIdToEntry(e2), o3 = t4.type === "docs" ? t4.storiesImports : [], [n3, ...i4] = await Promise.all([
      this.importFn(t4.importPath),
      ...o3.map((a5) => {
        let l3 = this.storyIndex.importPathToEntry(a5);
        return this.loadCSFFileByStoryId(l3.id);
      })
    ]);
    return { entryExports: n3, csfFiles: i4 };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separtely to the (immutable) story.
  getStoryContext(e2, { forceInitialArgs: t4 = false } = {}) {
    let o3 = this.userGlobals.get(), { initialGlobals: n3 } = this.userGlobals;
    return $e2({
      ...e2,
      args: t4 ? e2.initialArgs : this.args.get(e2.id),
      initialGlobals: n3,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals: o3,
      globals: {
        ...o3,
        ...e2.storyGlobals
      },
      hooks: this.hooks[e2.id]
    });
  }
  addCleanupCallbacks(e2, t4) {
    this.cleanupCallbacks[e2.id] = t4;
  }
  async cleanupStory(e2) {
    this.hooks[e2.id].clean();
    let t4 = this.cleanupCallbacks[e2.id];
    if (t4)
      for (let o3 of [...t4].reverse())
        await o3();
    delete this.cleanupCallbacks[e2.id];
  }
  extract(e2 = { includeDocsOnly: false }) {
    let { cachedCSFFiles: t4 } = this;
    if (!t4)
      throw new L3();
    return Object.entries(this.storyIndex.entries).reduce(
      (o3, [n3, { type: i4, importPath: a5 }]) => {
        if (i4 === "docs")
          return o3;
        let l3 = t4[a5], c3 = this.storyFromCSFFile({ storyId: n3, csfFile: l3 });
        return !e2.includeDocsOnly && c3.parameters.docsOnly || (o3[n3] = Object.entries(c3).reduce(
          (d3, [p6, u5]) => p6 === "moduleExport" || typeof u5 == "function" ? d3 : Array.isArray(u5) ? Object.assign(d3, { [p6]: u5.slice().sort() }) : Object.assign(d3, { [p6]: u5 }),
          { args: c3.initialArgs }
        )), o3;
      },
      {}
    );
  }
  // TODO: Remove in 9.0
  getSetStoriesPayload() {
    let e2 = this.extract({ includeDocsOnly: true }), t4 = Object.values(e2).reduce(
      (o3, { title: n3 }) => (o3[n3] = {}, o3),
      {}
    );
    return {
      v: 2,
      globals: this.userGlobals.get(),
      globalParameters: {},
      kindParameters: t4,
      stories: e2
    };
  }
  raw() {
    return m(
      "StoryStore.raw() is deprecated and will be removed in 9.0, please use extract() instead"
    ), Object.values(this.extract()).map(({ id: e2 }) => this.fromId(e2)).filter(Boolean);
  }
  fromId(e2) {
    if (m(
      "StoryStore.fromId() is deprecated and will be removed in 9.0, please use loadStory() instead"
    ), !this.cachedCSFFiles)
      throw new Error("Cannot call fromId/raw() unless you call cacheAllCSFFiles() first.");
    let t4;
    try {
      ({ importPath: t4 } = this.storyIndex.storyIdToEntry(e2));
    } catch {
      return null;
    }
    let o3 = this.cachedCSFFiles[t4], n3 = this.storyFromCSFFile({ storyId: e2, csfFile: o3 });
    return {
      ...n3,
      storyFn: s3((i4) => {
        let a5 = {
          ...this.getStoryContext(n3),
          abortSignal: new AbortController().signal,
          canvasElement: null,
          loaded: {},
          step: s3((l3, c3) => n3.runStep(l3, c3, a5), "step"),
          context: null,
          mount: null,
          canvas: {},
          viewMode: "story"
        };
        return n3.unboundStoryFn({ ...a5, ...i4 });
      }, "storyFn")
    };
  }
};
s3(Gr2, "StoryStore");
var ye2 = Gr2;
function Vr2(r4) {
  return r4.startsWith("\\\\?\\") ? r4 : r4.replace(/\\/g, "/");
}
s3(Vr2, "slash");
var zs = s3((r4) => {
  if (r4.length === 0)
    return r4;
  let e2 = r4[r4.length - 1], t4 = e2 == null ? void 0 : e2.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
  if (r4.length === 1)
    return [t4];
  let o3 = r4[r4.length - 2];
  return t4 && o3 && t4.toLowerCase() === o3.toLowerCase() ? [...r4.slice(0, -2), t4] : t4 && (/^(story|stories)([.][^.]+)$/i.test(e2) || /^index$/i.test(t4)) ? r4.slice(0, -1) : [...r4.slice(0, -1), t4];
}, "sanitize");
function mo(r4) {
  return r4.flatMap((e2) => e2.split("/")).filter(Boolean).join("/");
}
s3(mo, "pathJoin");
var ho = s3((r4, e2, t4) => {
  let { directory: o3, importPathMatcher: n3, titlePrefix: i4 = "" } = e2 || {};
  typeof r4 == "number" && n.warn(F4`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  let a5 = Vr2(String(r4));
  if (n3.exec(a5)) {
    if (!t4) {
      let l3 = a5.replace(o3, ""), c3 = mo([i4, l3]).split("/");
      return c3 = zs(c3), c3.join("/");
    }
    return i4 ? mo([i4, t4]) : t4;
  }
}, "userOrAutoTitleFromSpecifier");
var Gs = s3((r4, e2, t4) => {
  for (let o3 = 0; o3 < e2.length; o3 += 1) {
    let n3 = ho(r4, e2[o3], t4);
    if (n3)
      return n3;
  }
  return t4 || void 0;
}, "userOrAutoTitle");
var go = /\s*\/\s*/;
var bo = s3((r4 = {}) => (e2, t4) => {
  if (e2.title === t4.title && !r4.includeNames)
    return 0;
  let o3 = r4.method || "configure", n3 = r4.order || [], i4 = e2.title.trim().split(go), a5 = t4.title.trim().split(go);
  r4.includeNames && (i4.push(e2.name), a5.push(t4.name));
  let l3 = 0;
  for (; i4[l3] || a5[l3]; ) {
    if (!i4[l3])
      return -1;
    if (!a5[l3])
      return 1;
    let c3 = i4[l3], d3 = a5[l3];
    if (c3 !== d3) {
      let u5 = n3.indexOf(c3), m4 = n3.indexOf(d3), h5 = n3.indexOf("*");
      return u5 !== -1 || m4 !== -1 ? (u5 === -1 && (h5 !== -1 ? u5 = h5 : u5 = n3.length), m4 === -1 && (h5 !== -1 ? m4 = h5 : m4 = n3.length), u5 - m4) : o3 === "configure" ? 0 : c3.localeCompare(d3, r4.locales ? r4.locales : void 0, {
        numeric: true,
        sensitivity: "accent"
      });
    }
    let p6 = n3.indexOf(c3);
    p6 === -1 && (p6 = n3.indexOf("*")), n3 = p6 !== -1 && Array.isArray(n3[p6 + 1]) ? n3[p6 + 1] : [], l3 += 1;
  }
  return 0;
}, "storySort");
var Vs = s3((r4, e2, t4) => {
  if (e2) {
    let o3;
    typeof e2 == "function" ? o3 = e2 : o3 = bo(e2), r4.sort(o3);
  } else
    r4.sort(
      (o3, n3) => t4.indexOf(o3.importPath) - t4.indexOf(n3.importPath)
    );
  return r4;
}, "sortStoriesCommon");
var Us = s3((r4, e2, t4) => {
  try {
    return Vs(r4, e2, t4);
  } catch (o3) {
    throw new Error(F4`
    Error sorting stories with sort parameter ${e2}:

    > ${o3.message}
    
    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
  }
}, "sortStoriesV7");
var Y3 = new Error("prepareAborted");
var { AbortController: To } = globalThis;
function xo(r4) {
  try {
    let { name: e2 = "Error", message: t4 = String(r4), stack: o3 } = r4;
    return { name: e2, message: t4, stack: o3 };
  } catch {
    return { name: "Error", message: String(r4) };
  }
}
s3(xo, "serializeError");
var Ur2 = class Ur3 {
  constructor(e2, t4, o3, n3, i4, a5, l3 = { autoplay: true, forceInitialArgs: false }, c3) {
    this.channel = e2;
    this.store = t4;
    this.renderToScreen = o3;
    this.callbacks = n3;
    this.id = i4;
    this.viewMode = a5;
    this.renderOptions = l3;
    this.type = "story";
    this.notYetRendered = true;
    this.rerenderEnqueued = false;
    this.disableKeyListeners = false;
    this.teardownRender = s3(() => {
    }, "teardownRender");
    this.torndown = false;
    this.abortController = new To(), c3 && (this.story = c3, this.phase = "preparing");
  }
  async runPhase(e2, t4, o3) {
    this.phase = t4, this.channel.emit(B, { newPhase: this.phase, storyId: this.id }), o3 && (await o3(), this.checkIfAborted(e2));
  }
  checkIfAborted(e2) {
    return e2.aborted ? (this.phase = "aborted", this.channel.emit(B, { newPhase: this.phase, storyId: this.id }), true) : false;
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw await this.store.cleanupStory(this.story), Y3;
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(e2) {
    return !!(this.id === e2.id && this.story && this.story === e2.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing"].includes(this.phase);
  }
  async renderToElement(e2) {
    return this.canvasElement = e2, this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    let { forceInitialArgs: e2 } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs: e2 });
  }
  async render({
    initial: e2 = false,
    forceRemount: t4 = false
  } = {}) {
    var _a2, _b, _c, _d;
    let { canvasElement: o3 } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    let n3 = this.story;
    if (!o3)
      throw new Error("cannot render when canvasElement is unset");
    let {
      id: i4,
      componentId: a5,
      title: l3,
      name: c3,
      tags: d3,
      applyLoaders: p6,
      applyBeforeEach: u5,
      unboundStoryFn: m4,
      playFunction: h5,
      runStep: b6
    } = n3;
    t4 && !e2 && (this.cancelRender(), this.abortController = new To());
    let y4 = this.abortController.signal, S5 = false, x7 = n3.usesMount;
    try {
      let f8 = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal: y4,
        canvasElement: o3,
        loaded: {},
        step: s3((A4, j2) => b6(A4, j2, f8), "step"),
        context: null,
        canvas: {},
        renderToCanvas: s3(async () => {
          let A4 = await this.renderToScreen(g3, o3);
          this.teardownRender = A4 || (() => {
          }), S5 = true;
        }, "renderToCanvas"),
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: s3(async (...A4) => {
          var _a3, _b2;
          (_b2 = (_a3 = this.callbacks).showStoryDuringRender) == null ? void 0 : _b2.call(_a3);
          let j2 = null;
          return await this.runPhase(y4, "rendering", async () => {
            j2 = await n3.mount(f8)(...A4);
          }), x7 && await this.runPhase(y4, "playing"), j2;
        }, "mount")
      };
      f8.context = f8;
      let g3 = {
        componentId: a5,
        title: l3,
        kind: l3,
        id: i4,
        name: c3,
        story: c3,
        tags: d3,
        ...this.callbacks,
        showError: s3((A4) => (this.phase = "errored", this.callbacks.showError(A4)), "showError"),
        showException: s3((A4) => (this.phase = "errored", this.callbacks.showException(A4)), "showException"),
        forceRemount: t4 || this.notYetRendered,
        storyContext: f8,
        storyFn: s3(() => m4(f8), "storyFn"),
        unboundStoryFn: m4
      };
      if (await this.runPhase(y4, "loading", async () => {
        f8.loaded = await p6(f8);
      }), y4.aborted)
        return;
      let R5 = await u5(f8);
      if (this.store.addCleanupCallbacks(n3, R5), this.checkIfAborted(y4) || (!S5 && !x7 && await f8.mount(), this.notYetRendered = false, y4.aborted))
        return;
      let T4 = ((_b = (_a2 = this.story.parameters) == null ? void 0 : _a2.test) == null ? void 0 : _b.dangerouslyIgnoreUnhandledErrors) === true, E2 = /* @__PURE__ */ new Set(), C6 = s3((A4) => E2.add("error" in A4 ? A4.error : A4.reason), "onError");
      if (this.renderOptions.autoplay && t4 && h5 && this.phase !== "errored") {
        window.addEventListener("error", C6), window.addEventListener("unhandledrejection", C6), this.disableKeyListeners = true;
        try {
          if (x7 ? await h5(f8) : (f8.mount = async () => {
            throw new J3({ playFunction: h5.toString() });
          }, await this.runPhase(y4, "playing", async () => h5(f8))), !S5)
            throw new z3();
          this.checkIfAborted(y4), !T4 && E2.size > 0 ? await this.runPhase(y4, "errored") : await this.runPhase(y4, "played");
        } catch (A4) {
          if ((_d = (_c = this.callbacks).showStoryDuringRender) == null ? void 0 : _d.call(_c), await this.runPhase(y4, "errored", async () => {
            this.channel.emit(a2, xo(A4));
          }), this.story.parameters.throwPlayFunctionExceptions !== false)
            throw A4;
          console.error(A4);
        }
        if (!T4 && E2.size > 0 && this.channel.emit(
          Y,
          Array.from(E2).map(xo)
        ), this.disableKeyListeners = false, window.removeEventListener("unhandledrejection", C6), window.removeEventListener("error", C6), y4.aborted)
          return;
      }
      await this.runPhase(
        y4,
        "completed",
        async () => this.channel.emit(X, i4)
      );
    } catch (f8) {
      this.phase = "errored", this.callbacks.showException(f8);
    }
    this.rerenderEnqueued && (this.rerenderEnqueued = false, this.render());
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing")
      this.rerenderEnqueued = true;
    else
      return this.render();
  }
  async remount() {
    return await this.teardown(), this.render({ forceRemount: true });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    var _a2;
    (_a2 = this.abortController) == null ? void 0 : _a2.abort();
  }
  async teardown() {
    this.torndown = true, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
    for (let e2 = 0; e2 < 3; e2 += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((t4) => setTimeout(t4, 0));
    }
    window.location.reload(), await new Promise(() => {
    });
  }
};
s3(Ur2, "StoryRender");
var ne2 = Ur2;
var { fetch: di } = v5;
var pi = "./index.json";
var Hr2 = class Hr3 {
  constructor(e2, t4, o3 = q4.getChannel(), n3 = true) {
    this.importFn = e2;
    this.getProjectAnnotations = t4;
    this.channel = o3;
    this.storyRenders = [];
    this.storeInitializationPromise = new Promise((i4, a5) => {
      this.resolveStoreInitializationPromise = i4, this.rejectStoreInitializationPromise = a5;
    }), n3 && this.initialize();
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: s3((e2, t4) => {
          if (this.storyStoreValue)
            return m("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[t4];
          throw new U3();
        }, "get")
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      let e2 = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(e2), await this.initializeWithProjectAnnotations(e2);
    } catch (e2) {
      this.rejectStoreInitializationPromise(e2);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(m2, this.onStoryIndexChanged.bind(this)), this.channel.on(j, this.onUpdateGlobals.bind(this)), this.channel.on(n2, this.onUpdateArgs.bind(this)), this.channel.on(RE, this.onRequestArgTypesInfo.bind(this)), this.channel.on(H, this.onResetArgs.bind(this)), this.channel.on(L2, this.onForceReRender.bind(this)), this.channel.on(P, this.onForceRemount.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      let e2 = await this.getProjectAnnotations();
      if (this.renderToCanvas = e2.renderToCanvas, !this.renderToCanvas)
        throw new G3();
      return e2;
    } catch (e2) {
      throw this.renderPreviewEntryError("Error reading preview.js:", e2), e2;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(e2) {
    this.projectAnnotationsBeforeInitialization = e2;
    try {
      let t4 = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(t4);
    } catch (t4) {
      throw this.renderPreviewEntryError("Error loading story index:", t4), t4;
    }
  }
  async runBeforeAllHook(e2) {
    var _a2, _b;
    try {
      await ((_a2 = this.beforeAllCleanup) == null ? void 0 : _a2.call(this)), this.beforeAllCleanup = await ((_b = e2.beforeAll) == null ? void 0 : _b.call(e2));
    } catch (t4) {
      throw this.renderPreviewEntryError("Error in beforeAll hook:", t4), t4;
    }
  }
  async getStoryIndexFromServer() {
    let e2 = await di(pi);
    if (e2.status === 200)
      return e2.json();
    throw new M3({ text: await e2.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(e2) {
    if (!this.projectAnnotationsBeforeInitialization)
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    this.storyStoreValue = new ye2(
      e2,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "emitGlobals" });
    let e2 = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(u2, e2);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: e2
  }) {
    delete this.previewEntryError, this.getProjectAnnotations = e2;
    let t4 = await this.getProjectAnnotationsOrRenderError();
    if (await this.runBeforeAllHook(t4), !this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(t4);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(t4), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      try {
        let e2 = await this.getStoryIndexFromServer();
        if (this.projectAnnotationsBeforeInitialization) {
          this.initializeWithStoryIndex(e2);
          return;
        }
        await this.onStoriesChanged({ storyIndex: e2 });
      } catch (e2) {
        throw this.renderPreviewEntryError("Error loading story index:", e2), e2;
      }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: e2,
    storyIndex: t4
  }) {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "onStoriesChanged" });
    await this.storyStoreValue.onStoriesChanged({ importFn: e2, storyIndex: t4 });
  }
  async onUpdateGlobals({
    globals: e2,
    currentStory: t4
  }) {
    if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
      throw new Y2({ methodName: "onUpdateGlobals" });
    if (this.storyStoreValue.userGlobals.update(e2), t4) {
      let { initialGlobals: o3, storyGlobals: n3, userGlobals: i4, globals: a5 } = this.storyStoreValue.getStoryContext(t4);
      this.channel.emit(U, {
        initialGlobals: o3,
        userGlobals: i4,
        storyGlobals: n3,
        globals: a5
      });
    } else {
      let { initialGlobals: o3, globals: n3 } = this.storyStoreValue.userGlobals;
      this.channel.emit(U, {
        initialGlobals: o3,
        userGlobals: n3,
        storyGlobals: {},
        globals: n3
      });
    }
    await Promise.all(this.storyRenders.map((o3) => o3.rerender()));
  }
  async onUpdateArgs({ storyId: e2, updatedArgs: t4 }) {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "onUpdateArgs" });
    this.storyStoreValue.args.update(e2, t4), await Promise.all(
      this.storyRenders.filter((o3) => o3.id === e2 && !o3.renderOptions.forceInitialArgs).map(
        (o3) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          o3.story && o3.story.usesMount ? o3.remount() : o3.rerender()
        )
      )
    ), this.channel.emit(Q, {
      storyId: e2,
      args: this.storyStoreValue.args.get(e2)
    });
  }
  async onRequestArgTypesInfo({ id: e2, payload: t4 }) {
    var _a2;
    try {
      await this.storeInitializationPromise;
      let o3 = await ((_a2 = this.storyStoreValue) == null ? void 0 : _a2.loadStory(t4));
      this.channel.emit(SE, {
        id: e2,
        success: true,
        payload: { argTypes: (o3 == null ? void 0 : o3.argTypes) || {} },
        error: null
      });
    } catch (o3) {
      this.channel.emit(SE, {
        id: e2,
        success: false,
        error: o3 == null ? void 0 : o3.message
      });
    }
  }
  async onResetArgs({ storyId: e2, argNames: t4 }) {
    var _a2;
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "onResetArgs" });
    let n3 = ((_a2 = this.storyRenders.find((l3) => l3.id === e2)) == null ? void 0 : _a2.story) || await this.storyStoreValue.loadStory({ storyId: e2 }), a5 = (t4 || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(n3.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(e2))
      ])
    ]).reduce((l3, c3) => (l3[c3] = n3.initialArgs[c3], l3), {});
    await this.onUpdateArgs({ storyId: e2, updatedArgs: a5 });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((e2) => e2.rerender()));
  }
  async onForceRemount({ storyId: e2 }) {
    await Promise.all(this.storyRenders.filter((t4) => t4.id === e2).map((t4) => t4.remount()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(e2, t4, o3, n3) {
    if (!this.renderToCanvas || !this.storyStoreValue)
      throw new Y2({
        methodName: "renderStoryToElement"
      });
    let i4 = new ne2(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      o3,
      e2.id,
      "docs",
      n3,
      e2
    );
    return i4.renderToElement(t4), this.storyRenders.push(i4), async () => {
      await this.teardownRender(i4);
    };
  }
  async teardownRender(e2, { viewModeChanged: t4 } = {}) {
    var _a2;
    this.storyRenders = this.storyRenders.filter((o3) => o3 !== e2), await ((_a2 = e2 == null ? void 0 : e2.teardown) == null ? void 0 : _a2.call(e2, { viewModeChanged: t4 }));
  }
  // API
  async loadStory({ storyId: e2 }) {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "loadStory" });
    return this.storyStoreValue.loadStory({ storyId: e2 });
  }
  getStoryContext(e2, { forceInitialArgs: t4 = false } = {}) {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "getStoryContext" });
    return this.storyStoreValue.getStoryContext(e2, { forceInitialArgs: t4 });
  }
  async extract(e2) {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "extract" });
    if (this.previewEntryError)
      throw this.previewEntryError;
    return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(e2);
  }
  // UTILITIES
  renderPreviewEntryError(e2, t4) {
    this.previewEntryError = t4, s.error(e2), s.error(t4), this.channel.emit(N, t4);
  }
};
s3(Hr2, "Preview");
var me2 = Hr2;
var ui = false;
var Wr2 = "Invariant failed";
function Xe2(r4, e2) {
  if (!r4) {
    if (ui)
      throw new Error(Wr2);
    var t4 = typeof e2 == "function" ? e2() : e2, o3 = t4 ? "".concat(Wr2, ": ").concat(t4) : Wr2;
    throw new Error(o3);
  }
}
s3(Xe2, "invariant");
var $r2 = class $r3 {
  constructor(e2, t4, o3, n3) {
    this.channel = e2;
    this.store = t4;
    this.renderStoryToElement = o3;
    this.storyIdByName = s3((e3) => {
      let t5 = this.nameToStoryId.get(e3);
      if (t5)
        return t5;
      throw new Error(`No story found with that name: ${e3}`);
    }, "storyIdByName");
    this.componentStories = s3(() => this.componentStoriesValue, "componentStories");
    this.componentStoriesFromCSFFile = s3((e3) => this.store.componentStoriesFromCSFFile({ csfFile: e3 }), "componentStoriesFromCSFFile");
    this.storyById = s3((e3) => {
      if (!e3) {
        if (!this.primaryStory)
          throw new Error(
            "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
          );
        return this.primaryStory;
      }
      let t5 = this.storyIdToCSFFile.get(e3);
      if (!t5)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${e3}`);
      return this.store.storyFromCSFFile({ storyId: e3, csfFile: t5 });
    }, "storyById");
    this.getStoryContext = s3((e3) => ({
      ...this.store.getStoryContext(e3),
      loaded: {},
      viewMode: "docs"
    }), "getStoryContext");
    this.loadStory = s3((e3) => this.store.loadStory({ storyId: e3 }), "loadStory");
    this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), n3.forEach((i4, a5) => {
      this.referenceCSFFile(i4);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(e2) {
    this.exportsToCSFFile.set(e2.moduleExports, e2), this.exportsToCSFFile.set(e2.moduleExports.default, e2), this.store.componentStoriesFromCSFFile(
      { csfFile: e2 }
    ).forEach((o3) => {
      let n3 = e2.stories[o3.id];
      this.storyIdToCSFFile.set(n3.id, e2), this.exportToStory.set(n3.moduleExport, o3);
    });
  }
  attachCSFFile(e2) {
    if (!this.exportsToCSFFile.has(e2.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    if (this.attachedCSFFiles.has(e2))
      return;
    this.attachedCSFFiles.add(e2), this.store.componentStoriesFromCSFFile({ csfFile: e2 }).forEach((o3) => {
      this.nameToStoryId.set(o3.name, o3.id), this.componentStoriesValue.push(o3), this.primaryStory || (this.primaryStory = o3);
    });
  }
  referenceMeta(e2, t4) {
    let o3 = this.resolveModuleExport(e2);
    if (o3.type !== "meta")
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    t4 && this.attachCSFFile(o3.csfFile);
  }
  get projectAnnotations() {
    let { projectAnnotations: e2 } = this.store;
    if (!e2)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return e2;
  }
  resolveAttachedModuleExportType(e2) {
    if (e2 === "story") {
      if (!this.primaryStory)
        throw new Error(
          "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
        );
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0)
      throw new Error(
        "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
      );
    let t4 = Array.from(this.attachedCSFFiles)[0];
    if (e2 === "meta")
      return { type: "meta", csfFile: t4 };
    let { component: o3 } = t4.meta;
    if (!o3)
      throw new Error(
        "Attached CSF file does not defined a component, did you forget to export one?"
      );
    return { type: "component", component: o3 };
  }
  resolveModuleExport(e2) {
    let t4 = this.exportsToCSFFile.get(e2);
    if (t4)
      return { type: "meta", csfFile: t4 };
    let o3 = this.exportToStory.get(e2);
    return o3 ? { type: "story", story: o3 } : { type: "component", component: e2 };
  }
  resolveOf(e2, t4 = []) {
    let o3;
    if (["component", "meta", "story"].includes(e2)) {
      let n3 = e2;
      o3 = this.resolveAttachedModuleExportType(n3);
    } else
      o3 = this.resolveModuleExport(e2);
    if (t4.length && !t4.includes(o3.type)) {
      let n3 = o3.type === "component" ? "component or unknown" : o3.type;
      throw new Error(F4`Invalid value passed to the 'of' prop. The value was resolved to a '${n3}' type but the only types for this block are: ${t4.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (o3.type) {
      case "component":
        return {
          ...o3,
          projectAnnotations: this.projectAnnotations
        };
      case "meta":
        return {
          ...o3,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: o3.csfFile })
        };
      case "story":
      default:
        return o3;
    }
  }
};
s3($r2, "DocsContext");
var K3 = $r2;
var Yr2 = class Yr3 {
  constructor(e2, t4, o3, n3) {
    this.channel = e2;
    this.store = t4;
    this.entry = o3;
    this.callbacks = n3;
    this.type = "docs";
    this.subtype = "csf";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = o3.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports: e2, csfFiles: t4 = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw Y3;
    let { importPath: o3, title: n3 } = this.entry, i4 = this.store.processCSFFileWithCache(
      e2,
      o3,
      n3
    ), a5 = Object.keys(i4.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: a5, csfFile: i4 }), this.csfFiles = [i4, ...t4], this.preparing = false;
  }
  isEqual(e2) {
    return !!(this.id === e2.id && this.story && this.story === e2.story);
  }
  docsContext(e2) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let t4 = new K3(
      this.channel,
      this.store,
      e2,
      this.csfFiles
    );
    return this.csfFiles.forEach((o3) => t4.attachCSFFile(o3)), t4;
  }
  async renderToElement(e2, t4) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let o3 = this.docsContext(t4), { docs: n3 } = this.story.parameters || {};
    if (!n3)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let i4 = await n3.renderer(), { render: a5 } = i4, l3 = s3(async () => {
      try {
        await a5(o3, n3, e2), this.channel.emit(I, this.id);
      } catch (c3) {
        this.callbacks.showException(c3);
      }
    }, "renderDocs");
    return this.rerender = async () => l3(), this.teardownRender = async ({ viewModeChanged: c3 }) => {
      !c3 || !e2 || i4.unmount(e2);
    }, l3();
  }
  async teardown({ viewModeChanged: e2 } = {}) {
    var _a2;
    (_a2 = this.teardownRender) == null ? void 0 : _a2.call(this, { viewModeChanged: e2 }), this.torndown = true;
  }
};
s3(Yr2, "CsfDocsRender");
var De2 = Yr2;
var Kr2 = class Kr3 {
  constructor(e2, t4, o3, n3) {
    this.channel = e2;
    this.store = t4;
    this.entry = o3;
    this.callbacks = n3;
    this.type = "docs";
    this.subtype = "mdx";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = o3.id;
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports: e2, csfFiles: t4 = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw Y3;
    this.csfFiles = t4, this.exports = e2, this.preparing = false;
  }
  isEqual(e2) {
    return !!(this.id === e2.id && this.exports && this.exports === e2.exports);
  }
  docsContext(e2) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new K3(
      this.channel,
      this.store,
      e2,
      this.csfFiles
    );
  }
  async renderToElement(e2, t4) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    let o3 = this.docsContext(t4), { docs: n3 } = this.store.projectAnnotations.parameters || {};
    if (!n3)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let i4 = { ...n3, page: this.exports.default }, a5 = await n3.renderer(), { render: l3 } = a5, c3 = s3(async () => {
      try {
        await l3(o3, i4, e2), this.channel.emit(I, this.id);
      } catch (d3) {
        this.callbacks.showException(d3);
      }
    }, "renderDocs");
    return this.rerender = async () => c3(), this.teardownRender = async ({ viewModeChanged: d3 } = {}) => {
      !d3 || !e2 || (a5.unmount(e2), this.torndown = true);
    }, c3();
  }
  async teardown({ viewModeChanged: e2 } = {}) {
    var _a2;
    (_a2 = this.teardownRender) == null ? void 0 : _a2.call(this, { viewModeChanged: e2 }), this.torndown = true;
  }
};
s3(Kr2, "MdxDocsRender");
var ke2 = Kr2;
var Fi = globalThis;
function Ii(r4) {
  let e2 = r4.composedPath && r4.composedPath()[0] || r4.target;
  return /input|textarea/i.test(e2.tagName) || e2.getAttribute("contenteditable") !== null;
}
s3(Ii, "focusInInput");
var Fo = "attached-mdx";
var Oi = "unattached-mdx";
function Di({ tags: r4 }) {
  return (r4 == null ? void 0 : r4.includes(Oi)) || (r4 == null ? void 0 : r4.includes(Fo));
}
s3(Di, "isMdxEntry");
function Jr2(r4) {
  return r4.type === "story";
}
s3(Jr2, "isStoryRender");
function ki(r4) {
  return r4.type === "docs";
}
s3(ki, "isDocsRender");
function ji(r4) {
  return ki(r4) && r4.subtype === "csf";
}
s3(ji, "isCsfDocsRender");
var Qr2 = class Qr3 extends me2 {
  constructor(t4, o3, n3, i4) {
    super(t4, o3, void 0, false);
    this.importFn = t4;
    this.getProjectAnnotations = o3;
    this.selectionStore = n3;
    this.view = i4;
    this.initialize();
  }
  setupListeners() {
    super.setupListeners(), Fi.onkeydown = this.onKeydown.bind(this), this.channel.on(p, this.onSetCurrentStory.bind(this)), this.channel.on(
      k,
      this.onUpdateQueryParams.bind(this)
    ), this.channel.on(t2, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue)
      throw new Y2({ methodName: "setInitialGlobals" });
    let { globals: t4 } = this.selectionStore.selectionSpecifier || {};
    t4 && this.storyStoreValue.userGlobals.updateFromPersisted(t4), this.emitGlobals();
  }
  // If initialization gets as far as the story index, this function runs.
  async initializeWithStoryIndex(t4) {
    return await super.initializeWithStoryIndex(t4), this.selectSpecifiedStory();
  }
  // Use the selection specifier to choose a story, then render it
  async selectSpecifiedStory() {
    if (!this.storyStoreValue)
      throw new Y2({
        methodName: "selectSpecifiedStory"
      });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    let { storySpecifier: t4, args: o3 } = this.selectionStore.selectionSpecifier, n3 = this.storyStoreValue.storyIndex.entryFromSpecifier(t4);
    if (!n3) {
      t4 === "*" ? this.renderStoryLoadingException(t4, new F2()) : this.renderStoryLoadingException(
        t4,
        new K2({ storySpecifier: t4.toString() })
      );
      return;
    }
    let { id: i4, type: a5 } = n3;
    this.selectionStore.setSelection({ storyId: i4, viewMode: a5 }), this.channel.emit(q, this.selectionStore.selection), this.channel.emit(
      r2,
      this.selectionStore.selection
    ), await this.renderSelection({ persistedArgs: o3 });
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: t4
  }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: t4 }), this.selectionStore.selection && this.renderSelection();
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: t4,
    storyIndex: o3
  }) {
    await super.onStoriesChanged({ importFn: t4, storyIndex: o3 }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(t4) {
    if (!this.storyRenders.find((o3) => o3.disableKeyListeners) && !Ii(t4)) {
      let { altKey: o3, ctrlKey: n3, metaKey: i4, shiftKey: a5, key: l3, code: c3, keyCode: d3 } = t4;
      this.channel.emit(W, {
        event: { altKey: o3, ctrlKey: n3, metaKey: i4, shiftKey: a5, key: l3, code: c3, keyCode: d3 }
      });
    }
  }
  async onSetCurrentStory(t4) {
    this.selectionStore.setSelection({ viewMode: "story", ...t4 }), await this.storeInitializationPromise, this.channel.emit(r2, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(t4) {
    this.selectionStore.setQueryParams(t4);
  }
  async onUpdateGlobals({ globals: t4 }) {
    var _a2, _b;
    let o3 = this.currentRender instanceof ne2 && this.currentRender.story || void 0;
    super.onUpdateGlobals({ globals: t4, currentStory: o3 }), (this.currentRender instanceof ke2 || this.currentRender instanceof De2) && await ((_b = (_a2 = this.currentRender).rerender) == null ? void 0 : _b.call(_a2));
  }
  async onUpdateArgs({ storyId: t4, updatedArgs: o3 }) {
    super.onUpdateArgs({ storyId: t4, updatedArgs: o3 });
  }
  async onPreloadStories({ ids: t4 }) {
    await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(t4.map((o3) => {
      var _a2;
      return (_a2 = this.storyStoreValue) == null ? void 0 : _a2.loadEntry(o3);
    }));
  }
  // RENDERING
  // We can either have:
  // - a story selected in "story" viewMode,
  //     in which case we render it to the root element, OR
  // - a story selected in "docs" viewMode,
  //     in which case we render the docsPage for that story
  async renderSelection({ persistedArgs: t4 } = {}) {
    var _a2, _b, _c, _d;
    let { renderToCanvas: o3 } = this;
    if (!this.storyStoreValue || !o3)
      throw new Y2({ methodName: "renderSelection" });
    let { selection: n3 } = this.selectionStore;
    if (!n3)
      throw new Error("Cannot call renderSelection as no selection was made");
    let { storyId: i4 } = n3, a5;
    try {
      a5 = await this.storyStoreValue.storyIdToEntry(i4);
    } catch (h5) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(i4, h5);
      return;
    }
    let l3 = ((_a2 = this.currentSelection) == null ? void 0 : _a2.storyId) !== i4, c3 = ((_b = this.currentRender) == null ? void 0 : _b.type) !== a5.type;
    a5.type === "story" ? this.view.showPreparingStory({ immediate: c3 }) : this.view.showPreparingDocs({ immediate: c3 }), ((_c = this.currentRender) == null ? void 0 : _c.isPreparing()) && await this.teardownRender(this.currentRender);
    let d3;
    a5.type === "story" ? d3 = new ne2(
      this.channel,
      this.storyStoreValue,
      o3,
      this.mainStoryCallbacks(i4),
      i4,
      "story"
    ) : Di(a5) ? d3 = new ke2(
      this.channel,
      this.storyStoreValue,
      a5,
      this.mainStoryCallbacks(i4)
    ) : d3 = new De2(
      this.channel,
      this.storyStoreValue,
      a5,
      this.mainStoryCallbacks(i4)
    );
    let p6 = this.currentSelection;
    this.currentSelection = n3;
    let u5 = this.currentRender;
    this.currentRender = d3;
    try {
      await d3.prepare();
    } catch (h5) {
      u5 && await this.teardownRender(u5), h5 !== Y3 && this.renderStoryLoadingException(i4, h5);
      return;
    }
    let m4 = !l3 && u5 && !d3.isEqual(u5);
    if (t4 && Jr2(d3) && (Xe2(!!d3.story), this.storyStoreValue.args.updateFromPersisted(d3.story, t4)), u5 && !u5.torndown && !l3 && !m4 && !c3) {
      this.currentRender = u5, this.channel.emit(K, i4), this.view.showMain();
      return;
    }
    if (u5 && await this.teardownRender(u5, { viewModeChanged: c3 }), p6 && (l3 || c3) && this.channel.emit(f2, i4), Jr2(d3)) {
      Xe2(!!d3.story);
      let {
        parameters: h5,
        initialArgs: b6,
        argTypes: y4,
        unmappedArgs: S5,
        initialGlobals: x7,
        userGlobals: f8,
        storyGlobals: g3,
        globals: R5
      } = this.storyStoreValue.getStoryContext(d3.story);
      this.channel.emit(w, {
        id: i4,
        parameters: h5,
        initialArgs: b6,
        argTypes: y4,
        args: S5
      }), this.channel.emit(U, { userGlobals: f8, storyGlobals: g3, globals: R5, initialGlobals: x7 });
    } else {
      let { parameters: h5 } = this.storyStoreValue.projectAnnotations, { initialGlobals: b6, globals: y4 } = this.storyStoreValue.userGlobals;
      if (this.channel.emit(U, {
        globals: y4,
        initialGlobals: b6,
        storyGlobals: {},
        userGlobals: y4
      }), ji(d3) || ((_d = d3.entry.tags) == null ? void 0 : _d.includes(Fo))) {
        if (!d3.csfFiles)
          throw new H3({ storyId: i4 });
        ({ parameters: h5 } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: d3.csfFiles[0]
        }));
      }
      this.channel.emit(D, {
        id: i4,
        parameters: h5
      });
    }
    Jr2(d3) ? (Xe2(!!d3.story), this.storyRenders.push(d3), this.currentRender.renderToElement(
      this.view.prepareForStory(d3.story)
    )) : this.currentRender.renderToElement(
      this.view.prepareForDocs(),
      // This argument is used for docs, which is currently only compatible with HTMLElements
      this.renderStoryToElement.bind(this)
    );
  }
  async teardownRender(t4, { viewModeChanged: o3 = false } = {}) {
    var _a2;
    this.storyRenders = this.storyRenders.filter((n3) => n3 !== t4), await ((_a2 = t4 == null ? void 0 : t4.teardown) == null ? void 0 : _a2.call(t4, { viewModeChanged: o3 }));
  }
  // UTILITIES
  mainStoryCallbacks(t4) {
    return {
      showStoryDuringRender: s3(() => this.view.showStoryDuringRender(), "showStoryDuringRender"),
      showMain: s3(() => this.view.showMain(), "showMain"),
      showError: s3((o3) => this.renderError(t4, o3), "showError"),
      showException: s3((o3) => this.renderException(t4, o3), "showException")
    };
  }
  renderPreviewEntryError(t4, o3) {
    super.renderPreviewEntryError(t4, o3), this.view.showErrorDisplay(o3);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(V);
  }
  renderStoryLoadingException(t4, o3) {
    s.error(o3), this.view.showErrorDisplay(o3), this.channel.emit(V, t4);
  }
  // renderException is used if we fail to render the story and it is uncaught by the app layer
  renderException(t4, o3) {
    let { name: n3 = "Error", message: i4 = String(o3), stack: a5 } = o3;
    this.channel.emit(b2, { name: n3, message: i4, stack: a5 }), this.channel.emit(B, { newPhase: "errored", storyId: t4 }), this.view.showErrorDisplay(
      o3
    ), s.error(`Error rendering story '${t4}':`), s.error(o3);
  }
  // renderError is used by the various app layers to inform the user they have done something
  // wrong -- for instance returned the wrong thing from a story
  renderError(t4, { title: o3, description: n3 }) {
    s.error(`Error rendering story ${o3}: ${n3}`), this.channel.emit(x, { title: o3, description: n3 }), this.channel.emit(B, { newPhase: "errored", storyId: t4 }), this.view.showErrorDisplay({
      message: o3,
      stack: n3
    });
  }
};
s3(Qr2, "PreviewWithSelection");
var he2 = Qr2;
var Me2 = ce2(tr2(), 1);
var Go = ce2(tr2(), 1);
var zo = /^[a-zA-Z0-9 _-]*$/;
var Vo = /^-?[0-9]+(\.[0-9]+)?$/;
var aa = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;
var Uo = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i;
var st2 = s3((r4 = "", e2) => r4 === null || r4 === "" || !zo.test(r4) ? false : e2 == null || e2 instanceof Date || typeof e2 == "number" || typeof e2 == "boolean" ? true : typeof e2 == "string" ? zo.test(e2) || Vo.test(e2) || aa.test(e2) || Uo.test(e2) : Array.isArray(e2) ? e2.every((t4) => st2(
  r4,
  t4
)) : k6(e2) ? Object.entries(e2).every(([t4, o3]) => st2(t4, o3)) : false, "validateArgs");
var la = {
  delimiter: ";",
  // we're parsing a single query param
  nesting: true,
  arrayRepeat: true,
  arrayRepeatSyntax: "bracket",
  nestingSyntax: "js",
  // objects are encoded using dot notation
  valueDeserializer(r4) {
    if (r4.startsWith("!")) {
      if (r4 === "!undefined")
        return;
      if (r4 === "!null")
        return null;
      if (r4 === "!true")
        return true;
      if (r4 === "!false")
        return false;
      if (r4.startsWith("!date(") && r4.endsWith(")"))
        return new Date(r4.replaceAll(" ", "+").slice(6, -1));
      if (r4.startsWith("!hex(") && r4.endsWith(")"))
        return `#${r4.slice(5, -1)}`;
      let e2 = r4.slice(1).match(Uo);
      if (e2)
        return r4.startsWith("!rgba") || r4.startsWith("!RGBA") ? `${e2[1]}(${e2[2]}, ${e2[3]}, ${e2[4]}, ${e2[5]})` : r4.startsWith("!hsla") || r4.startsWith(
          "!HSLA"
        ) ? `${e2[1]}(${e2[2]}, ${e2[3]}%, ${e2[4]}%, ${e2[5]})` : r4.startsWith("!rgb") || r4.startsWith("!RGB") ? `${e2[1]}(${e2[2]}, ${e2[3]}, ${e2[4]})` : `${e2[1]}(${e2[2]}, ${e2[3]}%, ${e2[4]}%)`;
    }
    return Vo.test(r4) ? Number(r4) : r4;
  }
};
var it = s3((r4) => {
  let e2 = r4.split(";").map((t4) => t4.replace("=", "~").replace(":", "="));
  return Object.entries((0, Go.parse)(e2.join(";"), la)).reduce((t4, [o3, n3]) => st2(o3, n3) ? Object.assign(t4, { [o3]: n3 }) : (n.warn(F4`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url
    `), t4), {});
}, "parseArgsParam");
var { history: Ho, document: X3 } = v5;
function ca(r4) {
  let e2 = (r4 || "").match(/^\/story\/(.+)/);
  if (!e2)
    throw new Error(`Invalid path '${r4}',  must start with '/story/'`);
  return e2[1];
}
s3(ca, "pathToId");
var Wo = s3(({
  selection: r4,
  extraParams: e2
}) => {
  let t4 = X3 == null ? void 0 : X3.location.search.slice(1), { path: o3, selectedKind: n3, selectedStory: i4, ...a5 } = (0, Me2.parse)(t4);
  return `?${(0, Me2.stringify)({
    ...a5,
    ...e2,
    ...r4 && { id: r4.storyId, viewMode: r4.viewMode }
  })}`;
}, "getQueryString");
var da = s3((r4) => {
  if (!r4)
    return;
  let e2 = Wo({ selection: r4 }), { hash: t4 = "" } = X3.location;
  X3.title = r4.storyId, Ho.replaceState({}, "", `${X3.location.pathname}${e2}${t4}`);
}, "setPath");
var pa = s3((r4) => r4 != null && typeof r4 == "object" && Array.isArray(r4) === false, "isObject");
var je2 = s3(
  (r4) => {
    if (r4 !== void 0) {
      if (typeof r4 == "string")
        return r4;
      if (Array.isArray(r4))
        return je2(r4[0]);
      if (pa(r4))
        return je2(
          Object.values(r4).filter(Boolean)
        );
    }
  },
  "getFirstString"
);
var ua = s3(() => {
  if (typeof X3 < "u") {
    let r4 = X3.location.search.slice(1), e2 = (0, Me2.parse)(r4), t4 = typeof e2.args == "string" ? it(e2.args) : void 0, o3 = typeof e2.globals == "string" ? it(e2.globals) : void 0, n3 = je2(e2.viewMode);
    (typeof n3 != "string" || !n3.match(/docs|story/)) && (n3 = "story");
    let i4 = je2(e2.path), a5 = i4 ? ca(i4) : je2(e2.id);
    if (a5)
      return { storySpecifier: a5, args: t4, globals: o3, viewMode: n3 };
  }
  return null;
}, "getSelectionSpecifierFromPath");
var at2 = class at3 {
  constructor() {
    this.selectionSpecifier = ua();
  }
  setSelection(e2) {
    this.selection = e2, da(this.selection);
  }
  setQueryParams(e2) {
    let t4 = Wo({ extraParams: e2 }), { hash: o3 = "" } = X3.location;
    Ho.replaceState({}, "", `${X3.location.pathname}${t4}${o3}`);
  }
};
s3(at2, "UrlStore");
var ge2 = at2;
var An2 = ce2(Rn2(), 1);
var vn2 = ce2(tr2(), 1);
var { document: D4 } = v5;
var wn2 = 100;
var Cn2 = ((i4) => (i4.MAIN = "MAIN", i4.NOPREVIEW = "NOPREVIEW", i4.PREPARING_STORY = "PREPARING_STORY", i4.PREPARING_DOCS = "PREPARING_DOCS", i4.ERROR = "ERROR", i4))(Cn2 || {});
var yt2 = {
  PREPARING_STORY: "sb-show-preparing-story",
  PREPARING_DOCS: "sb-show-preparing-docs",
  MAIN: "sb-show-main",
  NOPREVIEW: "sb-show-nopreview",
  ERROR: "sb-show-errordisplay"
};
var mt2 = {
  centered: "sb-main-centered",
  fullscreen: "sb-main-fullscreen",
  padded: "sb-main-padded"
};
var En2 = new An2.default({
  escapeXML: true
});
var ht2 = class ht3 {
  constructor() {
    this.testing = false;
    if (typeof D4 < "u") {
      let { __SPECIAL_TEST_PARAMETER__: e2 } = (0, vn2.parse)(D4.location.search.slice(1));
      switch (e2) {
        case "preparing-story": {
          this.showPreparingStory(), this.testing = true;
          break;
        }
        case "preparing-docs": {
          this.showPreparingDocs(), this.testing = true;
          break;
        }
        default:
      }
    }
  }
  // Get ready to render a story, returning the element to render to
  prepareForStory(e2) {
    return this.showStory(), this.applyLayout(e2.parameters.layout), D4.documentElement.scrollTop = 0, D4.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return D4.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), D4.documentElement.scrollTop = 0, D4.documentElement.scrollLeft = 0, this.docsRoot();
  }
  docsRoot() {
    return D4.getElementById("storybook-docs");
  }
  applyLayout(e2 = "padded") {
    if (e2 === "none") {
      D4.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(e2);
    let t4 = mt2[e2];
    D4.body.classList.remove(this.currentLayoutClass), D4.body.classList.add(t4), this.currentLayoutClass = t4;
  }
  checkIfLayoutExists(e2) {
    mt2[e2] || s.warn(
      F4`
          The desired layout: ${e2} is not a valid option.
          The possible options are: ${Object.keys(mt2).join(", ")}, none.
        `
    );
  }
  showMode(e2) {
    clearTimeout(this.preparingTimeout), Object.keys(Cn2).forEach((t4) => {
      t4 === e2 ? D4.body.classList.add(yt2[t4]) : D4.body.classList.remove(yt2[t4]);
    });
  }
  showErrorDisplay({ message: e2 = "", stack: t4 = "" }) {
    let o3 = e2, n3 = t4, i4 = e2.split(`
`);
    i4.length > 1 && ([o3] = i4, n3 = i4.slice(1).join(`
`).replace(/^\n/, "")), D4.getElementById("error-message").innerHTML = En2.toHtml(o3), D4.getElementById("error-stack").innerHTML = En2.toHtml(n3), this.showMode("ERROR");
  }
  showNoPreview() {
    var _a2, _b;
    this.testing || (this.showMode("NOPREVIEW"), (_a2 = this.storyRoot()) == null ? void 0 : _a2.setAttribute("hidden", "true"), (_b = this.docsRoot()) == null ? void 0 : _b.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate: e2 = false } = {}) {
    clearTimeout(this.preparingTimeout), e2 ? this.showMode("PREPARING_STORY") : this.preparingTimeout = setTimeout(
      () => this.showMode("PREPARING_STORY"),
      wn2
    );
  }
  showPreparingDocs({ immediate: e2 = false } = {}) {
    clearTimeout(this.preparingTimeout), e2 ? this.showMode("PREPARING_DOCS") : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_DOCS"), wn2);
  }
  showMain() {
    this.showMode("MAIN");
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    D4.body.classList.add(yt2.MAIN);
  }
};
s3(ht2, "WebView");
var be2 = ht2;
var gt2 = class gt3 extends he2 {
  constructor(t4, o3) {
    super(t4, o3, new ge2(), new be2());
    this.importFn = t4;
    this.getProjectAnnotations = o3;
    v5.__STORYBOOK_PREVIEW__ = this;
  }
};
s3(gt2, "PreviewWeb");
var { document: le2 } = v5;
var Ya = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
];
var Ka = "script";
var Pn2 = "scripts-root";
function pr2() {
  let r4 = le2.createEvent("Event");
  r4.initEvent("DOMContentLoaded", true, true), le2.dispatchEvent(r4);
}
s3(pr2, "simulateDOMContentLoaded");
function Xa(r4, e2, t4) {
  let o3 = le2.createElement("script");
  o3.type = r4.type === "module" ? "module" : "text/javascript", r4.src ? (o3.onload = e2, o3.onerror = e2, o3.src = r4.src) : o3.textContent = r4.innerText, t4 ? t4.appendChild(o3) : le2.head.appendChild(o3), r4.parentNode.removeChild(r4), r4.src || e2();
}
s3(Xa, "insertScript");
function Fn2(r4, e2, t4 = 0) {
  r4[t4](() => {
    t4++, t4 === r4.length ? e2() : Fn2(r4, e2, t4);
  });
}
s3(Fn2, "insertScriptsSequentially");
function In2(r4) {
  let e2 = le2.getElementById(Pn2);
  e2 ? e2.innerHTML = "" : (e2 = le2.createElement("div"), e2.id = Pn2, le2.body.appendChild(e2));
  let t4 = Array.from(r4.querySelectorAll(Ka));
  if (t4.length) {
    let o3 = [];
    t4.forEach((n3) => {
      let i4 = n3.getAttribute("type");
      (!i4 || Ya.includes(i4)) && o3.push((a5) => Xa(n3, a5, e2));
    }), o3.length && Fn2(o3, pr2, void 0);
  } else
    pr2();
}
s3(In2, "simulatePageLoad");

// node_modules/@storybook/instrumenter/dist/index.mjs
var __require2 = ((x7) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(x7, { get: (a22, b6) => (typeof __require < "u" ? __require : a22)[b6] }) : x7)(function(x7) {
  if (typeof __require < "u") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + x7 + '" is not supported');
});
var f6 = { reset: [0, 0], bold: [1, 22, "\x1B[22m\x1B[1m"], dim: [2, 22, "\x1B[22m\x1B[2m"], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29], black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] };
var h3 = Object.entries(f6);
function a3(n3) {
  return String(n3);
}
a3.open = "";
a3.close = "";
function C4(n3 = false) {
  let e2 = typeof process < "u" ? process : void 0, i4 = (e2 == null ? void 0 : e2.env) || {}, g3 = (e2 == null ? void 0 : e2.argv) || [];
  return !("NO_COLOR" in i4 || g3.includes("--no-color")) && ("FORCE_COLOR" in i4 || g3.includes("--color") || (e2 == null ? void 0 : e2.platform) === "win32" || n3 && i4.TERM !== "dumb" || "CI" in i4) || typeof window < "u" && !!window.chrome;
}
function p4(n3 = false) {
  let e2 = C4(n3), i4 = (r4, t4, c3, o3) => {
    let l3 = "", s4 = 0;
    do
      l3 += r4.substring(s4, o3) + c3, s4 = o3 + t4.length, o3 = r4.indexOf(t4, s4);
    while (~o3);
    return l3 + r4.substring(s4);
  }, g3 = (r4, t4, c3 = r4) => {
    let o3 = (l3) => {
      let s4 = String(l3), b6 = s4.indexOf(t4, r4.length);
      return ~b6 ? r4 + i4(s4, t4, c3, b6) + t4 : r4 + s4 + t4;
    };
    return o3.open = r4, o3.close = t4, o3;
  }, u5 = { isColorSupported: e2 }, d3 = (r4) => `\x1B[${r4}m`;
  for (let [r4, t4] of h3) u5[r4] = e2 ? g3(d3(t4[0]), d3(t4[1]), t4[2]) : a3;
  return u5;
}
var f22 = p4(false);
function getKeysOfEnumerableProperties(object, compareKeys) {
  let rawKeys = Object.keys(object), keys2 = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
  if (Object.getOwnPropertySymbols) for (let symbol of Object.getOwnPropertySymbols(object)) Object.getOwnPropertyDescriptor(object, symbol).enumerable && keys2.push(symbol);
  return keys2;
}
function printIteratorEntries(iterator, config3, indentation, depth, refs2, printer22, separator = ": ") {
  let result2 = "", width = 0, current = iterator.next();
  if (!current.done) {
    result2 += config3.spacingOuter;
    let indentationNext = indentation + config3.indent;
    for (; !current.done; ) {
      if (result2 += indentationNext, width++ === config3.maxWidth) {
        result2 += "";
        break;
      }
      let name2 = printer22(current.value[0], config3, indentationNext, depth, refs2), value2 = printer22(current.value[1], config3, indentationNext, depth, refs2);
      result2 += name2 + separator + value2, current = iterator.next(), current.done ? config3.min || (result2 += ",") : result2 += `,${config3.spacingInner}`;
    }
    result2 += config3.spacingOuter + indentation;
  }
  return result2;
}
function printIteratorValues(iterator, config3, indentation, depth, refs2, printer22) {
  let result2 = "", width = 0, current = iterator.next();
  if (!current.done) {
    result2 += config3.spacingOuter;
    let indentationNext = indentation + config3.indent;
    for (; !current.done; ) {
      if (result2 += indentationNext, width++ === config3.maxWidth) {
        result2 += "";
        break;
      }
      result2 += printer22(current.value, config3, indentationNext, depth, refs2), current = iterator.next(), current.done ? config3.min || (result2 += ",") : result2 += `,${config3.spacingInner}`;
    }
    result2 += config3.spacingOuter + indentation;
  }
  return result2;
}
function printListItems(list, config3, indentation, depth, refs2, printer22) {
  let result2 = "";
  list = list instanceof ArrayBuffer ? new DataView(list) : list;
  let isDataView = (l3) => l3 instanceof DataView, length = isDataView(list) ? list.byteLength : list.length;
  if (length > 0) {
    result2 += config3.spacingOuter;
    let indentationNext = indentation + config3.indent;
    for (let i4 = 0; i4 < length; i4++) {
      if (result2 += indentationNext, i4 === config3.maxWidth) {
        result2 += "";
        break;
      }
      (isDataView(list) || i4 in list) && (result2 += printer22(isDataView(list) ? list.getInt8(i4) : list[i4], config3, indentationNext, depth, refs2)), i4 < length - 1 ? result2 += `,${config3.spacingInner}` : config3.min || (result2 += ",");
    }
    result2 += config3.spacingOuter + indentation;
  }
  return result2;
}
function printObjectProperties(val, config3, indentation, depth, refs2, printer22) {
  let result2 = "", keys2 = getKeysOfEnumerableProperties(val, config3.compareKeys);
  if (keys2.length > 0) {
    result2 += config3.spacingOuter;
    let indentationNext = indentation + config3.indent;
    for (let i4 = 0; i4 < keys2.length; i4++) {
      let key2 = keys2[i4], name2 = printer22(key2, config3, indentationNext, depth, refs2), value2 = printer22(val[key2], config3, indentationNext, depth, refs2);
      result2 += `${indentationNext + name2}: ${value2}`, i4 < keys2.length - 1 ? result2 += `,${config3.spacingInner}` : config3.min || (result2 += ",");
    }
    result2 += config3.spacingOuter + indentation;
  }
  return result2;
}
var asymmetricMatcher = typeof Symbol == "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621;
var SPACE$2 = " ";
var serialize$5 = (val, config3, indentation, depth, refs2, printer22) => {
  let stringedValue = val.toString();
  if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") return ++depth > config3.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}[${printListItems(val.sample, config3, indentation, depth, refs2, printer22)}]`;
  if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") return ++depth > config3.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config3, indentation, depth, refs2, printer22)}}`;
  if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching" || stringedValue === "StringContaining" || stringedValue === "StringNotContaining") return stringedValue + SPACE$2 + printer22(val.sample, config3, indentation, depth, refs2);
  if (typeof val.toAsymmetricMatcher != "function") throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
  return val.toAsymmetricMatcher();
};
var test$5 = (val) => val && val.$$typeof === asymmetricMatcher;
var plugin$5 = { serialize: serialize$5, test: test$5 };
var SPACE$1 = " ";
var OBJECT_NAMES = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]);
var ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
function testName(name2) {
  return OBJECT_NAMES.has(name2) || ARRAY_REGEXP.test(name2);
}
var test$4 = (val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
function isNamedNodeMap(collection) {
  return collection.constructor.name === "NamedNodeMap";
}
var serialize$4 = (collection, config3, indentation, depth, refs2, printer22) => {
  let name2 = collection.constructor.name;
  return ++depth > config3.maxDepth ? `[${name2}]` : (config3.min ? "" : name2 + SPACE$1) + (OBJECT_NAMES.has(name2) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}) : { ...collection }, config3, indentation, depth, refs2, printer22)}}` : `[${printListItems([...collection], config3, indentation, depth, refs2, printer22)}]`);
};
var plugin$4 = { serialize: serialize$4, test: test$4 };
function escapeHTML(str) {
  return str.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
function printProps(keys2, props, config3, indentation, depth, refs2, printer22) {
  let indentationNext = indentation + config3.indent, colors = config3.colors;
  return keys2.map((key2) => {
    let value2 = props[key2], printed = printer22(value2, config3, indentationNext, depth, refs2);
    return typeof value2 != "string" && (printed.includes(`
`) && (printed = config3.spacingOuter + indentationNext + printed + config3.spacingOuter + indentation), printed = `{${printed}}`), `${config3.spacingInner + indentation + colors.prop.open + key2 + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;
  }).join("");
}
function printChildren(children, config3, indentation, depth, refs2, printer22) {
  return children.map((child) => config3.spacingOuter + indentation + (typeof child == "string" ? printText(child, config3) : printer22(child, config3, indentation, depth, refs2))).join("");
}
function printText(text, config3) {
  let contentColor = config3.colors.content;
  return contentColor.open + escapeHTML(text) + contentColor.close;
}
function printComment(comment, config3) {
  let commentColor = config3.colors.comment;
  return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;
}
function printElement(type5, printedProps, printedChildren, config3, indentation) {
  let tagColor = config3.colors.tag;
  return `${tagColor.open}<${type5}${printedProps && tagColor.close + printedProps + config3.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config3.spacingOuter}${indentation}${tagColor.open}</${type5}` : `${printedProps && !config3.min ? "" : " "}/`}>${tagColor.close}`;
}
function printElementAsLeaf(type5, config3) {
  let tagColor = config3.colors.tag;
  return `${tagColor.open}<${type5}${tagColor.close} ${tagColor.open} />${tagColor.close}`;
}
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var FRAGMENT_NODE = 11;
var ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
function testHasAttribute(val) {
  try {
    return typeof val.hasAttribute == "function" && val.hasAttribute("is");
  } catch {
    return false;
  }
}
function testNode(val) {
  let constructorName = val.constructor.name, { nodeType, tagName } = val, isCustomElement3 = typeof tagName == "string" && tagName.includes("-") || testHasAttribute(val);
  return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement3) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
}
var test$3 = (val) => {
  var _a2;
  return ((_a2 = val == null ? void 0 : val.constructor) == null ? void 0 : _a2.name) && testNode(val);
};
function nodeIsText(node) {
  return node.nodeType === TEXT_NODE;
}
function nodeIsComment(node) {
  return node.nodeType === COMMENT_NODE;
}
function nodeIsFragment(node) {
  return node.nodeType === FRAGMENT_NODE;
}
var serialize$3 = (node, config3, indentation, depth, refs2, printer22) => {
  if (nodeIsText(node)) return printText(node.data, config3);
  if (nodeIsComment(node)) return printComment(node.data, config3);
  let type5 = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
  return ++depth > config3.maxDepth ? printElementAsLeaf(type5, config3) : printElement(type5, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}), config3, indentation + config3.indent, depth, refs2, printer22), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config3, indentation + config3.indent, depth, refs2, printer22), config3, indentation);
};
var plugin$3 = { serialize: serialize$3, test: test$3 };
var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
var IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
var getImmutableName = (name2) => `Immutable.${name2}`;
var printAsLeaf = (name2) => `[${name2}]`;
var SPACE = " ";
var LAZY = "";
function printImmutableEntries(val, config3, indentation, depth, refs2, printer22, type5) {
  return ++depth > config3.maxDepth ? printAsLeaf(getImmutableName(type5)) : `${getImmutableName(type5) + SPACE}{${printIteratorEntries(val.entries(), config3, indentation, depth, refs2, printer22)}}`;
}
function getRecordEntries(val) {
  let i4 = 0;
  return { next() {
    if (i4 < val._keys.length) {
      let key2 = val._keys[i4++];
      return { done: false, value: [key2, val.get(key2)] };
    }
    return { done: true, value: void 0 };
  } };
}
function printImmutableRecord(val, config3, indentation, depth, refs2, printer22) {
  let name2 = getImmutableName(val._name || "Record");
  return ++depth > config3.maxDepth ? printAsLeaf(name2) : `${name2 + SPACE}{${printIteratorEntries(getRecordEntries(val), config3, indentation, depth, refs2, printer22)}}`;
}
function printImmutableSeq(val, config3, indentation, depth, refs2, printer22) {
  let name2 = getImmutableName("Seq");
  return ++depth > config3.maxDepth ? printAsLeaf(name2) : val[IS_KEYED_SENTINEL] ? `${name2 + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config3, indentation, depth, refs2, printer22) : LAZY}}` : `${name2 + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config3, indentation, depth, refs2, printer22) : LAZY}]`;
}
function printImmutableValues(val, config3, indentation, depth, refs2, printer22, type5) {
  return ++depth > config3.maxDepth ? printAsLeaf(getImmutableName(type5)) : `${getImmutableName(type5) + SPACE}[${printIteratorValues(val.values(), config3, indentation, depth, refs2, printer22)}]`;
}
var serialize$2 = (val, config3, indentation, depth, refs2, printer22) => val[IS_MAP_SENTINEL] ? printImmutableEntries(val, config3, indentation, depth, refs2, printer22, val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map") : val[IS_LIST_SENTINEL] ? printImmutableValues(val, config3, indentation, depth, refs2, printer22, "List") : val[IS_SET_SENTINEL] ? printImmutableValues(val, config3, indentation, depth, refs2, printer22, val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set") : val[IS_STACK_SENTINEL] ? printImmutableValues(val, config3, indentation, depth, refs2, printer22, "Stack") : val[IS_SEQ_SENTINEL] ? printImmutableSeq(val, config3, indentation, depth, refs2, printer22) : printImmutableRecord(val, config3, indentation, depth, refs2, printer22);
var test$2 = (val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
var plugin$2 = { serialize: serialize$2, test: test$2 };
var reactIs = { exports: {} };
var reactIs_development = {};
var hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, function() {
    var REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), enableScopeAPI = false, enableCacheElement = false, enableTransitionTracing = false, enableLegacyHidden = false, enableDebugTracing = false, REACT_MODULE_REFERENCE;
    REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
    function isValidElementType(type5) {
      return !!(typeof type5 == "string" || typeof type5 == "function" || type5 === REACT_FRAGMENT_TYPE || type5 === REACT_PROFILER_TYPE || enableDebugTracing || type5 === REACT_STRICT_MODE_TYPE || type5 === REACT_SUSPENSE_TYPE || type5 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type5 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type5 == "object" && type5 !== null && (type5.$$typeof === REACT_LAZY_TYPE || type5.$$typeof === REACT_MEMO_TYPE || type5.$$typeof === REACT_PROVIDER_TYPE || type5.$$typeof === REACT_CONTEXT_TYPE || type5.$$typeof === REACT_FORWARD_REF_TYPE || type5.$$typeof === REACT_MODULE_REFERENCE || type5.getModuleId !== void 0));
    }
    function typeOf(object) {
      if (typeof object == "object" && object !== null) {
        var $$typeof = object.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type5 = object.type;
            switch (type5) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
                return type5;
              default:
                var $$typeofType = type5 && type5.$$typeof;
                switch ($$typeofType) {
                  case REACT_SERVER_CONTEXT_TYPE:
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    var ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo = REACT_MEMO_TYPE, Portal = REACT_PORTAL_TYPE, Profiler = REACT_PROFILER_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, Suspense = REACT_SUSPENSE_TYPE, SuspenseList = REACT_SUSPENSE_LIST_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = false, hasWarnedAboutDeprecatedIsConcurrentMode = false;
    function isAsyncMode(object) {
      return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), false;
    }
    function isConcurrentMode(object) {
      return hasWarnedAboutDeprecatedIsConcurrentMode || (hasWarnedAboutDeprecatedIsConcurrentMode = true, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), false;
    }
    function isContextConsumer(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    }
    function isContextProvider(object) {
      return typeOf(object) === REACT_PROVIDER_TYPE;
    }
    function isElement5(object) {
      return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function isForwardRef(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }
    function isFragment(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    }
    function isLazy(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    }
    function isMemo(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    }
    function isPortal(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    }
    function isProfiler(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    }
    function isStrictMode(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }
    function isSuspense(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    }
    function isSuspenseList(object) {
      return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
    }
    reactIs_development.ContextConsumer = ContextConsumer, reactIs_development.ContextProvider = ContextProvider, reactIs_development.Element = Element2, reactIs_development.ForwardRef = ForwardRef, reactIs_development.Fragment = Fragment, reactIs_development.Lazy = Lazy, reactIs_development.Memo = Memo, reactIs_development.Portal = Portal, reactIs_development.Profiler = Profiler, reactIs_development.StrictMode = StrictMode, reactIs_development.Suspense = Suspense, reactIs_development.SuspenseList = SuspenseList, reactIs_development.isAsyncMode = isAsyncMode, reactIs_development.isConcurrentMode = isConcurrentMode, reactIs_development.isContextConsumer = isContextConsumer, reactIs_development.isContextProvider = isContextProvider, reactIs_development.isElement = isElement5, reactIs_development.isForwardRef = isForwardRef, reactIs_development.isFragment = isFragment, reactIs_development.isLazy = isLazy, reactIs_development.isMemo = isMemo, reactIs_development.isPortal = isPortal, reactIs_development.isProfiler = isProfiler, reactIs_development.isStrictMode = isStrictMode, reactIs_development.isSuspense = isSuspense, reactIs_development.isSuspenseList = isSuspenseList, reactIs_development.isValidElementType = isValidElementType, reactIs_development.typeOf = typeOf;
  }()), reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, reactIs.exports = requireReactIs_development()), reactIs.exports;
}
var reactIsExports = requireReactIs();
function getChildren(arg, children = []) {
  if (Array.isArray(arg)) for (let item of arg) getChildren(item, children);
  else arg != null && arg !== false && arg !== "" && children.push(arg);
  return children;
}
function getType(element) {
  let type5 = element.type;
  if (typeof type5 == "string") return type5;
  if (typeof type5 == "function") return type5.displayName || type5.name || "Unknown";
  if (reactIsExports.isFragment(element)) return "React.Fragment";
  if (reactIsExports.isSuspense(element)) return "React.Suspense";
  if (typeof type5 == "object" && type5 !== null) {
    if (reactIsExports.isContextProvider(element)) return "Context.Provider";
    if (reactIsExports.isContextConsumer(element)) return "Context.Consumer";
    if (reactIsExports.isForwardRef(element)) {
      if (type5.displayName) return type5.displayName;
      let functionName = type5.render.displayName || type5.render.name || "";
      return functionName === "" ? "ForwardRef" : `ForwardRef(${functionName})`;
    }
    if (reactIsExports.isMemo(element)) {
      let functionName = type5.displayName || type5.type.displayName || type5.type.name || "";
      return functionName === "" ? "Memo" : `Memo(${functionName})`;
    }
  }
  return "UNDEFINED";
}
function getPropKeys$1(element) {
  let { props } = element;
  return Object.keys(props).filter((key2) => key2 !== "children" && props[key2] !== void 0).sort();
}
var serialize$1 = (element, config3, indentation, depth, refs2, printer22) => ++depth > config3.maxDepth ? printElementAsLeaf(getType(element), config3) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config3, indentation + config3.indent, depth, refs2, printer22), printChildren(getChildren(element.props.children), config3, indentation + config3.indent, depth, refs2, printer22), config3, indentation);
var test$1 = (val) => val != null && reactIsExports.isElement(val);
var plugin$1 = { serialize: serialize$1, test: test$1 };
var testSymbol = typeof Symbol == "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function getPropKeys(object) {
  let { props } = object;
  return props ? Object.keys(props).filter((key2) => props[key2] !== void 0).sort() : [];
}
var serialize = (object, config3, indentation, depth, refs2, printer22) => ++depth > config3.maxDepth ? printElementAsLeaf(object.type, config3) : printElement(object.type, object.props ? printProps(getPropKeys(object), object.props, config3, indentation + config3.indent, depth, refs2, printer22) : "", object.children ? printChildren(object.children, config3, indentation + config3.indent, depth, refs2, printer22) : "", config3, indentation);
var test = (val) => val && val.$$typeof === testSymbol;
var plugin = { serialize, test };
var toString = Object.prototype.toString;
var toISOString = Date.prototype.toISOString;
var errorToString = Error.prototype.toString;
var regExpToString = RegExp.prototype.toString;
function getConstructorName(val) {
  return typeof val.constructor == "function" && val.constructor.name || "Object";
}
function isWindow(val) {
  return typeof window < "u" && val === window;
}
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
var NEWLINE_REGEXP = /\n/g;
var PrettyFormatPluginError = class extends Error {
  constructor(message, stack) {
    super(message), this.stack = stack, this.name = this.constructor.name;
  }
};
function isToStringedArrayType(toStringed) {
  return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
}
function printNumber(val) {
  return Object.is(val, -0) ? "-0" : String(val);
}
function printBigInt(val) {
  return `${val}n`;
}
function printFunction(val, printFunctionName) {
  return printFunctionName ? `[Function ${val.name || "anonymous"}]` : "[Function]";
}
function printSymbol(val) {
  return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
}
function printError(val) {
  return `[${errorToString.call(val)}]`;
}
function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
  if (val === true || val === false) return `${val}`;
  if (val === void 0) return "undefined";
  if (val === null) return "null";
  let typeOf = typeof val;
  if (typeOf === "number") return printNumber(val);
  if (typeOf === "bigint") return printBigInt(val);
  if (typeOf === "string") return escapeString ? `"${val.replaceAll(/"|\\/g, "\\$&")}"` : `"${val}"`;
  if (typeOf === "function") return printFunction(val, printFunctionName);
  if (typeOf === "symbol") return printSymbol(val);
  let toStringed = toString.call(val);
  return toStringed === "[object WeakMap]" ? "WeakMap {}" : toStringed === "[object WeakSet]" ? "WeakSet {}" : toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]" ? printFunction(val, printFunctionName) : toStringed === "[object Symbol]" ? printSymbol(val) : toStringed === "[object Date]" ? Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val) : toStringed === "[object Error]" ? printError(val) : toStringed === "[object RegExp]" ? escapeRegex ? regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&") : regExpToString.call(val) : val instanceof Error ? printError(val) : null;
}
function printComplexValue(val, config3, indentation, depth, refs2, hasCalledToJSON) {
  if (refs2.includes(val)) return "[Circular]";
  refs2 = [...refs2], refs2.push(val);
  let hitMaxDepth = ++depth > config3.maxDepth, min = config3.min;
  if (config3.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON == "function" && !hasCalledToJSON) return printer(val.toJSON(), config3, indentation, depth, refs2, true);
  let toStringed = toString.call(val);
  return toStringed === "[object Arguments]" ? hitMaxDepth ? "[Arguments]" : `${min ? "" : "Arguments "}[${printListItems(val, config3, indentation, depth, refs2, printer)}]` : isToStringedArrayType(toStringed) ? hitMaxDepth ? `[${val.constructor.name}]` : `${min || !config3.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${printListItems(val, config3, indentation, depth, refs2, printer)}]` : toStringed === "[object Map]" ? hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries(val.entries(), config3, indentation, depth, refs2, printer, " => ")}}` : toStringed === "[object Set]" ? hitMaxDepth ? "[Set]" : `Set {${printIteratorValues(val.values(), config3, indentation, depth, refs2, printer)}}` : hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min || !config3.printBasicPrototype && getConstructorName(val) === "Object" ? "" : `${getConstructorName(val)} `}{${printObjectProperties(val, config3, indentation, depth, refs2, printer)}}`;
}
function isNewPlugin(plugin22) {
  return plugin22.serialize != null;
}
function printPlugin(plugin22, val, config3, indentation, depth, refs2) {
  let printed;
  try {
    printed = isNewPlugin(plugin22) ? plugin22.serialize(val, config3, indentation, depth, refs2, printer) : plugin22.print(val, (valChild) => printer(valChild, config3, indentation, depth, refs2), (str) => {
      let indentationNext = indentation + config3.indent;
      return indentationNext + str.replaceAll(NEWLINE_REGEXP, `
${indentationNext}`);
    }, { edgeSpacing: config3.spacingOuter, min: config3.min, spacing: config3.spacingInner }, config3.colors);
  } catch (error) {
    throw new PrettyFormatPluginError(error.message, error.stack);
  }
  if (typeof printed != "string") throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
  return printed;
}
function findPlugin(plugins22, val) {
  for (let plugin22 of plugins22) try {
    if (plugin22.test(val)) return plugin22;
  } catch (error) {
    throw new PrettyFormatPluginError(error.message, error.stack);
  }
  return null;
}
function printer(val, config3, indentation, depth, refs2, hasCalledToJSON) {
  let plugin22 = findPlugin(config3.plugins, val);
  if (plugin22 !== null) return printPlugin(plugin22, val, config3, indentation, depth, refs2);
  let basicResult = printBasicValue(val, config3.printFunctionName, config3.escapeRegex, config3.escapeString);
  return basicResult !== null ? basicResult : printComplexValue(val, config3, indentation, depth, refs2, hasCalledToJSON);
}
var DEFAULT_THEME = { comment: "gray", content: "reset", prop: "yellow", tag: "cyan", value: "green" };
var DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
var DEFAULT_OPTIONS = { callToJSON: true, compareKeys: void 0, escapeRegex: false, escapeString: true, highlight: false, indent: 2, maxDepth: Number.POSITIVE_INFINITY, maxWidth: Number.POSITIVE_INFINITY, min: false, plugins: [], printBasicPrototype: true, printFunctionName: true, theme: DEFAULT_THEME };
function validateOptions(options2) {
  for (let key2 of Object.keys(options2)) if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key2)) throw new Error(`pretty-format: Unknown option "${key2}".`);
  if (options2.min && options2.indent !== void 0 && options2.indent !== 0) throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
function getColorsHighlight() {
  return DEFAULT_THEME_KEYS.reduce((colors, key2) => {
    let value2 = DEFAULT_THEME[key2], color = value2 && f22[value2];
    if (color && typeof color.close == "string" && typeof color.open == "string") colors[key2] = color;
    else throw new Error(`pretty-format: Option "theme" has a key "${key2}" whose value "${value2}" is undefined in ansi-styles.`);
    return colors;
  }, /* @__PURE__ */ Object.create(null));
}
function getColorsEmpty() {
  return DEFAULT_THEME_KEYS.reduce((colors, key2) => (colors[key2] = { close: "", open: "" }, colors), /* @__PURE__ */ Object.create(null));
}
function getPrintFunctionName(options2) {
  return (options2 == null ? void 0 : options2.printFunctionName) ?? DEFAULT_OPTIONS.printFunctionName;
}
function getEscapeRegex(options2) {
  return (options2 == null ? void 0 : options2.escapeRegex) ?? DEFAULT_OPTIONS.escapeRegex;
}
function getEscapeString(options2) {
  return (options2 == null ? void 0 : options2.escapeString) ?? DEFAULT_OPTIONS.escapeString;
}
function getConfig(options2) {
  return { callToJSON: (options2 == null ? void 0 : options2.callToJSON) ?? DEFAULT_OPTIONS.callToJSON, colors: (options2 == null ? void 0 : options2.highlight) ? getColorsHighlight() : getColorsEmpty(), compareKeys: typeof (options2 == null ? void 0 : options2.compareKeys) == "function" || (options2 == null ? void 0 : options2.compareKeys) === null ? options2.compareKeys : DEFAULT_OPTIONS.compareKeys, escapeRegex: getEscapeRegex(options2), escapeString: getEscapeString(options2), indent: (options2 == null ? void 0 : options2.min) ? "" : createIndent((options2 == null ? void 0 : options2.indent) ?? DEFAULT_OPTIONS.indent), maxDepth: (options2 == null ? void 0 : options2.maxDepth) ?? DEFAULT_OPTIONS.maxDepth, maxWidth: (options2 == null ? void 0 : options2.maxWidth) ?? DEFAULT_OPTIONS.maxWidth, min: (options2 == null ? void 0 : options2.min) ?? DEFAULT_OPTIONS.min, plugins: (options2 == null ? void 0 : options2.plugins) ?? DEFAULT_OPTIONS.plugins, printBasicPrototype: (options2 == null ? void 0 : options2.printBasicPrototype) ?? true, printFunctionName: getPrintFunctionName(options2), spacingInner: (options2 == null ? void 0 : options2.min) ? " " : `
`, spacingOuter: (options2 == null ? void 0 : options2.min) ? "" : `
` };
}
function createIndent(indent) {
  return Array.from({ length: indent + 1 }).join(" ");
}
function format(val, options2) {
  if (options2 && (validateOptions(options2), options2.plugins)) {
    let plugin22 = findPlugin(options2.plugins, val);
    if (plugin22 !== null) return printPlugin(plugin22, val, getConfig(options2), "", 0, []);
  }
  let basicResult = printBasicValue(val, getPrintFunctionName(options2), getEscapeRegex(options2), getEscapeString(options2));
  return basicResult !== null ? basicResult : printComplexValue(val, getConfig(options2), "", 0, []);
}
var plugins = { AsymmetricMatcher: plugin$5, DOMCollection: plugin$4, DOMElement: plugin$3, Immutable: plugin$2, ReactElement: plugin$1, ReactTestComponent: plugin };
var ansiColors = { bold: ["1", "22"], dim: ["2", "22"], italic: ["3", "23"], underline: ["4", "24"], inverse: ["7", "27"], hidden: ["8", "28"], strike: ["9", "29"], black: ["30", "39"], red: ["31", "39"], green: ["32", "39"], yellow: ["33", "39"], blue: ["34", "39"], magenta: ["35", "39"], cyan: ["36", "39"], white: ["37", "39"], brightblack: ["30;1", "39"], brightred: ["31;1", "39"], brightgreen: ["32;1", "39"], brightyellow: ["33;1", "39"], brightblue: ["34;1", "39"], brightmagenta: ["35;1", "39"], brightcyan: ["36;1", "39"], brightwhite: ["37;1", "39"], grey: ["90", "39"] };
var styles = { special: "cyan", number: "yellow", bigint: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", symbol: "green", date: "magenta", regexp: "red" };
var truncator = "";
function colorise(value2, styleType) {
  let color = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
  return color ? `\x1B[${color[0]}m${String(value2)}\x1B[${color[1]}m` : String(value2);
}
function normaliseOptions({ showHidden = false, depth = 2, colors = false, customInspect = true, showProxy = false, maxArrayLength = 1 / 0, breakLength = 1 / 0, seen = [], truncate: truncate23 = 1 / 0, stylize = String } = {}, inspect33) {
  let options2 = { showHidden: !!showHidden, depth: Number(depth), colors: !!colors, customInspect: !!customInspect, showProxy: !!showProxy, maxArrayLength: Number(maxArrayLength), breakLength: Number(breakLength), truncate: Number(truncate23), seen, inspect: inspect33, stylize };
  return options2.colors && (options2.stylize = colorise), options2;
}
function isHighSurrogate(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
function truncate(string, length, tail = truncator) {
  string = String(string);
  let tailLength = tail.length, stringLength = string.length;
  if (tailLength > length && stringLength > tailLength) return tail;
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    return end > 0 && isHighSurrogate(string[end - 1]) && (end = end - 1), `${string.slice(0, end)}${tail}`;
  }
  return string;
}
function inspectList(list, options2, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options2.inspect;
  let size = list.length;
  if (size === 0) return "";
  let originalLength = options2.truncate, output = "", peek = "", truncated = "";
  for (let i4 = 0; i4 < size; i4 += 1) {
    let last = i4 + 1 === list.length, secondToLast = i4 + 2 === list.length;
    truncated = `${truncator}(${list.length - i4})`;
    let value2 = list[i4];
    options2.truncate = originalLength - output.length - (last ? 0 : separator.length);
    let string = peek || inspectItem(value2, options2) + (last ? "" : separator), nextLength = output.length + string.length, truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength || !last && !secondToLast && truncatedLength > originalLength || (peek = last ? "" : inspectItem(list[i4 + 1], options2) + (secondToLast ? "" : separator), !last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength)) break;
    if (output += string, !last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator}(${list.length - i4 - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
function quoteComplexKey(key2) {
  return key2.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? key2 : JSON.stringify(key2).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
function inspectProperty([key2, value2], options2) {
  return options2.truncate -= 2, typeof key2 == "string" ? key2 = quoteComplexKey(key2) : typeof key2 != "number" && (key2 = `[${options2.inspect(key2, options2)}]`), options2.truncate -= key2.length, value2 = options2.inspect(value2, options2), `${key2}: ${value2}`;
}
function inspectArray(array, options2) {
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length) return "[]";
  options2.truncate -= 4;
  let listContents = inspectList(array, options2);
  options2.truncate -= listContents.length;
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key2) => [key2, array[key2]]), options2, inspectProperty)), `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
var getArrayName = (array) => typeof Buffer == "function" && array instanceof Buffer ? "Buffer" : array[Symbol.toStringTag] ? array[Symbol.toStringTag] : array.constructor.name;
function inspectTypedArray(array, options2) {
  let name2 = getArrayName(array);
  options2.truncate -= name2.length + 4;
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length) return `${name2}[]`;
  let output = "";
  for (let i4 = 0; i4 < array.length; i4++) {
    let string = `${options2.stylize(truncate(array[i4], options2.truncate), "number")}${i4 === array.length - 1 ? "" : ", "}`;
    if (options2.truncate -= string.length, array[i4] !== array.length && options2.truncate <= 3) {
      output += `${truncator}(${array.length - array[i4] + 1})`;
      break;
    }
    output += string;
  }
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key2) => [key2, array[key2]]), options2, inspectProperty)), `${name2}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
function inspectDate(dateObject, options2) {
  let stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null) return "Invalid Date";
  let split = stringRepresentation.split("T"), date = split[0];
  return options2.stylize(`${date}T${truncate(split[1], options2.truncate - date.length - 1)}`, "date");
}
function inspectFunction(func, options2) {
  let functionType = func[Symbol.toStringTag] || "Function", name2 = func.name;
  return name2 ? options2.stylize(`[${functionType} ${truncate(name2, options2.truncate - 11)}]`, "special") : options2.stylize(`[${functionType}]`, "special");
}
function inspectMapEntry([key2, value2], options2) {
  return options2.truncate -= 4, key2 = options2.inspect(key2, options2), options2.truncate -= key2.length, value2 = options2.inspect(value2, options2), `${key2} => ${value2}`;
}
function mapToEntries(map) {
  let entries = [];
  return map.forEach((value2, key2) => {
    entries.push([key2, value2]);
  }), entries;
}
function inspectMap(map, options2) {
  return map.size - 1 <= 0 ? "Map{}" : (options2.truncate -= 7, `Map{ ${inspectList(mapToEntries(map), options2, inspectMapEntry)} }`);
}
var isNaN2 = Number.isNaN || ((i4) => i4 !== i4);
function inspectNumber(number, options2) {
  return isNaN2(number) ? options2.stylize("NaN", "number") : number === 1 / 0 ? options2.stylize("Infinity", "number") : number === -1 / 0 ? options2.stylize("-Infinity", "number") : number === 0 ? options2.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number") : options2.stylize(truncate(String(number), options2.truncate), "number");
}
function inspectBigInt(number, options2) {
  let nums = truncate(number.toString(), options2.truncate - 1);
  return nums !== truncator && (nums += "n"), options2.stylize(nums, "bigint");
}
function inspectRegExp(value2, options2) {
  let flags = value2.toString().split("/")[2], sourceLength = options2.truncate - (2 + flags.length), source2 = value2.source;
  return options2.stylize(`/${truncate(source2, sourceLength)}/${flags}`, "regexp");
}
function arrayFromSet(set) {
  let values = [];
  return set.forEach((value2) => {
    values.push(value2);
  }), values;
}
function inspectSet(set, options2) {
  return set.size === 0 ? "Set{}" : (options2.truncate -= 7, `Set{ ${inspectList(arrayFromSet(set), options2)} }`);
}
var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var escapeCharacters = { "\b": "\\b", "	": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", "'": "\\'", "\\": "\\\\" };
var hex = 16;
var unicodeLength = 4;
function escape(char) {
  return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
}
function inspectString(string, options2) {
  return stringEscapeChars.test(string) && (string = string.replace(stringEscapeChars, escape)), options2.stylize(`'${truncate(string, options2.truncate - 2)}'`, "string");
}
function inspectSymbol(value2) {
  return "description" in Symbol.prototype ? value2.description ? `Symbol(${value2.description})` : "Symbol()" : value2.toString();
}
var getPromiseValue = () => "Promise{}";
try {
  let { getPromiseDetails, kPending, kRejected } = process.binding("util");
  Array.isArray(getPromiseDetails(Promise.resolve())) && (getPromiseValue = (value2, options2) => {
    let [state, innerValue] = getPromiseDetails(value2);
    return state === kPending ? "Promise{<pending>}" : `Promise${state === kRejected ? "!" : ""}{${options2.inspect(innerValue, options2)}}`;
  });
} catch {
}
var promise_default = getPromiseValue;
function inspectObject(object, options2) {
  let properties = Object.getOwnPropertyNames(object), symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
  if (properties.length === 0 && symbols.length === 0) return "{}";
  if (options2.truncate -= 4, options2.seen = options2.seen || [], options2.seen.indexOf(object) >= 0) return "[Circular]";
  options2.seen.push(object);
  let propertyContents = inspectList(properties.map((key2) => [key2, object[key2]]), options2, inspectProperty), symbolContents = inspectList(symbols.map((key2) => [key2, object[key2]]), options2, inspectProperty);
  options2.seen.pop();
  let sep = "";
  return propertyContents && symbolContents && (sep = ", "), `{ ${propertyContents}${sep}${symbolContents} }`;
}
var toStringTag = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass(value2, options2) {
  let name2 = "";
  return toStringTag && toStringTag in value2 && (name2 = value2[toStringTag]), name2 = name2 || value2.constructor.name, (!name2 || name2 === "_class") && (name2 = "<Anonymous Class>"), options2.truncate -= name2.length, `${name2}${inspectObject(value2, options2)}`;
}
function inspectArguments(args2, options2) {
  return args2.length === 0 ? "Arguments[]" : (options2.truncate -= 13, `Arguments[ ${inspectList(args2, options2)} ]`);
}
var errorKeys = ["stack", "line", "column", "name", "message", "fileName", "lineNumber", "columnNumber", "number", "description"];
function inspectObject2(error, options2) {
  let properties = Object.getOwnPropertyNames(error).filter((key2) => errorKeys.indexOf(key2) === -1), name2 = error.name;
  options2.truncate -= name2.length;
  let message = "";
  typeof error.message == "string" ? message = truncate(error.message, options2.truncate) : properties.unshift("message"), message = message ? `: ${message}` : "", options2.truncate -= message.length + 5;
  let propertyContents = inspectList(properties.map((key2) => [key2, error[key2]]), options2, inspectProperty);
  return `${name2}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
function inspectAttribute([key2, value2], options2) {
  return options2.truncate -= 3, value2 ? `${options2.stylize(String(key2), "yellow")}=${options2.stylize(`"${value2}"`, "string")}` : `${options2.stylize(String(key2), "yellow")}`;
}
function inspectHTMLCollection(collection, options2) {
  return inspectList(collection, options2, inspectHTML, `
`);
}
function inspectHTML(element, options2) {
  let properties = element.getAttributeNames(), name2 = element.tagName.toLowerCase(), head = options2.stylize(`<${name2}`, "special"), headClose = options2.stylize(">", "special"), tail = options2.stylize(`</${name2}>`, "special");
  options2.truncate -= name2.length * 2 + 5;
  let propertyContents = "";
  properties.length > 0 && (propertyContents += " ", propertyContents += inspectList(properties.map((key2) => [key2, element.getAttribute(key2)]), options2, inspectAttribute, " ")), options2.truncate -= propertyContents.length;
  let truncate23 = options2.truncate, children = inspectHTMLCollection(element.children, options2);
  return children && children.length > truncate23 && (children = `${truncator}(${element.children.length})`), `${head}${propertyContents}${headClose}${children}${tail}`;
}
var symbolsSupported = typeof Symbol == "function" && typeof Symbol.for == "function";
var chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect";
var nodeInspect = false;
try {
  let nodeUtil = __require2("util");
  nodeInspect = nodeUtil.inspect ? nodeUtil.inspect.custom : false;
} catch {
  nodeInspect = false;
}
var constructorMap = /* @__PURE__ */ new WeakMap();
var stringTagMap = {};
var baseTypesMap = { undefined: (value2, options2) => options2.stylize("undefined", "undefined"), null: (value2, options2) => options2.stylize("null", "null"), boolean: (value2, options2) => options2.stylize(String(value2), "boolean"), Boolean: (value2, options2) => options2.stylize(String(value2), "boolean"), number: inspectNumber, Number: inspectNumber, bigint: inspectBigInt, BigInt: inspectBigInt, string: inspectString, String: inspectString, function: inspectFunction, Function: inspectFunction, symbol: inspectSymbol, Symbol: inspectSymbol, Array: inspectArray, Date: inspectDate, Map: inspectMap, Set: inspectSet, RegExp: inspectRegExp, Promise: promise_default, WeakSet: (value2, options2) => options2.stylize("WeakSet{}", "special"), WeakMap: (value2, options2) => options2.stylize("WeakMap{}", "special"), Arguments: inspectArguments, Int8Array: inspectTypedArray, Uint8Array: inspectTypedArray, Uint8ClampedArray: inspectTypedArray, Int16Array: inspectTypedArray, Uint16Array: inspectTypedArray, Int32Array: inspectTypedArray, Uint32Array: inspectTypedArray, Float32Array: inspectTypedArray, Float64Array: inspectTypedArray, Generator: () => "", DataView: () => "", ArrayBuffer: () => "", Error: inspectObject2, HTMLCollection: inspectHTMLCollection, NodeList: inspectHTMLCollection };
var inspectCustom = (value2, options2, type5) => chaiInspect in value2 && typeof value2[chaiInspect] == "function" ? value2[chaiInspect](options2) : nodeInspect && nodeInspect in value2 && typeof value2[nodeInspect] == "function" ? value2[nodeInspect](options2.depth, options2) : "inspect" in value2 && typeof value2.inspect == "function" ? value2.inspect(options2.depth, options2) : "constructor" in value2 && constructorMap.has(value2.constructor) ? constructorMap.get(value2.constructor)(value2, options2) : stringTagMap[type5] ? stringTagMap[type5](value2, options2) : "";
var toString2 = Object.prototype.toString;
function inspect(value2, opts = {}) {
  let options2 = normaliseOptions(opts, inspect), { customInspect } = options2, type5 = value2 === null ? "null" : typeof value2;
  if (type5 === "object" && (type5 = toString2.call(value2).slice(8, -1)), type5 in baseTypesMap) return baseTypesMap[type5](value2, options2);
  if (customInspect && value2) {
    let output = inspectCustom(value2, options2, type5);
    if (output) return typeof output == "string" ? output : inspect(output, options2);
  }
  let proto = value2 ? Object.getPrototypeOf(value2) : false;
  return proto === Object.prototype || proto === null ? inspectObject(value2, options2) : value2 && typeof HTMLElement == "function" && value2 instanceof HTMLElement ? inspectHTML(value2, options2) : "constructor" in value2 ? value2.constructor !== Object ? inspectClass(value2, options2) : inspectObject(value2, options2) : value2 === Object(value2) ? inspectObject(value2, options2) : options2.stylize(String(value2), type5);
}
var { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins;
var PLUGINS = [ReactTestComponent, ReactElement, DOMElement, DOMCollection, Immutable, AsymmetricMatcher];
function stringify(object, maxDepth = 10, { maxLength, ...options2 } = {}) {
  let MAX_LENGTH = maxLength ?? 1e4, result2;
  try {
    result2 = format(object, { maxDepth, escapeString: false, plugins: PLUGINS, ...options2 });
  } catch {
    result2 = format(object, { callToJSON: false, maxDepth, escapeString: false, plugins: PLUGINS, ...options2 });
  }
  return result2.length >= MAX_LENGTH && maxDepth > 1 ? stringify(object, Math.floor(maxDepth / 2)) : result2;
}
var formatRegExp = /%[sdjifoOc%]/g;
function format2(...args2) {
  if (typeof args2[0] != "string") {
    let objects = [];
    for (let i22 = 0; i22 < args2.length; i22++) objects.push(inspect2(args2[i22], { depth: 0, colors: false }));
    return objects.join(" ");
  }
  let len = args2.length, i4 = 1, template = args2[0], str = String(template).replace(formatRegExp, (x7) => {
    if (x7 === "%%") return "%";
    if (i4 >= len) return x7;
    switch (x7) {
      case "%s": {
        let value2 = args2[i4++];
        return typeof value2 == "bigint" ? `${value2.toString()}n` : typeof value2 == "number" && value2 === 0 && 1 / value2 < 0 ? "-0" : typeof value2 == "object" && value2 !== null ? inspect2(value2, { depth: 0, colors: false }) : String(value2);
      }
      case "%d": {
        let value2 = args2[i4++];
        return typeof value2 == "bigint" ? `${value2.toString()}n` : Number(value2).toString();
      }
      case "%i": {
        let value2 = args2[i4++];
        return typeof value2 == "bigint" ? `${value2.toString()}n` : Number.parseInt(String(value2)).toString();
      }
      case "%f":
        return Number.parseFloat(String(args2[i4++])).toString();
      case "%o":
        return inspect2(args2[i4++], { showHidden: true, showProxy: true });
      case "%O":
        return inspect2(args2[i4++]);
      case "%c":
        return i4++, "";
      case "%j":
        try {
          return JSON.stringify(args2[i4++]);
        } catch (err) {
          let m22 = err.message;
          if (m22.includes("circular structure") || m22.includes("cyclic structures") || m22.includes("cyclic object")) return "[Circular]";
          throw err;
        }
      default:
        return x7;
    }
  });
  for (let x7 = args2[i4]; i4 < len; x7 = args2[++i4]) x7 === null || typeof x7 != "object" ? str += ` ${x7}` : str += ` ${inspect2(x7)}`;
  return str;
}
function inspect2(obj, options2 = {}) {
  return options2.truncate === 0 && (options2.truncate = Number.POSITIVE_INFINITY), inspect(obj, options2);
}
function getDefaultExportFromCjs(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7.default : x7;
}
function isFinalObj(obj) {
  return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
}
function getType2(value2) {
  return Object.prototype.toString.apply(value2).slice(8, -1);
}
function collectOwnProperties(obj, collector) {
  let collect = typeof collector == "function" ? collector : (key2) => collector.add(key2);
  Object.getOwnPropertyNames(obj).forEach(collect), Object.getOwnPropertySymbols(obj).forEach(collect);
}
function getOwnProperties(obj) {
  let ownProps = /* @__PURE__ */ new Set();
  return isFinalObj(obj) ? [] : (collectOwnProperties(obj, ownProps), Array.from(ownProps));
}
var defaultCloneOptions = { forceWritable: false };
function deepClone(val, options2 = defaultCloneOptions) {
  return clone(val, /* @__PURE__ */ new WeakMap(), options2);
}
function clone(val, seen, options2 = defaultCloneOptions) {
  let k8, out;
  if (seen.has(val)) return seen.get(val);
  if (Array.isArray(val)) {
    for (out = Array.from({ length: k8 = val.length }), seen.set(val, out); k8--; ) out[k8] = clone(val[k8], seen, options2);
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = Object.create(Object.getPrototypeOf(val)), seen.set(val, out);
    let props = getOwnProperties(val);
    for (let k22 of props) {
      let descriptor = Object.getOwnPropertyDescriptor(val, k22);
      if (!descriptor) continue;
      let cloned = clone(val[k22], seen, options2);
      options2.forceWritable ? Object.defineProperty(out, k22, { enumerable: descriptor.enumerable, configurable: true, writable: true, value: cloned }) : "get" in descriptor ? Object.defineProperty(out, k22, { ...descriptor, get() {
        return cloned;
      } }) : Object.defineProperty(out, k22, { ...descriptor, value: cloned });
    }
    return out;
  }
  return val;
}
function getType3(value2) {
  if (value2 === void 0) return "undefined";
  if (value2 === null) return "null";
  if (Array.isArray(value2)) return "array";
  if (typeof value2 == "boolean") return "boolean";
  if (typeof value2 == "function") return "function";
  if (typeof value2 == "number") return "number";
  if (typeof value2 == "string") return "string";
  if (typeof value2 == "bigint") return "bigint";
  if (typeof value2 == "object") {
    if (value2 != null) {
      if (value2.constructor === RegExp) return "regexp";
      if (value2.constructor === Map) return "map";
      if (value2.constructor === Set) return "set";
      if (value2.constructor === Date) return "date";
    }
    return "object";
  } else if (typeof value2 == "symbol") return "symbol";
  throw new Error(`value of unknown type: ${value2}`);
}
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
var Diff = class {
  constructor(op, text) {
    __publicField(this, 0);
    __publicField(this, 1);
    this[0] = op, this[1] = text;
  }
};
var diff_commonPrefix = function(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) return 0;
  let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerstart = 0;
  for (; pointermin < pointermid; ) text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid) ? (pointermin = pointermid, pointerstart = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  return pointermid;
};
var diff_commonSuffix = function(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) return 0;
  let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerend = 0;
  for (; pointermin < pointermid; ) text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend) ? (pointermin = pointermid, pointerend = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  return pointermid;
};
var diff_commonOverlap_ = function(text1, text2) {
  let text1_length = text1.length, text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0) return 0;
  text1_length > text2_length ? text1 = text1.substring(text1_length - text2_length) : text1_length < text2_length && (text2 = text2.substring(0, text1_length));
  let text_length = Math.min(text1_length, text2_length);
  if (text1 === text2) return text_length;
  let best = 0, length = 1;
  for (; ; ) {
    let pattern = text1.substring(text_length - length), found = text2.indexOf(pattern);
    if (found === -1) return best;
    length += found, (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) && (best = length, length++);
  }
};
var diff_cleanupSemantic = function(diffs) {
  let changes = false, equalities = [], equalitiesLength = 0, lastEquality = null, pointer3 = 0, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0;
  for (; pointer3 < diffs.length; ) diffs[pointer3][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer3, length_insertions1 = length_insertions2, length_deletions1 = length_deletions2, length_insertions2 = 0, length_deletions2 = 0, lastEquality = diffs[pointer3][1]) : (diffs[pointer3][0] === DIFF_INSERT ? length_insertions2 += diffs[pointer3][1].length : length_deletions2 += diffs[pointer3][1].length, lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality)), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer3 = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0, lastEquality = null, changes = true)), pointer3++;
  for (changes && diff_cleanupMerge(diffs), diff_cleanupSemanticLossless(diffs), pointer3 = 1; pointer3 < diffs.length; ) {
    if (diffs[pointer3 - 1][0] === DIFF_DELETE && diffs[pointer3][0] === DIFF_INSERT) {
      let deletion = diffs[pointer3 - 1][1], insertion = diffs[pointer3][1], overlap_length1 = diff_commonOverlap_(deletion, insertion), overlap_length2 = diff_commonOverlap_(insertion, deletion);
      overlap_length1 >= overlap_length2 ? (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) && (diffs.splice(pointer3, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))), diffs[pointer3 - 1][1] = deletion.substring(0, deletion.length - overlap_length1), diffs[pointer3 + 1][1] = insertion.substring(overlap_length1), pointer3++) : (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) && (diffs.splice(pointer3, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))), diffs[pointer3 - 1][0] = DIFF_INSERT, diffs[pointer3 - 1][1] = insertion.substring(0, insertion.length - overlap_length2), diffs[pointer3 + 1][0] = DIFF_DELETE, diffs[pointer3 + 1][1] = deletion.substring(overlap_length2), pointer3++), pointer3++;
    }
    pointer3++;
  }
};
var nonAlphaNumericRegex_ = /[^a-z0-9]/i;
var whitespaceRegex_ = /\s/;
var linebreakRegex_ = /[\r\n]/;
var blanklineEndRegex_ = /\n\r?\n$/;
var blanklineStartRegex_ = /^\r?\n\r?\n/;
function diff_cleanupSemanticLossless(diffs) {
  let pointer3 = 1;
  for (; pointer3 < diffs.length - 1; ) {
    if (diffs[pointer3 - 1][0] === DIFF_EQUAL && diffs[pointer3 + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer3 - 1][1], edit = diffs[pointer3][1], equality2 = diffs[pointer3 + 1][1], commonOffset = diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        let commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
      for (; edit.charAt(0) === equality2.charAt(0); ) {
        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
        let score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
      }
      diffs[pointer3 - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer3 - 1][1] = bestEquality1 : (diffs.splice(pointer3 - 1, 1), pointer3--), diffs[pointer3][1] = bestEdit, bestEquality2 ? diffs[pointer3 + 1][1] = bestEquality2 : (diffs.splice(pointer3 + 1, 1), pointer3--));
    }
    pointer3++;
  }
}
function diff_cleanupMerge(diffs) {
  diffs.push(new Diff(DIFF_EQUAL, ""));
  let pointer3 = 0, count_delete = 0, count_insert = 0, text_delete = "", text_insert = "", commonlength;
  for (; pointer3 < diffs.length; ) switch (diffs[pointer3][0]) {
    case DIFF_INSERT:
      count_insert++, text_insert += diffs[pointer3][1], pointer3++;
      break;
    case DIFF_DELETE:
      count_delete++, text_delete += diffs[pointer3][1], pointer3++;
      break;
    case DIFF_EQUAL:
      count_delete + count_insert > 1 ? (count_delete !== 0 && count_insert !== 0 && (commonlength = diff_commonPrefix(text_insert, text_delete), commonlength !== 0 && (pointer3 - count_delete - count_insert > 0 && diffs[pointer3 - count_delete - count_insert - 1][0] === DIFF_EQUAL ? diffs[pointer3 - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength) : (diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength))), pointer3++), text_insert = text_insert.substring(commonlength), text_delete = text_delete.substring(commonlength)), commonlength = diff_commonSuffix(text_insert, text_delete), commonlength !== 0 && (diffs[pointer3][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer3][1], text_insert = text_insert.substring(0, text_insert.length - commonlength), text_delete = text_delete.substring(0, text_delete.length - commonlength))), pointer3 -= count_delete + count_insert, diffs.splice(pointer3, count_delete + count_insert), text_delete.length && (diffs.splice(pointer3, 0, new Diff(DIFF_DELETE, text_delete)), pointer3++), text_insert.length && (diffs.splice(pointer3, 0, new Diff(DIFF_INSERT, text_insert)), pointer3++), pointer3++) : pointer3 !== 0 && diffs[pointer3 - 1][0] === DIFF_EQUAL ? (diffs[pointer3 - 1][1] += diffs[pointer3][1], diffs.splice(pointer3, 1)) : pointer3++, count_insert = 0, count_delete = 0, text_delete = "", text_insert = "";
      break;
  }
  diffs[diffs.length - 1][1] === "" && diffs.pop();
  let changes = false;
  for (pointer3 = 1; pointer3 < diffs.length - 1; ) diffs[pointer3 - 1][0] === DIFF_EQUAL && diffs[pointer3 + 1][0] === DIFF_EQUAL && (diffs[pointer3][1].substring(diffs[pointer3][1].length - diffs[pointer3 - 1][1].length) === diffs[pointer3 - 1][1] ? (diffs[pointer3][1] = diffs[pointer3 - 1][1] + diffs[pointer3][1].substring(0, diffs[pointer3][1].length - diffs[pointer3 - 1][1].length), diffs[pointer3 + 1][1] = diffs[pointer3 - 1][1] + diffs[pointer3 + 1][1], diffs.splice(pointer3 - 1, 1), changes = true) : diffs[pointer3][1].substring(0, diffs[pointer3 + 1][1].length) === diffs[pointer3 + 1][1] && (diffs[pointer3 - 1][1] += diffs[pointer3 + 1][1], diffs[pointer3][1] = diffs[pointer3][1].substring(diffs[pointer3 + 1][1].length) + diffs[pointer3 + 1][1], diffs.splice(pointer3 + 1, 1), changes = true)), pointer3++;
  changes && diff_cleanupMerge(diffs);
}
function diff_cleanupSemanticScore_(one, two) {
  if (!one || !two) return 6;
  let char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_), lineBreak1 = whitespace1 && char1.match(linebreakRegex_), lineBreak2 = whitespace2 && char2.match(linebreakRegex_), blankLine1 = lineBreak1 && one.match(blanklineEndRegex_), blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
  return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
}
var NO_DIFF_MESSAGE = "Compared values have no visual difference.";
var SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.";
var build = {};
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1, Object.defineProperty(build, "__esModule", { value: true }), build.default = diffSequence2;
  let pkg2 = "diff-sequences", NOT_YET_SET2 = 0, countCommonItemsF2 = (aIndex, aEnd, bIndex, bEnd, isCommon) => {
    let nCommon = 0;
    for (; aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex); ) aIndex += 1, bIndex += 1, nCommon += 1;
    return nCommon;
  }, countCommonItemsR2 = (aStart, aIndex, bStart, bIndex, isCommon) => {
    let nCommon = 0;
    for (; aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex); ) aIndex -= 1, bIndex -= 1, nCommon += 1;
    return nCommon;
  }, extendPathsF2 = (d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
    let iF = 0, kF = -d3, aFirst = aIndexesF[iF], aIndexPrev1 = aFirst;
    aIndexesF[iF] += countCommonItemsF2(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
    let nF = d3 < iMaxF ? d3 : iMaxF;
    for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
      if (iF !== d3 && aIndexPrev1 < aIndexesF[iF]) aFirst = aIndexesF[iF];
      else if (aFirst = aIndexPrev1 + 1, aEnd <= aFirst) return iF - 1;
      aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aFirst + countCommonItemsF2(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
    }
    return iMaxF;
  }, extendPathsR2 = (d3, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
    let iR = 0, kR = d3, aFirst = aIndexesR[iR], aIndexPrev1 = aFirst;
    aIndexesR[iR] -= countCommonItemsR2(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
    let nR = d3 < iMaxR ? d3 : iMaxR;
    for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
      if (iR !== d3 && aIndexesR[iR] < aIndexPrev1) aFirst = aIndexesR[iR];
      else if (aFirst = aIndexPrev1 - 1, aFirst < aStart) return iR - 1;
      aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aFirst - countCommonItemsR2(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
    }
    return iMaxR;
  }, extendOverlappablePathsF2 = (d3, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    let bF = bStart - aStart, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapF = -baDeltaLength - (d3 - 1), kMaxOverlapF = -baDeltaLength + (d3 - 1), aIndexPrev1 = NOT_YET_SET2, nF = d3 < iMaxF ? d3 : iMaxF;
    for (let iF = 0, kF = -d3; iF <= nF; iF += 1, kF += 2) {
      let insert = iF === 0 || iF !== d3 && aIndexPrev1 < aIndexesF[iF], aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev + 1, bFirst = bF + aFirst - kF, nCommonF = countCommonItemsF2(aFirst + 1, aEnd, bFirst + 1, bEnd, isCommon), aLast = aFirst + nCommonF;
      if (aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aLast, kMinOverlapF <= kF && kF <= kMaxOverlapF) {
        let iR = (d3 - 1 - (kF + baDeltaLength)) / 2;
        if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
          let bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1), nCommonR = countCommonItemsR2(aStart, aLastPrev, bStart, bLastPrev, isCommon), aIndexPrevFirst = aLastPrev - nCommonR, bIndexPrevFirst = bLastPrev - nCommonR, aEndPreceding = aIndexPrevFirst + 1, bEndPreceding = bIndexPrevFirst + 1;
          division.nChangePreceding = d3 - 1, d3 - 1 === aEndPreceding + bEndPreceding - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aEndPreceding, division.bEndPreceding = bEndPreceding), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aEndPreceding, division.bCommonPreceding = bEndPreceding), division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aFirst + 1, division.bCommonFollowing = bFirst + 1);
          let aStartFollowing = aLast + 1, bStartFollowing = bFirst + nCommonF + 1;
          return division.nChangeFollowing = d3 - 1, d3 - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing), true;
        }
      }
    }
    return false;
  }, extendOverlappablePathsR2 = (d3, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    let bR = bEnd - aEnd, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapR = baDeltaLength - d3, kMaxOverlapR = baDeltaLength + d3, aIndexPrev1 = NOT_YET_SET2, nR = d3 < iMaxR ? d3 : iMaxR;
    for (let iR = 0, kR = d3; iR <= nR; iR += 1, kR -= 2) {
      let insert = iR === 0 || iR !== d3 && aIndexesR[iR] < aIndexPrev1, aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev - 1, bFirst = bR + aFirst - kR, nCommonR = countCommonItemsR2(aStart, aFirst - 1, bStart, bFirst - 1, isCommon), aLast = aFirst - nCommonR;
      if (aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aLast, kMinOverlapR <= kR && kR <= kMaxOverlapR) {
        let iF = (d3 + (kR - baDeltaLength)) / 2;
        if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
          let bLast = bFirst - nCommonR;
          if (division.nChangePreceding = d3, d3 === aLast + bLast - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aLast, division.bEndPreceding = bLast), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aLast, division.bCommonPreceding = bLast), division.nChangeFollowing = d3 - 1, d3 === 1) division.nCommonFollowing = 0, division.aStartFollowing = aEnd, division.bStartFollowing = bEnd;
          else {
            let bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1), nCommonF = countCommonItemsF2(aLastPrev, aEnd, bLastPrev, bEnd, isCommon);
            division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aLastPrev, division.bCommonFollowing = bLastPrev);
            let aStartFollowing = aLastPrev + nCommonF, bStartFollowing = bLastPrev + nCommonF;
            d3 - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing);
          }
          return true;
        }
      }
    }
    return false;
  }, divide2 = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
    let bF = bStart - aStart, bR = bEnd - aEnd, aLength = aEnd - aStart, bLength = bEnd - bStart, baDeltaLength = bLength - aLength, iMaxF = aLength, iMaxR = aLength;
    if (aIndexesF[0] = aStart - 1, aIndexesR[0] = aEnd, baDeltaLength % 2 === 0) {
      let dMin = (nChange || baDeltaLength) / 2, dMax = (aLength + bLength) / 2;
      for (let d3 = 1; d3 <= dMax; d3 += 1) if (iMaxF = extendPathsF2(d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d3 < dMin) iMaxR = extendPathsR2(d3, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
      else if (extendOverlappablePathsR2(d3, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) return;
    } else {
      let dMin = ((nChange || baDeltaLength) + 1) / 2, dMax = (aLength + bLength + 1) / 2, d3 = 1;
      for (iMaxF = extendPathsF2(d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d3 += 1; d3 <= dMax; d3 += 1) if (iMaxR = extendPathsR2(d3 - 1, aStart, bStart, bR, isCommon, aIndexesR, iMaxR), d3 < dMin) iMaxF = extendPathsF2(d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
      else if (extendOverlappablePathsF2(d3, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) return;
    }
    throw new Error(`${pkg2}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`);
  }, findSubsequences2 = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
    if (bEnd - bStart < aEnd - aStart) {
      if (transposed = !transposed, transposed && callbacks.length === 1) {
        let { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];
        callbacks[1] = { foundSubsequence: (nCommon, bCommon, aCommon) => {
          foundSubsequence2(nCommon, aCommon, bCommon);
        }, isCommon: (bIndex, aIndex) => isCommon2(aIndex, bIndex) };
      }
      let tStart = aStart, tEnd = aEnd;
      aStart = bStart, aEnd = bEnd, bStart = tStart, bEnd = tEnd;
    }
    let { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
    divide2(nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division);
    let { nChangePreceding, aEndPreceding, bEndPreceding, nCommonPreceding, aCommonPreceding, bCommonPreceding, nCommonFollowing, aCommonFollowing, bCommonFollowing, nChangeFollowing, aStartFollowing, bStartFollowing } = division;
    aStart < aEndPreceding && bStart < bEndPreceding && findSubsequences2(nChangePreceding, aStart, aEndPreceding, bStart, bEndPreceding, transposed, callbacks, aIndexesF, aIndexesR, division), nCommonPreceding !== 0 && foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding), nCommonFollowing !== 0 && foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing), aStartFollowing < aEnd && bStartFollowing < bEnd && findSubsequences2(nChangeFollowing, aStartFollowing, aEnd, bStartFollowing, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);
  }, validateLength2 = (name2, arg) => {
    if (typeof arg != "number") throw new TypeError(`${pkg2}: ${name2} typeof ${typeof arg} is not a number`);
    if (!Number.isSafeInteger(arg)) throw new RangeError(`${pkg2}: ${name2} value ${arg} is not a safe integer`);
    if (arg < 0) throw new RangeError(`${pkg2}: ${name2} value ${arg} is a negative integer`);
  }, validateCallback2 = (name2, arg) => {
    let type5 = typeof arg;
    if (type5 !== "function") throw new TypeError(`${pkg2}: ${name2} typeof ${type5} is not a function`);
  };
  function diffSequence2(aLength, bLength, isCommon, foundSubsequence) {
    validateLength2("aLength", aLength), validateLength2("bLength", bLength), validateCallback2("isCommon", isCommon), validateCallback2("foundSubsequence", foundSubsequence);
    let nCommonF = countCommonItemsF2(0, aLength, 0, bLength, isCommon);
    if (nCommonF !== 0 && foundSubsequence(nCommonF, 0, 0), aLength !== nCommonF || bLength !== nCommonF) {
      let aStart = nCommonF, bStart = nCommonF, nCommonR = countCommonItemsR2(aStart, aLength - 1, bStart, bLength - 1, isCommon), aEnd = aLength - nCommonR, bEnd = bLength - nCommonR, nCommonFR = nCommonF + nCommonR;
      aLength !== nCommonFR && bLength !== nCommonFR && findSubsequences2(0, aStart, aEnd, bStart, bEnd, false, [{ foundSubsequence, isCommon }], [NOT_YET_SET2], [NOT_YET_SET2], { aCommonFollowing: NOT_YET_SET2, aCommonPreceding: NOT_YET_SET2, aEndPreceding: NOT_YET_SET2, aStartFollowing: NOT_YET_SET2, bCommonFollowing: NOT_YET_SET2, bCommonPreceding: NOT_YET_SET2, bEndPreceding: NOT_YET_SET2, bStartFollowing: NOT_YET_SET2, nChangeFollowing: NOT_YET_SET2, nChangePreceding: NOT_YET_SET2, nCommonFollowing: NOT_YET_SET2, nCommonPreceding: NOT_YET_SET2 }), nCommonR !== 0 && foundSubsequence(nCommonR, aEnd, bEnd);
    }
  }
  return build;
}
var buildExports = requireBuild();
var diffSequences = getDefaultExportFromCjs(buildExports);
function formatTrailingSpaces(line, trailingSpaceFormatter) {
  return line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
}
function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
  return line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== " " ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
}
function printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
  return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
}
function joinAlignedDiffsNoExpand(diffs, options2) {
  let iLength = diffs.length, nContextLines = options2.contextLines, nContextLines2 = nContextLines + nContextLines, jLength = iLength, hasExcessAtStartOrEnd = false, nExcessesBetweenChanges = 0, i4 = 0;
  for (; i4 !== iLength; ) {
    let iStart = i4;
    for (; i4 !== iLength && diffs[i4][0] === DIFF_EQUAL; ) i4 += 1;
    if (iStart !== i4) if (iStart === 0) i4 > nContextLines && (jLength -= i4 - nContextLines, hasExcessAtStartOrEnd = true);
    else if (i4 === iLength) {
      let n3 = i4 - iStart;
      n3 > nContextLines && (jLength -= n3 - nContextLines, hasExcessAtStartOrEnd = true);
    } else {
      let n3 = i4 - iStart;
      n3 > nContextLines2 && (jLength -= n3 - nContextLines2, nExcessesBetweenChanges += 1);
    }
    for (; i4 !== iLength && diffs[i4][0] !== DIFF_EQUAL; ) i4 += 1;
  }
  let hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
  nExcessesBetweenChanges !== 0 ? jLength += nExcessesBetweenChanges + 1 : hasExcessAtStartOrEnd && (jLength += 1);
  let jLast = jLength - 1, lines = [], jPatchMark = 0;
  hasPatch && lines.push("");
  let aStart = 0, bStart = 0, aEnd = 0, bEnd = 0, pushCommonLine = (line) => {
    let j2 = lines.length;
    lines.push(printCommonLine(line, j2 === 0 || j2 === jLast, options2)), aEnd += 1, bEnd += 1;
  }, pushDeleteLine = (line) => {
    let j2 = lines.length;
    lines.push(printDeleteLine(line, j2 === 0 || j2 === jLast, options2)), aEnd += 1;
  }, pushInsertLine = (line) => {
    let j2 = lines.length;
    lines.push(printInsertLine(line, j2 === 0 || j2 === jLast, options2)), bEnd += 1;
  };
  for (i4 = 0; i4 !== iLength; ) {
    let iStart = i4;
    for (; i4 !== iLength && diffs[i4][0] === DIFF_EQUAL; ) i4 += 1;
    if (iStart !== i4) if (iStart === 0) {
      i4 > nContextLines && (iStart = i4 - nContextLines, aStart = iStart, bStart = iStart, aEnd = aStart, bEnd = bStart);
      for (let iCommon = iStart; iCommon !== i4; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
    } else if (i4 === iLength) {
      let iEnd = i4 - iStart > nContextLines ? iStart + nContextLines : i4;
      for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
    } else {
      let nCommon = i4 - iStart;
      if (nCommon > nContextLines2) {
        let iEnd = iStart + nContextLines;
        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
        lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options2), jPatchMark = lines.length, lines.push("");
        let nOmit = nCommon - nContextLines2;
        aStart = aEnd + nOmit, bStart = bEnd + nOmit, aEnd = aStart, bEnd = bStart;
        for (let iCommon = i4 - nContextLines; iCommon !== i4; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
      } else for (let iCommon = iStart; iCommon !== i4; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
    }
    for (; i4 !== iLength && diffs[i4][0] === DIFF_DELETE; ) pushDeleteLine(diffs[i4][1]), i4 += 1;
    for (; i4 !== iLength && diffs[i4][0] === DIFF_INSERT; ) pushInsertLine(diffs[i4][1]), i4 += 1;
  }
  return hasPatch && (lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options2)), lines.join(`
`);
}
function joinAlignedDiffsExpand(diffs, options2) {
  return diffs.map((diff22, i4, diffs2) => {
    let line = diff22[1], isFirstOrLast = i4 === 0 || i4 === diffs2.length - 1;
    switch (diff22[0]) {
      case DIFF_DELETE:
        return printDeleteLine(line, isFirstOrLast, options2);
      case DIFF_INSERT:
        return printInsertLine(line, isFirstOrLast, options2);
      default:
        return printCommonLine(line, isFirstOrLast, options2);
    }
  }).join(`
`);
}
var noColor = (string) => string;
var DIFF_CONTEXT_DEFAULT = 5;
var DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
function getDefaultOptions() {
  return { aAnnotation: "Expected", aColor: f22.green, aIndicator: "-", bAnnotation: "Received", bColor: f22.red, bIndicator: "+", changeColor: f22.inverse, changeLineTrailingSpaceColor: noColor, commonColor: f22.dim, commonIndicator: " ", commonLineTrailingSpaceColor: noColor, compareKeys: void 0, contextLines: DIFF_CONTEXT_DEFAULT, emptyFirstOrLastLinePlaceholder: "", expand: true, includeChangeCounts: false, omitAnnotationLines: false, patchColor: f22.yellow, truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT, truncateAnnotation: "... Diff result is truncated", truncateAnnotationColor: noColor };
}
function getCompareKeys(compareKeys) {
  return compareKeys && typeof compareKeys == "function" ? compareKeys : void 0;
}
function getContextLines(contextLines) {
  return typeof contextLines == "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
}
function normalizeDiffOptions(options2 = {}) {
  return { ...getDefaultOptions(), ...options2, compareKeys: getCompareKeys(options2.compareKeys), contextLines: getContextLines(options2.contextLines) };
}
function isEmptyString(lines) {
  return lines.length === 1 && lines[0].length === 0;
}
function countChanges(diffs) {
  let a22 = 0, b6 = 0;
  return diffs.forEach((diff22) => {
    switch (diff22[0]) {
      case DIFF_DELETE:
        a22 += 1;
        break;
      case DIFF_INSERT:
        b6 += 1;
        break;
    }
  }), { a: a22, b: b6 };
}
function printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
  if (omitAnnotationLines) return "";
  let aRest = "", bRest = "";
  if (includeChangeCounts) {
    let aCount = String(changeCounts.a), bCount = String(changeCounts.b), baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length, aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff)), bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff)), baCountLengthDiff = bCount.length - aCount.length, aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff)), bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`, bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
  }
  let a22 = `${aIndicator} ${aAnnotation}${aRest}`, b6 = `${bIndicator} ${bAnnotation}${bRest}`;
  return `${aColor(a22)}
${bColor(b6)}

`;
}
function printDiffLines(diffs, truncated, options2) {
  return printAnnotation(options2, countChanges(diffs)) + (options2.expand ? joinAlignedDiffsExpand(diffs, options2) : joinAlignedDiffsNoExpand(diffs, options2)) + (truncated ? options2.truncateAnnotationColor(`
${options2.truncateAnnotation}`) : "");
}
function diffLinesUnified(aLines, bLines, options2) {
  let normalizedOptions = normalizeDiffOptions(options2), [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);
  return printDiffLines(diffs, truncated, normalizedOptions);
}
function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options2) {
  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare) && (aLinesDisplay = [], aLinesCompare = []), isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare) && (bLinesDisplay = [], bLinesCompare = []), aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) return diffLinesUnified(aLinesDisplay, bLinesDisplay, options2);
  let [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options2), aIndex = 0, bIndex = 0;
  return diffs.forEach((diff22) => {
    switch (diff22[0]) {
      case DIFF_DELETE:
        diff22[1] = aLinesDisplay[aIndex], aIndex += 1;
        break;
      case DIFF_INSERT:
        diff22[1] = bLinesDisplay[bIndex], bIndex += 1;
        break;
      default:
        diff22[1] = bLinesDisplay[bIndex], aIndex += 1, bIndex += 1;
    }
  }), printDiffLines(diffs, truncated, normalizeDiffOptions(options2));
}
function diffLinesRaw(aLines, bLines, options2) {
  let truncate23 = (options2 == null ? void 0 : options2.truncateThreshold) ?? false, truncateThreshold = Math.max(Math.floor((options2 == null ? void 0 : options2.truncateThreshold) ?? 0), 0), aLength = truncate23 ? Math.min(aLines.length, truncateThreshold) : aLines.length, bLength = truncate23 ? Math.min(bLines.length, truncateThreshold) : bLines.length, truncated = aLength !== aLines.length || bLength !== bLines.length, isCommon = (aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2], diffs = [], aIndex = 0, bIndex = 0;
  for (diffSequences(aLength, bLength, isCommon, (nCommon, aCommon, bCommon) => {
    for (; aIndex !== aCommon; aIndex += 1) diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
    for (; bIndex !== bCommon; bIndex += 1) diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
  }); aIndex !== aLength; aIndex += 1) diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
  for (; bIndex !== bLength; bIndex += 1) diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
  return [diffs, truncated];
}
function getNewLineSymbol(string) {
  return string.includes(`\r
`) ? `\r
` : `
`;
}
function diffStrings(a22, b6, options2) {
  let truncate23 = (options2 == null ? void 0 : options2.truncateThreshold) ?? false, truncateThreshold = Math.max(Math.floor((options2 == null ? void 0 : options2.truncateThreshold) ?? 0), 0), aLength = a22.length, bLength = b6.length;
  if (truncate23) {
    let aMultipleLines = a22.includes(`
`), bMultipleLines = b6.includes(`
`), aNewLineSymbol = getNewLineSymbol(a22), bNewLineSymbol = getNewLineSymbol(b6), _a2 = aMultipleLines ? `${a22.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}
` : a22, _b = bMultipleLines ? `${b6.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}
` : b6;
    aLength = _a2.length, bLength = _b.length;
  }
  let truncated = aLength !== a22.length || bLength !== b6.length, isCommon = (aIndex2, bIndex2) => a22[aIndex2] === b6[bIndex2], aIndex = 0, bIndex = 0, diffs = [];
  return diffSequences(aLength, bLength, isCommon, (nCommon, aCommon, bCommon) => {
    aIndex !== aCommon && diffs.push(new Diff(DIFF_DELETE, a22.slice(aIndex, aCommon))), bIndex !== bCommon && diffs.push(new Diff(DIFF_INSERT, b6.slice(bIndex, bCommon))), aIndex = aCommon + nCommon, bIndex = bCommon + nCommon, diffs.push(new Diff(DIFF_EQUAL, b6.slice(bCommon, bIndex)));
  }), aIndex !== aLength && diffs.push(new Diff(DIFF_DELETE, a22.slice(aIndex))), bIndex !== bLength && diffs.push(new Diff(DIFF_INSERT, b6.slice(bIndex))), [diffs, truncated];
}
function concatenateRelevantDiffs(op, diffs, changeColor) {
  return diffs.reduce((reduced, diff22) => reduced + (diff22[0] === DIFF_EQUAL ? diff22[1] : diff22[0] === op && diff22[1].length !== 0 ? changeColor(diff22[1]) : ""), "");
}
var ChangeBuffer = class {
  constructor(op, changeColor) {
    __publicField(this, "op");
    __publicField(this, "line");
    __publicField(this, "lines");
    __publicField(this, "changeColor");
    this.op = op, this.line = [], this.lines = [], this.changeColor = changeColor;
  }
  pushSubstring(substring) {
    this.pushDiff(new Diff(this.op, substring));
  }
  pushLine() {
    this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1])), this.line.length = 0;
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  pushDiff(diff22) {
    this.line.push(diff22);
  }
  align(diff22) {
    let string = diff22[1];
    if (string.includes(`
`)) {
      let substrings = string.split(`
`), iLast = substrings.length - 1;
      substrings.forEach((substring, i4) => {
        i4 < iLast ? (this.pushSubstring(substring), this.pushLine()) : substring.length !== 0 && this.pushSubstring(substring);
      });
    } else this.pushDiff(diff22);
  }
  moveLinesTo(lines) {
    this.isLineEmpty() || this.pushLine(), lines.push(...this.lines), this.lines.length = 0;
  }
};
var CommonBuffer = class {
  constructor(deleteBuffer, insertBuffer) {
    __publicField(this, "deleteBuffer");
    __publicField(this, "insertBuffer");
    __publicField(this, "lines");
    this.deleteBuffer = deleteBuffer, this.insertBuffer = insertBuffer, this.lines = [];
  }
  pushDiffCommonLine(diff22) {
    this.lines.push(diff22);
  }
  pushDiffChangeLines(diff22) {
    let isDiffEmpty = diff22[1].length === 0;
    (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(diff22), (!isDiffEmpty || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(diff22);
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines);
  }
  align(diff22) {
    let op = diff22[0], string = diff22[1];
    if (string.includes(`
`)) {
      let substrings = string.split(`
`), iLast = substrings.length - 1;
      substrings.forEach((substring, i4) => {
        if (i4 === 0) {
          let subdiff = new Diff(op, substring);
          this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty() ? (this.flushChangeLines(), this.pushDiffCommonLine(subdiff)) : (this.pushDiffChangeLines(subdiff), this.flushChangeLines());
        } else i4 < iLast ? this.pushDiffCommonLine(new Diff(op, substring)) : substring.length !== 0 && this.pushDiffChangeLines(new Diff(op, substring));
      });
    } else this.pushDiffChangeLines(diff22);
  }
  getLines() {
    return this.flushChangeLines(), this.lines;
  }
};
function getAlignedDiffs(diffs, changeColor) {
  let deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor), insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor), commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
  return diffs.forEach((diff22) => {
    switch (diff22[0]) {
      case DIFF_DELETE:
        deleteBuffer.align(diff22);
        break;
      case DIFF_INSERT:
        insertBuffer.align(diff22);
        break;
      default:
        commonBuffer.align(diff22);
    }
  }), commonBuffer.getLines();
}
function hasCommonDiff(diffs, isMultiline) {
  if (isMultiline) {
    let iLast = diffs.length - 1;
    return diffs.some((diff22, i4) => diff22[0] === DIFF_EQUAL && (i4 !== iLast || diff22[1] !== `
`));
  }
  return diffs.some((diff22) => diff22[0] === DIFF_EQUAL);
}
function diffStringsUnified(a22, b6, options2) {
  if (a22 !== b6 && a22.length !== 0 && b6.length !== 0) {
    let isMultiline = a22.includes(`
`) || b6.includes(`
`), [diffs, truncated] = diffStringsRaw(isMultiline ? `${a22}
` : a22, isMultiline ? `${b6}
` : b6, true, options2);
    if (hasCommonDiff(diffs, isMultiline)) {
      let optionsNormalized = normalizeDiffOptions(options2), lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
      return printDiffLines(lines, truncated, optionsNormalized);
    }
  }
  return diffLinesUnified(a22.split(`
`), b6.split(`
`), options2);
}
function diffStringsRaw(a22, b6, cleanup, options2) {
  let [diffs, truncated] = diffStrings(a22, b6, options2);
  return cleanup && diff_cleanupSemantic(diffs), [diffs, truncated];
}
function getCommonMessage(message, options2) {
  let { commonColor } = normalizeDiffOptions(options2);
  return commonColor(message);
}
var { AsymmetricMatcher: AsymmetricMatcher2, DOMCollection: DOMCollection2, DOMElement: DOMElement2, Immutable: Immutable2, ReactElement: ReactElement2, ReactTestComponent: ReactTestComponent2 } = plugins;
var PLUGINS2 = [ReactTestComponent2, ReactElement2, DOMElement2, DOMCollection2, Immutable2, AsymmetricMatcher2];
var FORMAT_OPTIONS = { plugins: PLUGINS2 };
var FALLBACK_FORMAT_OPTIONS = { callToJSON: false, maxDepth: 10, plugins: PLUGINS2 };
function diff(a22, b6, options2) {
  if (Object.is(a22, b6)) return "";
  let aType = getType3(a22), expectedType = aType, omitDifference = false;
  if (aType === "object" && typeof a22.asymmetricMatch == "function") {
    if (a22.$$typeof !== Symbol.for("jest.asymmetricMatcher") || typeof a22.getExpectedType != "function") return;
    expectedType = a22.getExpectedType(), omitDifference = expectedType === "string";
  }
  if (expectedType !== getType3(b6)) {
    let { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options2), formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options2), aDisplay = format(a22, formatOptions), bDisplay = format(b6, formatOptions), aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} 
${aDisplay}`, bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} 
${bDisplay}`;
    return `${aDiff}

${bDiff}`;
  }
  if (!omitDifference) switch (aType) {
    case "string":
      return diffLinesUnified(a22.split(`
`), b6.split(`
`), options2);
    case "boolean":
    case "number":
      return comparePrimitive(a22, b6, options2);
    case "map":
      return compareObjects(sortMap(a22), sortMap(b6), options2);
    case "set":
      return compareObjects(sortSet(a22), sortSet(b6), options2);
    default:
      return compareObjects(a22, b6, options2);
  }
}
function comparePrimitive(a22, b6, options2) {
  let aFormat = format(a22, FORMAT_OPTIONS), bFormat = format(b6, FORMAT_OPTIONS);
  return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split(`
`), bFormat.split(`
`), options2);
}
function sortMap(map) {
  return new Map(Array.from(map.entries()).sort());
}
function sortSet(set) {
  return new Set(Array.from(set.values()).sort());
}
function compareObjects(a22, b6, options2) {
  let difference, hasThrown = false;
  try {
    let formatOptions = getFormatOptions(FORMAT_OPTIONS, options2);
    difference = getObjectsDifference(a22, b6, formatOptions, options2);
  } catch {
    hasThrown = true;
  }
  let noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options2);
  if (difference === void 0 || difference === noDiffMessage) {
    let formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options2);
    difference = getObjectsDifference(a22, b6, formatOptions, options2), difference !== noDiffMessage && !hasThrown && (difference = `${getCommonMessage(SIMILAR_MESSAGE, options2)}

${difference}`);
  }
  return difference;
}
function getFormatOptions(formatOptions, options2) {
  let { compareKeys } = normalizeDiffOptions(options2);
  return { ...formatOptions, compareKeys };
}
function getObjectsDifference(a22, b6, formatOptions, options2) {
  let formatOptionsZeroIndent = { ...formatOptions, indent: 0 }, aCompare = format(a22, formatOptionsZeroIndent), bCompare = format(b6, formatOptionsZeroIndent);
  if (aCompare === bCompare) return getCommonMessage(NO_DIFF_MESSAGE, options2);
  {
    let aDisplay = format(a22, formatOptions), bDisplay = format(b6, formatOptions);
    return diffLinesUnified2(aDisplay.split(`
`), bDisplay.split(`
`), aCompare.split(`
`), bCompare.split(`
`), options2);
  }
}
var MAX_DIFF_STRING_LENGTH = 2e4;
function isAsymmetricMatcher(data) {
  return getType2(data) === "Object" && typeof data.asymmetricMatch == "function";
}
function isReplaceable(obj1, obj2) {
  let obj1Type = getType2(obj1), obj2Type = getType2(obj2);
  return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
}
function printDiffOrStringify(expected, received, options2) {
  let { aAnnotation, bAnnotation } = normalizeDiffOptions(options2);
  if (typeof expected == "string" && typeof received == "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
    if (expected.includes(`
`) || received.includes(`
`)) return diffStringsUnified(received, expected, options2);
    let [diffs] = diffStringsRaw(received, expected, true), hasCommonDiff22 = diffs.some((diff22) => diff22[0] === DIFF_EQUAL), printLabel = getLabelPrinter(aAnnotation, bAnnotation), expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff22)), receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff22));
    return `${expectedLine}
${receivedLine}`;
  }
  let clonedExpected = deepClone(expected, { forceWritable: true }), clonedReceived = deepClone(received, { forceWritable: true }), { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedExpected, clonedReceived);
  return diff(replacedExpected, replacedActual, options2);
}
function replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {
  return isReplaceable(actual, expected) ? actualReplaced.has(actual) || expectedReplaced.has(expected) ? { replacedActual: actual, replacedExpected: expected } : (actualReplaced.add(actual), expectedReplaced.add(expected), getOwnProperties(expected).forEach((key2) => {
    let expectedValue = expected[key2], actualValue = actual[key2];
    if (isAsymmetricMatcher(expectedValue)) expectedValue.asymmetricMatch(actualValue) && (actual[key2] = expectedValue);
    else if (isAsymmetricMatcher(actualValue)) actualValue.asymmetricMatch(expectedValue) && (expected[key2] = actualValue);
    else if (isReplaceable(actualValue, expectedValue)) {
      let replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
      actual[key2] = replaced.replacedActual, expected[key2] = replaced.replacedExpected;
    }
  }), { replacedActual: actual, replacedExpected: expected }) : { replacedActual: actual, replacedExpected: expected };
}
function getLabelPrinter(...strings) {
  let maxLength = strings.reduce((max, string) => string.length > max ? string.length : max, 0);
  return (string) => `${string}: ${" ".repeat(maxLength - string.length)}`;
}
var SPACE_SYMBOL = "";
function replaceTrailingSpaces(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));
}
function printReceived(object) {
  return f22.red(replaceTrailingSpaces(stringify(object)));
}
function printExpected(value2) {
  return f22.green(replaceTrailingSpaces(stringify(value2)));
}
function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff22) {
  return diffs.reduce((reduced, diff22) => reduced + (diff22[0] === DIFF_EQUAL ? diff22[1] : diff22[0] === op ? hasCommonDiff22 ? f22.inverse(diff22[1]) : diff22[1] : ""), "");
}
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isImmutable(v6) {
  return v6 && (v6[IS_COLLECTION_SYMBOL] || v6[IS_RECORD_SYMBOL]);
}
var OBJECT_PROTO = Object.getPrototypeOf({});
function getUnserializableMessage(err) {
  return err instanceof Error ? `<unserializable>: ${err.message}` : typeof err == "string" ? `<unserializable>: ${err}` : "<unserializable>";
}
function serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {
  if (!val || typeof val == "string") return val;
  if (typeof val == "function") return `Function<${val.name || "anonymous"}>`;
  if (typeof val == "symbol") return val.toString();
  if (typeof val != "object") return val;
  if (isImmutable(val)) return serializeValue(val.toJSON(), seen);
  if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction") return "Promise";
  if (typeof Element < "u" && val instanceof Element) return val.tagName;
  if (typeof val.asymmetricMatch == "function") return `${val.toString()} ${format2(val.sample)}`;
  if (typeof val.toJSON == "function") return serializeValue(val.toJSON(), seen);
  if (seen.has(val)) return seen.get(val);
  if (Array.isArray(val)) {
    let clone22 = new Array(val.length);
    return seen.set(val, clone22), val.forEach((e2, i4) => {
      try {
        clone22[i4] = serializeValue(e2, seen);
      } catch (err) {
        clone22[i4] = getUnserializableMessage(err);
      }
    }), clone22;
  } else {
    let clone22 = /* @__PURE__ */ Object.create(null);
    seen.set(val, clone22);
    let obj = val;
    for (; obj && obj !== OBJECT_PROTO; ) Object.getOwnPropertyNames(obj).forEach((key2) => {
      if (!(key2 in clone22)) try {
        clone22[key2] = serializeValue(val[key2], seen);
      } catch (err) {
        delete clone22[key2], clone22[key2] = getUnserializableMessage(err);
      }
    }), obj = Object.getPrototypeOf(obj);
    return clone22;
  }
}
function normalizeErrorMessage(message) {
  return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
function processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {
  if (!_err || typeof _err != "object") return { message: String(_err) };
  let err = _err;
  err.stack && (err.stackStr = String(err.stack)), err.name && (err.nameStr = String(err.name)), (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) && (err.diff = printDiffOrStringify(err.actual, err.expected, { ...diffOptions, ...err.diffOptions })), typeof err.expected != "string" && (err.expected = stringify(err.expected, 10)), typeof err.actual != "string" && (err.actual = stringify(err.actual, 10));
  try {
    typeof err.message == "string" && (err.message = normalizeErrorMessage(err.message));
  } catch {
  }
  try {
    !seen.has(err) && typeof err.cause == "object" && (seen.add(err), err.cause = processError(err.cause, diffOptions, seen));
  } catch {
  }
  try {
    return serializeValue(err);
  } catch (e2) {
    return serializeValue(new Error(`Failed to fully serialize error: ${e2 == null ? void 0 : e2.message}
Inner error message: ${err == null ? void 0 : err.message}`));
  }
}
var CallStates = ((CallStates2) => (CallStates2.DONE = "done", CallStates2.ERROR = "error", CallStates2.ACTIVE = "active", CallStates2.WAITING = "waiting", CallStates2))(CallStates || {});
var EVENTS = { CALL: "storybook/instrumenter/call", SYNC: "storybook/instrumenter/sync", START: "storybook/instrumenter/start", BACK: "storybook/instrumenter/back", GOTO: "storybook/instrumenter/goto", NEXT: "storybook/instrumenter/next", END: "storybook/instrumenter/end" };
var controlsDisabled = { start: false, back: false, goto: false, next: false, end: false };
var alreadyCompletedException = new Error("This function ran after the play function completed. Did you forget to `await` it?");
var isObject = (o3) => Object.prototype.toString.call(o3) === "[object Object]";
var isModule = (o3) => Object.prototype.toString.call(o3) === "[object Module]";
var isInstrumentable = (o3) => {
  if (!isObject(o3) && !isModule(o3)) return false;
  if (o3.constructor === void 0) return true;
  let proto = o3.constructor.prototype;
  return !!isObject(proto);
};
var construct = (obj) => {
  try {
    return new obj.constructor();
  } catch {
    return {};
  }
};
var getInitialState = () => ({ renderPhase: void 0, isDebugging: false, isPlaying: false, isLocked: false, cursor: 0, calls: [], shadowCalls: [], callRefsByResult: /* @__PURE__ */ new Map(), chainedCallIds: /* @__PURE__ */ new Set(), ancestors: [], playUntil: void 0, resolvers: {}, syncTimeout: void 0 });
var getRetainedState = (state, isDebugging = false) => {
  let calls = (isDebugging ? state.shadowCalls : state.calls).filter((call2) => call2.retain);
  if (!calls.length) return;
  let callRefsByResult = new Map(Array.from(state.callRefsByResult.entries()).filter(([, ref]) => ref.retain));
  return { cursor: calls.length, calls, callRefsByResult };
};
var Instrumenter = class {
  constructor() {
    var _a2;
    this.initialized = false;
    this.channel = q4.getChannel(), this.state = ((_a2 = scope.window) == null ? void 0 : _a2.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__) || {};
    let resetState = ({ storyId, isPlaying = true, isDebugging = false }) => {
      let state = this.getState(storyId);
      this.setState(storyId, { ...getInitialState(), ...getRetainedState(state, isDebugging), shadowCalls: isDebugging ? state.shadowCalls : [], chainedCallIds: isDebugging ? state.chainedCallIds : /* @__PURE__ */ new Set(), playUntil: isDebugging ? state.playUntil : void 0, isPlaying, isDebugging }), this.sync(storyId);
    };
    this.channel.on(P, resetState), this.channel.on(B, ({ storyId, newPhase }) => {
      let { isDebugging } = this.getState(storyId);
      this.setState(storyId, { renderPhase: newPhase }), newPhase === "preparing" && isDebugging && resetState({ storyId }), newPhase === "playing" && resetState({ storyId, isDebugging }), newPhase === "played" && this.setState(storyId, { isLocked: false, isPlaying: false, isDebugging: false }), newPhase === "errored" && this.setState(storyId, { isLocked: false, isPlaying: false });
    }), this.channel.on(p, () => {
      this.initialized ? this.cleanup() : this.initialized = true;
    });
    let start = ({ storyId, playUntil }) => {
      this.getState(storyId).isDebugging || this.setState(storyId, ({ calls }) => ({ calls: [], shadowCalls: calls.map((call2) => ({ ...call2, status: "waiting" })), isDebugging: true }));
      let log = this.getLog(storyId);
      this.setState(storyId, ({ shadowCalls }) => {
        var _a3;
        if (playUntil || !log.length) return { playUntil };
        let firstRowIndex = shadowCalls.findIndex((call2) => call2.id === log[0].callId);
        return { playUntil: (_a3 = shadowCalls.slice(0, firstRowIndex).filter((call2) => call2.interceptable && !call2.ancestors.length).slice(-1)[0]) == null ? void 0 : _a3.id };
      }), this.channel.emit(P, { storyId, isDebugging: true });
    }, back = ({ storyId }) => {
      var _a3;
      let log = this.getLog(storyId).filter((call2) => !call2.ancestors.length), last = log.reduceRight((res, item, index) => res >= 0 || item.status === "waiting" ? res : index, -1);
      start({ storyId, playUntil: (_a3 = log[last - 1]) == null ? void 0 : _a3.callId });
    }, goto = ({ storyId, callId }) => {
      var _a3;
      let { calls, shadowCalls, resolvers } = this.getState(storyId), call2 = calls.find(({ id }) => id === callId), shadowCall = shadowCalls.find(({ id }) => id === callId);
      if (!call2 && shadowCall && Object.values(resolvers).length > 0) {
        let nextId = (_a3 = this.getLog(storyId).find((c3) => c3.status === "waiting")) == null ? void 0 : _a3.callId;
        shadowCall.id !== nextId && this.setState(storyId, { playUntil: shadowCall.id }), Object.values(resolvers).forEach((resolve) => resolve());
      } else start({ storyId, playUntil: callId });
    }, next = ({ storyId }) => {
      var _a3;
      let { resolvers } = this.getState(storyId);
      if (Object.values(resolvers).length > 0) Object.values(resolvers).forEach((resolve) => resolve());
      else {
        let nextId = (_a3 = this.getLog(storyId).find((c3) => c3.status === "waiting")) == null ? void 0 : _a3.callId;
        nextId ? start({ storyId, playUntil: nextId }) : end({ storyId });
      }
    }, end = ({ storyId }) => {
      this.setState(storyId, { playUntil: void 0, isDebugging: false }), Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());
    };
    this.channel.on(EVENTS.START, start), this.channel.on(EVENTS.BACK, back), this.channel.on(EVENTS.GOTO, goto), this.channel.on(EVENTS.NEXT, next), this.channel.on(EVENTS.END, end);
  }
  getState(storyId) {
    return this.state[storyId] || getInitialState();
  }
  setState(storyId, update) {
    var _a2;
    let state = this.getState(storyId), patch = typeof update == "function" ? update(state) : update;
    this.state = { ...this.state, [storyId]: { ...state, ...patch } }, ((_a2 = scope.window) == null ? void 0 : _a2.parent) && (scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state);
  }
  cleanup() {
    var _a2;
    this.state = Object.entries(this.state).reduce((acc, [storyId, state]) => {
      let retainedState = getRetainedState(state);
      return retainedState && (acc[storyId] = Object.assign(getInitialState(), retainedState)), acc;
    }, {});
    let payload = { controlStates: controlsDisabled, logItems: [] };
    this.channel.emit(EVENTS.SYNC, payload), ((_a2 = scope.window) == null ? void 0 : _a2.parent) && (scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state);
  }
  getLog(storyId) {
    let { calls, shadowCalls } = this.getState(storyId), merged = [...shadowCalls];
    calls.forEach((call2, index) => {
      merged[index] = call2;
    });
    let seen = /* @__PURE__ */ new Set();
    return merged.reduceRight((acc, call2) => (call2.args.forEach((arg) => {
      (arg == null ? void 0 : arg.__callId__) && seen.add(arg.__callId__);
    }), call2.path.forEach((node) => {
      node.__callId__ && seen.add(node.__callId__);
    }), (call2.interceptable || call2.exception) && !seen.has(call2.id) && (acc.unshift({ callId: call2.id, status: call2.status, ancestors: call2.ancestors }), seen.add(call2.id)), acc), []);
  }
  instrument(obj, options2, depth = 0) {
    if (!isInstrumentable(obj)) return obj;
    let { mutate = false, path = [] } = options2, keys2 = options2.getKeys ? options2.getKeys(obj, depth) : Object.keys(obj);
    return depth += 1, keys2.reduce((acc, key2) => {
      let descriptor = getPropertyDescriptor(obj, key2);
      if (typeof (descriptor == null ? void 0 : descriptor.get) == "function") {
        let getter = () => {
          var _a2, _b;
          return (_b = (_a2 = descriptor == null ? void 0 : descriptor.get) == null ? void 0 : _a2.bind(obj)) == null ? void 0 : _b();
        };
        return Object.defineProperty(acc, key2, { get: () => this.instrument(getter(), { ...options2, path: path.concat(key2) }, depth) }), acc;
      }
      let value2 = obj[key2];
      return typeof value2 != "function" ? (acc[key2] = this.instrument(value2, { ...options2, path: path.concat(key2) }, depth), acc) : "__originalFn__" in value2 && typeof value2.__originalFn__ == "function" ? (acc[key2] = value2, acc) : (acc[key2] = (...args2) => this.track(key2, value2, obj, args2, options2), acc[key2].__originalFn__ = value2, Object.defineProperty(acc[key2], "name", { value: key2, writable: false }), Object.keys(value2).length > 0 && Object.assign(acc[key2], this.instrument({ ...value2 }, { ...options2, path: path.concat(key2) }, depth)), acc);
    }, mutate ? obj : construct(obj));
  }
  track(method, fn3, object, args2, options2) {
    var _a2, _b, _c, _d;
    let storyId = ((_a2 = args2 == null ? void 0 : args2[0]) == null ? void 0 : _a2.__storyId__) || ((_d = (_c = (_b = scope.__STORYBOOK_PREVIEW__) == null ? void 0 : _b.selectionStore) == null ? void 0 : _c.selection) == null ? void 0 : _d.storyId), { cursor, ancestors } = this.getState(storyId);
    this.setState(storyId, { cursor: cursor + 1 });
    let id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`, { path = [], intercept = false, retain = false } = options2, interceptable = typeof intercept == "function" ? intercept(method, path) : intercept, call2 = { id, cursor, storyId, ancestors, path, method, args: args2, interceptable, retain }, result2 = (interceptable && !ancestors.length ? this.intercept : this.invoke).call(this, fn3, object, call2, options2);
    return this.instrument(result2, { ...options2, mutate: true, path: [{ __callId__: call2.id }] });
  }
  intercept(fn3, object, call2, options2) {
    let { chainedCallIds, isDebugging, playUntil } = this.getState(call2.storyId), isChainedUpon = chainedCallIds.has(call2.id);
    return !isDebugging || isChainedUpon || playUntil ? (playUntil === call2.id && this.setState(call2.storyId, { playUntil: void 0 }), this.invoke(fn3, object, call2, options2)) : new Promise((resolve) => {
      this.setState(call2.storyId, ({ resolvers }) => ({ isLocked: false, resolvers: { ...resolvers, [call2.id]: resolve } }));
    }).then(() => (this.setState(call2.storyId, (state) => {
      let { [call2.id]: _4, ...resolvers } = state.resolvers;
      return { isLocked: true, resolvers };
    }), this.invoke(fn3, object, call2, options2)));
  }
  invoke(fn3, object, call2, options2) {
    let { callRefsByResult, renderPhase } = this.getState(call2.storyId), maximumDepth = 25, serializeValues = (value2, depth, seen) => {
      var _a2, _b, _c;
      if (seen.includes(value2)) return "[Circular]";
      if (seen = [...seen, value2], depth > maximumDepth) return "...";
      if (callRefsByResult.has(value2)) return callRefsByResult.get(value2);
      if (value2 instanceof Array) return value2.map((it2) => serializeValues(it2, ++depth, seen));
      if (value2 instanceof Date) return { __date__: { value: value2.toISOString() } };
      if (value2 instanceof Error) {
        let { name: name2, message, stack } = value2;
        return { __error__: { name: name2, message, stack } };
      }
      if (value2 instanceof RegExp) {
        let { flags, source: source2 } = value2;
        return { __regexp__: { flags, source: source2 } };
      }
      if (value2 instanceof ((_a2 = scope.window) == null ? void 0 : _a2.HTMLElement)) {
        let { prefix, localName, id, classList, innerText } = value2, classNames = Array.from(classList);
        return { __element__: { prefix, localName, id, classNames, innerText } };
      }
      return typeof value2 == "function" ? { __function__: { name: "getMockName" in value2 ? value2.getMockName() : value2.name } } : typeof value2 == "symbol" ? { __symbol__: { description: value2.description } } : typeof value2 == "object" && ((_b = value2 == null ? void 0 : value2.constructor) == null ? void 0 : _b.name) && ((_c = value2 == null ? void 0 : value2.constructor) == null ? void 0 : _c.name) !== "Object" ? { __class__: { name: value2.constructor.name } } : Object.prototype.toString.call(value2) === "[object Object]" ? Object.fromEntries(Object.entries(value2).map(([key2, val]) => [key2, serializeValues(val, ++depth, seen)])) : value2;
    }, info = { ...call2, args: call2.args.map((arg) => serializeValues(arg, 0, [])) };
    call2.path.forEach((ref) => {
      (ref == null ? void 0 : ref.__callId__) && this.setState(call2.storyId, ({ chainedCallIds }) => ({ chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__)) }));
    });
    let handleException = (e2) => {
      if (e2 instanceof Error) {
        let { name: name2, message, stack, callId = call2.id } = e2, { showDiff = void 0, diff: diff22 = void 0, actual = void 0, expected = void 0 } = e2.name === "AssertionError" ? processError(e2) : e2, exception = { name: name2, message, stack, callId, showDiff, diff: diff22, actual, expected };
        if (this.update({ ...info, status: "error", exception }), this.setState(call2.storyId, (state) => ({ callRefsByResult: new Map([...Array.from(state.callRefsByResult.entries()), [e2, { __callId__: call2.id, retain: call2.retain }]]) })), call2.ancestors.length) throw Object.prototype.hasOwnProperty.call(e2, "callId") || Object.defineProperty(e2, "callId", { value: call2.id }), e2;
      }
      throw e2;
    };
    try {
      if (renderPhase === "played" && !call2.retain) throw alreadyCompletedException;
      let finalArgs = (options2.getArgs ? options2.getArgs(call2, this.getState(call2.storyId)) : call2.args).map((arg) => typeof arg != "function" || Object.keys(arg).length ? arg : (...args2) => {
        let { cursor, ancestors } = this.getState(call2.storyId);
        this.setState(call2.storyId, { cursor: 0, ancestors: [...ancestors, call2.id] });
        let restore = () => this.setState(call2.storyId, { cursor, ancestors }), willRestore = false;
        try {
          let res = arg(...args2);
          return res instanceof Promise ? (willRestore = true, res.finally(restore)) : res;
        } finally {
          willRestore || restore();
        }
      }), result2 = fn3.apply(object, finalArgs);
      return result2 && ["object", "function", "symbol"].includes(typeof result2) && this.setState(call2.storyId, (state) => ({ callRefsByResult: new Map([...Array.from(state.callRefsByResult.entries()), [result2, { __callId__: call2.id, retain: call2.retain }]]) })), this.update({ ...info, status: result2 instanceof Promise ? "active" : "done" }), result2 instanceof Promise ? result2.then((value2) => (this.update({ ...info, status: "done" }), value2), handleException) : result2;
    } catch (e2) {
      return handleException(e2);
    }
  }
  update(call2) {
    this.channel.emit(EVENTS.CALL, call2), this.setState(call2.storyId, ({ calls }) => {
      let callsById = calls.concat(call2).reduce((a22, c3) => Object.assign(a22, { [c3.id]: c3 }), {});
      return { calls: Object.values(callsById).sort((a22, b6) => a22.id.localeCompare(b6.id, void 0, { numeric: true })) };
    }), this.sync(call2.storyId);
  }
  sync(storyId) {
    let synchronize = () => {
      var _a2;
      let { isLocked, isPlaying } = this.getState(storyId), logItems = this.getLog(storyId), pausedAt = (_a2 = logItems.filter(({ ancestors }) => !ancestors.length).find((item) => item.status === "waiting")) == null ? void 0 : _a2.callId, hasActive = logItems.some((item) => item.status === "active");
      if (isLocked || hasActive || logItems.length === 0) {
        let payload2 = { controlStates: controlsDisabled, logItems };
        this.channel.emit(EVENTS.SYNC, payload2);
        return;
      }
      let hasPrevious = logItems.some((item) => item.status === "done" || item.status === "error"), payload = { controlStates: { start: hasPrevious, back: hasPrevious, goto: true, next: isPlaying, end: isPlaying }, logItems, pausedAt };
      this.channel.emit(EVENTS.SYNC, payload);
    };
    this.setState(storyId, ({ syncTimeout }) => (clearTimeout(syncTimeout), { syncTimeout: setTimeout(synchronize, 0) }));
  }
};
function instrument(obj, options2 = {}) {
  var _a2, _b, _c, _d, _e2, _f, _g, _h;
  try {
    let forceInstrument = false, skipInstrument = false;
    return ((_c = (_b = (_a2 = scope.window) == null ? void 0 : _a2.location) == null ? void 0 : _b.search) == null ? void 0 : _c.includes("instrument=true")) ? forceInstrument = true : ((_f = (_e2 = (_d = scope.window) == null ? void 0 : _d.location) == null ? void 0 : _e2.search) == null ? void 0 : _f.includes("instrument=false")) && (skipInstrument = true), ((_g = scope.window) == null ? void 0 : _g.parent) === scope.window && !forceInstrument || skipInstrument ? obj : (scope.window && !scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ && (scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter()), ((_h = scope.window) == null ? void 0 : _h.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(obj, options2));
  } catch (e2) {
    return n.warn(e2), obj;
  }
}
function getPropertyDescriptor(obj, propName) {
  let target = obj;
  for (; target != null; ) {
    let descriptor = Object.getOwnPropertyDescriptor(target, propName);
    if (descriptor) return descriptor;
    target = Object.getPrototypeOf(target);
  }
}

// node_modules/@storybook/test/dist/index.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require3 = ((x22) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(x22, { get: (a22, b6) => (typeof __require < "u" ? __require : a22)[b6] }) : x22)(function(x22) {
  if (typeof __require < "u") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + x22 + '" is not supported');
});
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export2 = (target, all) => {
  for (var name2 in all) __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to3, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function") for (let key2 of __getOwnPropNames(from)) !__hasOwnProp.call(to3, key2) && key2 !== except && __defProp(to3, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  return to3;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var require_min_indent = __commonJS({ "../../node_modules/min-indent/index.js"(exports, module2) {
  module2.exports = (string) => {
    let match = string.match(/^[ \t]*(?=\S)/gm);
    return match ? match.reduce((r4, a22) => Math.min(r4, a22.length), 1 / 0) : 0;
  };
} });
var require_strip_indent = __commonJS({ "../../node_modules/strip-indent/index.js"(exports, module2) {
  var minIndent = require_min_indent();
  module2.exports = (string) => {
    let indent = minIndent(string);
    if (indent === 0) return string;
    let regex = new RegExp(`^[ \\t]{${indent}}`, "gm");
    return string.replace(regex, "");
  };
} });
var require_indent_string = __commonJS({ "../../node_modules/indent-string/index.js"(exports, module2) {
  module2.exports = (string, count = 1, options2) => {
    if (options2 = { indent: " ", includeEmptyLines: false, ...options2 }, typeof string != "string") throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
    if (typeof count != "number") throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
    if (typeof options2.indent != "string") throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options2.indent}\``);
    if (count === 0) return string;
    let regex = options2.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
    return string.replace(regex, options2.indent.repeat(count));
  };
} });
var require_redent = __commonJS({ "../../node_modules/redent/index.js"(exports, module2) {
  var stripIndent = require_strip_indent(), indentString = require_indent_string();
  module2.exports = (string, count = 0, options2) => indentString(stripIndent(string), count, options2);
} });
var require_iteratorProxy = __commonJS({ "../../node_modules/aria-query/lib/util/iteratorProxy.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  function iteratorProxy() {
    var values = this, index = 0, iter = { "@@iterator": function() {
      return iter;
    }, next: function() {
      if (index < values.length) {
        var value2 = values[index];
        return index = index + 1, { done: false, value: value2 };
      } else return { done: true };
    } };
    return iter;
  }
  var _default2 = iteratorProxy;
  exports.default = _default2;
} });
var require_iterationDecorator = __commonJS({ "../../node_modules/aria-query/lib/util/iterationDecorator.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = iterationDecorator;
  var _iteratorProxy = _interopRequireDefault(require_iteratorProxy());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _typeof5(obj) {
    "@babel/helpers - typeof";
    return _typeof5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof5(obj);
  }
  function iterationDecorator(collection, entries) {
    return typeof Symbol == "function" && _typeof5(Symbol.iterator) === "symbol" && Object.defineProperty(collection, Symbol.iterator, { value: _iteratorProxy.default.bind(entries) }), collection;
  }
} });
var require_ariaPropsMap = __commonJS({ "../../node_modules/aria-query/lib/ariaPropsMap.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i4) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i4) || _unsupportedIterableToArray(arr, i4) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function _iterableToArrayLimit(arr, i4) {
    var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i != null) {
      var _arr = [], _n3 = true, _d = false, _s2, _e2;
      try {
        for (_i = _i.call(arr); !(_n3 = (_s2 = _i.next()).done) && (_arr.push(_s2.value), !(i4 && _arr.length === i4)); _n3 = true) ;
      } catch (err) {
        _d = true, _e2 = err;
      } finally {
        try {
          !_n3 && _i.return != null && _i.return();
        } finally {
          if (_d) throw _e2;
        }
      }
      return _arr;
    }
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _createForOfIteratorHelper(o3, allowArrayLike) {
    var it2 = typeof Symbol < "u" && o3[Symbol.iterator] || o3["@@iterator"];
    if (!it2) {
      if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length == "number") {
        it2 && (o3 = it2);
        var i4 = 0, F5 = function() {
        };
        return { s: F5, n: function() {
          return i4 >= o3.length ? { done: true } : { done: false, value: o3[i4++] };
        }, e: function(_e2) {
          throw _e2;
        }, f: F5 };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function() {
      it2 = it2.call(o3);
    }, n: function() {
      var step = it2.next();
      return normalCompletion = step.done, step;
    }, e: function(_e3) {
      didErr = true, err = _e3;
    }, f: function() {
      try {
        !normalCompletion && it2.return != null && it2.return();
      } finally {
        if (didErr) throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o3, minLen) {
    if (o3) {
      if (typeof o3 == "string") return _arrayLikeToArray(o3, minLen);
      var n3 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n3 === "Object" && o3.constructor && (n3 = o3.constructor.name), n3 === "Map" || n3 === "Set") return Array.from(o3);
      if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return _arrayLikeToArray(o3, minLen);
    }
  }
  function _arrayLikeToArray(arr, len) {
    (len == null || len > arr.length) && (len = arr.length);
    for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++) arr2[i4] = arr[i4];
    return arr2;
  }
  var properties = [["aria-activedescendant", { type: "id" }], ["aria-atomic", { type: "boolean" }], ["aria-autocomplete", { type: "token", values: ["inline", "list", "both", "none"] }], ["aria-braillelabel", { type: "string" }], ["aria-brailleroledescription", { type: "string" }], ["aria-busy", { type: "boolean" }], ["aria-checked", { type: "tristate" }], ["aria-colcount", { type: "integer" }], ["aria-colindex", { type: "integer" }], ["aria-colspan", { type: "integer" }], ["aria-controls", { type: "idlist" }], ["aria-current", { type: "token", values: ["page", "step", "location", "date", "time", true, false] }], ["aria-describedby", { type: "idlist" }], ["aria-description", { type: "string" }], ["aria-details", { type: "id" }], ["aria-disabled", { type: "boolean" }], ["aria-dropeffect", { type: "tokenlist", values: ["copy", "execute", "link", "move", "none", "popup"] }], ["aria-errormessage", { type: "id" }], ["aria-expanded", { type: "boolean", allowundefined: true }], ["aria-flowto", { type: "idlist" }], ["aria-grabbed", { type: "boolean", allowundefined: true }], ["aria-haspopup", { type: "token", values: [false, true, "menu", "listbox", "tree", "grid", "dialog"] }], ["aria-hidden", { type: "boolean", allowundefined: true }], ["aria-invalid", { type: "token", values: ["grammar", false, "spelling", true] }], ["aria-keyshortcuts", { type: "string" }], ["aria-label", { type: "string" }], ["aria-labelledby", { type: "idlist" }], ["aria-level", { type: "integer" }], ["aria-live", { type: "token", values: ["assertive", "off", "polite"] }], ["aria-modal", { type: "boolean" }], ["aria-multiline", { type: "boolean" }], ["aria-multiselectable", { type: "boolean" }], ["aria-orientation", { type: "token", values: ["vertical", "undefined", "horizontal"] }], ["aria-owns", { type: "idlist" }], ["aria-placeholder", { type: "string" }], ["aria-posinset", { type: "integer" }], ["aria-pressed", { type: "tristate" }], ["aria-readonly", { type: "boolean" }], ["aria-relevant", { type: "tokenlist", values: ["additions", "all", "removals", "text"] }], ["aria-required", { type: "boolean" }], ["aria-roledescription", { type: "string" }], ["aria-rowcount", { type: "integer" }], ["aria-rowindex", { type: "integer" }], ["aria-rowspan", { type: "integer" }], ["aria-selected", { type: "boolean", allowundefined: true }], ["aria-setsize", { type: "integer" }], ["aria-sort", { type: "token", values: ["ascending", "descending", "none", "other"] }], ["aria-valuemax", { type: "number" }], ["aria-valuemin", { type: "number" }], ["aria-valuenow", { type: "number" }], ["aria-valuetext", { type: "string" }]], ariaPropsMap = { entries: function() {
    return properties;
  }, forEach: function(fn3) {
    var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _iterator = _createForOfIteratorHelper(properties), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _slicedToArray(_step.value, 2), key2 = _step$value[0], values = _step$value[1];
        fn3.call(thisArg, values, key2, properties);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }, get: function(key2) {
    var item = properties.find(function(tuple) {
      return tuple[0] === key2;
    });
    return item && item[1];
  }, has: function(key2) {
    return !!ariaPropsMap.get(key2);
  }, keys: function() {
    return properties.map(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
      return key2;
    });
  }, values: function() {
    return properties.map(function(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
      return values2;
    });
  } }, _default2 = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
  exports.default = _default2;
} });
var require_domMap = __commonJS({ "../../node_modules/aria-query/lib/domMap.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i4) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i4) || _unsupportedIterableToArray(arr, i4) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function _iterableToArrayLimit(arr, i4) {
    var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i != null) {
      var _arr = [], _n3 = true, _d = false, _s2, _e2;
      try {
        for (_i = _i.call(arr); !(_n3 = (_s2 = _i.next()).done) && (_arr.push(_s2.value), !(i4 && _arr.length === i4)); _n3 = true) ;
      } catch (err) {
        _d = true, _e2 = err;
      } finally {
        try {
          !_n3 && _i.return != null && _i.return();
        } finally {
          if (_d) throw _e2;
        }
      }
      return _arr;
    }
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _createForOfIteratorHelper(o3, allowArrayLike) {
    var it2 = typeof Symbol < "u" && o3[Symbol.iterator] || o3["@@iterator"];
    if (!it2) {
      if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length == "number") {
        it2 && (o3 = it2);
        var i4 = 0, F5 = function() {
        };
        return { s: F5, n: function() {
          return i4 >= o3.length ? { done: true } : { done: false, value: o3[i4++] };
        }, e: function(_e2) {
          throw _e2;
        }, f: F5 };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function() {
      it2 = it2.call(o3);
    }, n: function() {
      var step = it2.next();
      return normalCompletion = step.done, step;
    }, e: function(_e3) {
      didErr = true, err = _e3;
    }, f: function() {
      try {
        !normalCompletion && it2.return != null && it2.return();
      } finally {
        if (didErr) throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o3, minLen) {
    if (o3) {
      if (typeof o3 == "string") return _arrayLikeToArray(o3, minLen);
      var n3 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n3 === "Object" && o3.constructor && (n3 = o3.constructor.name), n3 === "Map" || n3 === "Set") return Array.from(o3);
      if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return _arrayLikeToArray(o3, minLen);
    }
  }
  function _arrayLikeToArray(arr, len) {
    (len == null || len > arr.length) && (len = arr.length);
    for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++) arr2[i4] = arr[i4];
    return arr2;
  }
  var dom = [["a", { reserved: false }], ["abbr", { reserved: false }], ["acronym", { reserved: false }], ["address", { reserved: false }], ["applet", { reserved: false }], ["area", { reserved: false }], ["article", { reserved: false }], ["aside", { reserved: false }], ["audio", { reserved: false }], ["b", { reserved: false }], ["base", { reserved: true }], ["bdi", { reserved: false }], ["bdo", { reserved: false }], ["big", { reserved: false }], ["blink", { reserved: false }], ["blockquote", { reserved: false }], ["body", { reserved: false }], ["br", { reserved: false }], ["button", { reserved: false }], ["canvas", { reserved: false }], ["caption", { reserved: false }], ["center", { reserved: false }], ["cite", { reserved: false }], ["code", { reserved: false }], ["col", { reserved: true }], ["colgroup", { reserved: true }], ["content", { reserved: false }], ["data", { reserved: false }], ["datalist", { reserved: false }], ["dd", { reserved: false }], ["del", { reserved: false }], ["details", { reserved: false }], ["dfn", { reserved: false }], ["dialog", { reserved: false }], ["dir", { reserved: false }], ["div", { reserved: false }], ["dl", { reserved: false }], ["dt", { reserved: false }], ["em", { reserved: false }], ["embed", { reserved: false }], ["fieldset", { reserved: false }], ["figcaption", { reserved: false }], ["figure", { reserved: false }], ["font", { reserved: false }], ["footer", { reserved: false }], ["form", { reserved: false }], ["frame", { reserved: false }], ["frameset", { reserved: false }], ["h1", { reserved: false }], ["h2", { reserved: false }], ["h3", { reserved: false }], ["h4", { reserved: false }], ["h5", { reserved: false }], ["h6", { reserved: false }], ["head", { reserved: true }], ["header", { reserved: false }], ["hgroup", { reserved: false }], ["hr", { reserved: false }], ["html", { reserved: true }], ["i", { reserved: false }], ["iframe", { reserved: false }], ["img", { reserved: false }], ["input", { reserved: false }], ["ins", { reserved: false }], ["kbd", { reserved: false }], ["keygen", { reserved: false }], ["label", { reserved: false }], ["legend", { reserved: false }], ["li", { reserved: false }], ["link", { reserved: true }], ["main", { reserved: false }], ["map", { reserved: false }], ["mark", { reserved: false }], ["marquee", { reserved: false }], ["menu", { reserved: false }], ["menuitem", { reserved: false }], ["meta", { reserved: true }], ["meter", { reserved: false }], ["nav", { reserved: false }], ["noembed", { reserved: true }], ["noscript", { reserved: true }], ["object", { reserved: false }], ["ol", { reserved: false }], ["optgroup", { reserved: false }], ["option", { reserved: false }], ["output", { reserved: false }], ["p", { reserved: false }], ["param", { reserved: true }], ["picture", { reserved: true }], ["pre", { reserved: false }], ["progress", { reserved: false }], ["q", { reserved: false }], ["rp", { reserved: false }], ["rt", { reserved: false }], ["rtc", { reserved: false }], ["ruby", { reserved: false }], ["s", { reserved: false }], ["samp", { reserved: false }], ["script", { reserved: true }], ["section", { reserved: false }], ["select", { reserved: false }], ["small", { reserved: false }], ["source", { reserved: true }], ["spacer", { reserved: false }], ["span", { reserved: false }], ["strike", { reserved: false }], ["strong", { reserved: false }], ["style", { reserved: true }], ["sub", { reserved: false }], ["summary", { reserved: false }], ["sup", { reserved: false }], ["table", { reserved: false }], ["tbody", { reserved: false }], ["td", { reserved: false }], ["textarea", { reserved: false }], ["tfoot", { reserved: false }], ["th", { reserved: false }], ["thead", { reserved: false }], ["time", { reserved: false }], ["title", { reserved: true }], ["tr", { reserved: false }], ["track", { reserved: true }], ["tt", { reserved: false }], ["u", { reserved: false }], ["ul", { reserved: false }], ["var", { reserved: false }], ["video", { reserved: false }], ["wbr", { reserved: false }], ["xmp", { reserved: false }]], domMap = { entries: function() {
    return dom;
  }, forEach: function(fn3) {
    var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _iterator = _createForOfIteratorHelper(dom), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _slicedToArray(_step.value, 2), key2 = _step$value[0], values = _step$value[1];
        fn3.call(thisArg, values, key2, dom);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }, get: function(key2) {
    var item = dom.find(function(tuple) {
      return tuple[0] === key2;
    });
    return item && item[1];
  }, has: function(key2) {
    return !!domMap.get(key2);
  }, keys: function() {
    return dom.map(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
      return key2;
    });
  }, values: function() {
    return dom.map(function(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
      return values2;
    });
  } }, _default2 = (0, _iterationDecorator.default)(domMap, domMap.entries());
  exports.default = _default2;
} });
var require_commandRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var commandRole = { abstract: true, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget"]] }, _default2 = commandRole;
  exports.default = _default2;
} });
var require_compositeRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var compositeRole = { abstract: true, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-activedescendant": null, "aria-disabled": null }, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget"]] }, _default2 = compositeRole;
  exports.default = _default2;
} });
var require_inputRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var inputRole = { abstract: true, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null }, relatedConcepts: [{ concept: { name: "input" }, module: "XForms" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget"]] }, _default2 = inputRole;
  exports.default = _default2;
} });
var require_landmarkRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var landmarkRole = { abstract: true, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = landmarkRole;
  exports.default = _default2;
} });
var require_rangeRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var rangeRole = { abstract: true, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-valuemax": null, "aria-valuemin": null, "aria-valuenow": null }, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure"]] }, _default2 = rangeRole;
  exports.default = _default2;
} });
var require_roletypeRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var roletypeRole = { abstract: true, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: [], prohibitedProps: [], props: { "aria-atomic": null, "aria-busy": null, "aria-controls": null, "aria-current": null, "aria-describedby": null, "aria-details": null, "aria-dropeffect": null, "aria-flowto": null, "aria-grabbed": null, "aria-hidden": null, "aria-keyshortcuts": null, "aria-label": null, "aria-labelledby": null, "aria-live": null, "aria-owns": null, "aria-relevant": null, "aria-roledescription": null }, relatedConcepts: [{ concept: { name: "role" }, module: "XHTML" }, { concept: { name: "type" }, module: "Dublin Core" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [] }, _default2 = roletypeRole;
  exports.default = _default2;
} });
var require_sectionRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var sectionRole = { abstract: true, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: [], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "frontmatter" }, module: "DTB" }, { concept: { name: "level" }, module: "DTB" }, { concept: { name: "level" }, module: "SMIL" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure"]] }, _default2 = sectionRole;
  exports.default = _default2;
} });
var require_sectionheadRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var sectionheadRole = { abstract: true, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure"]] }, _default2 = sectionheadRole;
  exports.default = _default2;
} });
var require_selectRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var selectRole = { abstract: true, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-orientation": null }, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]] }, _default2 = selectRole;
  exports.default = _default2;
} });
var require_structureRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var structureRole = { abstract: true, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: [], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype"]] }, _default2 = structureRole;
  exports.default = _default2;
} });
var require_widgetRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var widgetRole = { abstract: true, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: [], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype"]] }, _default2 = widgetRole;
  exports.default = _default2;
} });
var require_windowRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var windowRole = { abstract: true, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-modal": null }, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype"]] }, _default2 = windowRole;
  exports.default = _default2;
} });
var require_ariaAbstractRoles = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var _commandRole = _interopRequireDefault(require_commandRole()), _compositeRole = _interopRequireDefault(require_compositeRole()), _inputRole = _interopRequireDefault(require_inputRole()), _landmarkRole = _interopRequireDefault(require_landmarkRole()), _rangeRole = _interopRequireDefault(require_rangeRole()), _roletypeRole = _interopRequireDefault(require_roletypeRole()), _sectionRole = _interopRequireDefault(require_sectionRole()), _sectionheadRole = _interopRequireDefault(require_sectionheadRole()), _selectRole = _interopRequireDefault(require_selectRole()), _structureRole = _interopRequireDefault(require_structureRole()), _widgetRole = _interopRequireDefault(require_widgetRole()), _windowRole = _interopRequireDefault(require_windowRole());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]], _default2 = ariaAbstractRoles;
  exports.default = _default2;
} });
var require_alertRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var alertRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-atomic": "true", "aria-live": "assertive" }, relatedConcepts: [{ concept: { name: "alert" }, module: "XForms" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = alertRole;
  exports.default = _default2;
} });
var require_alertdialogRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var alertdialogRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "alert" }, module: "XForms" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]] }, _default2 = alertdialogRole;
  exports.default = _default2;
} });
var require_applicationRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var applicationRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-activedescendant": null, "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "Device Independence Delivery Unit" } }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure"]] }, _default2 = applicationRole;
  exports.default = _default2;
} });
var require_articleRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var articleRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-posinset": null, "aria-setsize": null }, relatedConcepts: [{ concept: { name: "article" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "document"]] }, _default2 = articleRole;
  exports.default = _default2;
} });
var require_bannerRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var bannerRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { constraints: ["scoped to the body element"], name: "header" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = bannerRole;
  exports.default = _default2;
} });
var require_blockquoteRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var blockquoteRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "blockquote" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = blockquoteRole;
  exports.default = _default2;
} });
var require_buttonRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var buttonRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-disabled": null, "aria-expanded": null, "aria-haspopup": null, "aria-pressed": null }, relatedConcepts: [{ concept: { attributes: [{ name: "type", value: "button" }], name: "input" }, module: "HTML" }, { concept: { attributes: [{ name: "type", value: "image" }], name: "input" }, module: "HTML" }, { concept: { attributes: [{ name: "type", value: "reset" }], name: "input" }, module: "HTML" }, { concept: { attributes: [{ name: "type", value: "submit" }], name: "input" }, module: "HTML" }, { concept: { name: "button" }, module: "HTML" }, { concept: { name: "trigger" }, module: "XForms" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget", "command"]] }, _default2 = buttonRole;
  exports.default = _default2;
} });
var require_captionRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var captionRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["prohibited"], prohibitedProps: ["aria-label", "aria-labelledby"], props: {}, relatedConcepts: [{ concept: { name: "caption" }, module: "HTML" }], requireContextRole: ["figure", "grid", "table"], requiredContextRole: ["figure", "grid", "table"], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = captionRole;
  exports.default = _default2;
} });
var require_cellRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var cellRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-colindex": null, "aria-colspan": null, "aria-rowindex": null, "aria-rowspan": null }, relatedConcepts: [{ concept: { constraints: ["ancestor table element has table role"], name: "td" }, module: "HTML" }], requireContextRole: ["row"], requiredContextRole: ["row"], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = cellRole;
  exports.default = _default2;
} });
var require_checkboxRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var checkboxRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-checked": null, "aria-errormessage": null, "aria-expanded": null, "aria-invalid": null, "aria-readonly": null, "aria-required": null }, relatedConcepts: [{ concept: { attributes: [{ name: "type", value: "checkbox" }], name: "input" }, module: "HTML" }, { concept: { name: "option" }, module: "ARIA" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: { "aria-checked": null }, superClass: [["roletype", "widget", "input"]] }, _default2 = checkboxRole;
  exports.default = _default2;
} });
var require_codeRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var codeRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["prohibited"], prohibitedProps: ["aria-label", "aria-labelledby"], props: {}, relatedConcepts: [{ concept: { name: "code" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = codeRole;
  exports.default = _default2;
} });
var require_columnheaderRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var columnheaderRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-sort": null }, relatedConcepts: [{ concept: { name: "th" }, module: "HTML" }, { concept: { attributes: [{ name: "scope", value: "col" }], name: "th" }, module: "HTML" }, { concept: { attributes: [{ name: "scope", value: "colgroup" }], name: "th" }, module: "HTML" }], requireContextRole: ["row"], requiredContextRole: ["row"], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]] }, _default2 = columnheaderRole;
  exports.default = _default2;
} });
var require_comboboxRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var comboboxRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-activedescendant": null, "aria-autocomplete": null, "aria-errormessage": null, "aria-invalid": null, "aria-readonly": null, "aria-required": null, "aria-expanded": "false", "aria-haspopup": "listbox" }, relatedConcepts: [{ concept: { attributes: [{ constraints: ["set"], name: "list" }, { name: "type", value: "email" }], name: "input" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["set"], name: "list" }, { name: "type", value: "search" }], name: "input" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["set"], name: "list" }, { name: "type", value: "tel" }], name: "input" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["set"], name: "list" }, { name: "type", value: "text" }], name: "input" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["set"], name: "list" }, { name: "type", value: "url" }], name: "input" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["set"], name: "list" }, { name: "type", value: "url" }], name: "input" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["undefined"], name: "multiple" }, { constraints: ["undefined"], name: "size" }], constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"], name: "select" }, module: "HTML" }, { concept: { name: "select" }, module: "XForms" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: { "aria-controls": null, "aria-expanded": "false" }, superClass: [["roletype", "widget", "input"]] }, _default2 = comboboxRole;
  exports.default = _default2;
} });
var require_complementaryRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var complementaryRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "aside" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["set"], name: "aria-label" }], constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"], name: "aside" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["set"], name: "aria-labelledby" }], constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"], name: "aside" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = complementaryRole;
  exports.default = _default2;
} });
var require_contentinfoRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var contentinfoRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { constraints: ["scoped to the body element"], name: "footer" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = contentinfoRole;
  exports.default = _default2;
} });
var require_definitionRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var definitionRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "dd" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = definitionRole;
  exports.default = _default2;
} });
var require_deletionRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var deletionRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["prohibited"], prohibitedProps: ["aria-label", "aria-labelledby"], props: {}, relatedConcepts: [{ concept: { name: "del" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = deletionRole;
  exports.default = _default2;
} });
var require_dialogRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var dialogRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "dialog" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "window"]] }, _default2 = dialogRole;
  exports.default = _default2;
} });
var require_directoryRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var directoryRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ module: "DAISY Guide" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "list"]] }, _default2 = directoryRole;
  exports.default = _default2;
} });
var require_documentRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var documentRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "Device Independence Delivery Unit" } }, { concept: { name: "html" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure"]] }, _default2 = documentRole;
  exports.default = _default2;
} });
var require_emphasisRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var emphasisRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["prohibited"], prohibitedProps: ["aria-label", "aria-labelledby"], props: {}, relatedConcepts: [{ concept: { name: "em" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = emphasisRole;
  exports.default = _default2;
} });
var require_feedRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var feedRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["article"]], requiredProps: {}, superClass: [["roletype", "structure", "section", "list"]] }, _default2 = feedRole;
  exports.default = _default2;
} });
var require_figureRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var figureRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "figure" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = figureRole;
  exports.default = _default2;
} });
var require_formRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/formRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var formRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { attributes: [{ constraints: ["set"], name: "aria-label" }], name: "form" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["set"], name: "aria-labelledby" }], name: "form" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["set"], name: "name" }], name: "form" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = formRole;
  exports.default = _default2;
} });
var require_genericRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var genericRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["prohibited"], prohibitedProps: ["aria-label", "aria-labelledby"], props: {}, relatedConcepts: [{ concept: { name: "a" }, module: "HTML" }, { concept: { name: "area" }, module: "HTML" }, { concept: { name: "aside" }, module: "HTML" }, { concept: { name: "b" }, module: "HTML" }, { concept: { name: "bdo" }, module: "HTML" }, { concept: { name: "body" }, module: "HTML" }, { concept: { name: "data" }, module: "HTML" }, { concept: { name: "div" }, module: "HTML" }, { concept: { constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"], name: "footer" }, module: "HTML" }, { concept: { constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"], name: "header" }, module: "HTML" }, { concept: { name: "hgroup" }, module: "HTML" }, { concept: { name: "i" }, module: "HTML" }, { concept: { name: "pre" }, module: "HTML" }, { concept: { name: "q" }, module: "HTML" }, { concept: { name: "samp" }, module: "HTML" }, { concept: { name: "section" }, module: "HTML" }, { concept: { name: "small" }, module: "HTML" }, { concept: { name: "span" }, module: "HTML" }, { concept: { name: "u" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure"]] }, _default2 = genericRole;
  exports.default = _default2;
} });
var require_gridRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var gridRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-multiselectable": null, "aria-readonly": null }, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["row"], ["row", "rowgroup"]], requiredProps: {}, superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]] }, _default2 = gridRole;
  exports.default = _default2;
} });
var require_gridcellRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var gridcellRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null, "aria-readonly": null, "aria-required": null, "aria-selected": null }, relatedConcepts: [{ concept: { constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"], name: "td" }, module: "HTML" }], requireContextRole: ["row"], requiredContextRole: ["row"], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]] }, _default2 = gridcellRole;
  exports.default = _default2;
} });
var require_groupRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var groupRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-activedescendant": null, "aria-disabled": null }, relatedConcepts: [{ concept: { name: "details" }, module: "HTML" }, { concept: { name: "fieldset" }, module: "HTML" }, { concept: { name: "optgroup" }, module: "HTML" }, { concept: { name: "address" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = groupRole;
  exports.default = _default2;
} });
var require_headingRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var headingRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-level": "2" }, relatedConcepts: [{ concept: { name: "h1" }, module: "HTML" }, { concept: { name: "h2" }, module: "HTML" }, { concept: { name: "h3" }, module: "HTML" }, { concept: { name: "h4" }, module: "HTML" }, { concept: { name: "h5" }, module: "HTML" }, { concept: { name: "h6" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: { "aria-level": "2" }, superClass: [["roletype", "structure", "sectionhead"]] }, _default2 = headingRole;
  exports.default = _default2;
} });
var require_imgRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var imgRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { attributes: [{ constraints: ["set"], name: "alt" }], name: "img" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["undefined"], name: "alt" }], name: "img" }, module: "HTML" }, { concept: { name: "imggroup" }, module: "DTB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = imgRole;
  exports.default = _default2;
} });
var require_insertionRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var insertionRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["prohibited"], prohibitedProps: ["aria-label", "aria-labelledby"], props: {}, relatedConcepts: [{ concept: { name: "ins" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = insertionRole;
  exports.default = _default2;
} });
var require_linkRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var linkRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-disabled": null, "aria-expanded": null, "aria-haspopup": null }, relatedConcepts: [{ concept: { attributes: [{ constraints: ["set"], name: "href" }], name: "a" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["set"], name: "href" }], name: "area" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget", "command"]] }, _default2 = linkRole;
  exports.default = _default2;
} });
var require_listRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/listRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var listRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "menu" }, module: "HTML" }, { concept: { name: "ol" }, module: "HTML" }, { concept: { name: "ul" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["listitem"]], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = listRole;
  exports.default = _default2;
} });
var require_listboxRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var listboxRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-errormessage": null, "aria-expanded": null, "aria-invalid": null, "aria-multiselectable": null, "aria-readonly": null, "aria-required": null, "aria-orientation": "vertical" }, relatedConcepts: [{ concept: { attributes: [{ constraints: [">1"], name: "size" }], constraints: ["the size attribute value is greater than 1"], name: "select" }, module: "HTML" }, { concept: { attributes: [{ name: "multiple" }], name: "select" }, module: "HTML" }, { concept: { name: "datalist" }, module: "HTML" }, { concept: { name: "list" }, module: "ARIA" }, { concept: { name: "select" }, module: "XForms" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["option", "group"], ["option"]], requiredProps: {}, superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]] }, _default2 = listboxRole;
  exports.default = _default2;
} });
var require_listitemRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var listitemRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-level": null, "aria-posinset": null, "aria-setsize": null }, relatedConcepts: [{ concept: { constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"], name: "li" }, module: "HTML" }, { concept: { name: "item" }, module: "XForms" }], requireContextRole: ["directory", "list"], requiredContextRole: ["directory", "list"], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = listitemRole;
  exports.default = _default2;
} });
var require_logRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/logRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var logRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-live": "polite" }, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = logRole;
  exports.default = _default2;
} });
var require_mainRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var mainRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "main" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = mainRole;
  exports.default = _default2;
} });
var require_markRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/markRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var markRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["prohibited"], prohibitedProps: [], props: { "aria-braillelabel": null, "aria-brailleroledescription": null, "aria-description": null }, relatedConcepts: [{ concept: { name: "mark" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = markRole;
  exports.default = _default2;
} });
var require_marqueeRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var marqueeRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = marqueeRole;
  exports.default = _default2;
} });
var require_mathRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var mathRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "math" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = mathRole;
  exports.default = _default2;
} });
var require_menuRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var menuRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-orientation": "vertical" }, relatedConcepts: [{ concept: { name: "MENU" }, module: "JAPI" }, { concept: { name: "list" }, module: "ARIA" }, { concept: { name: "select" }, module: "XForms" }, { concept: { name: "sidebar" }, module: "DTB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]], requiredProps: {}, superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]] }, _default2 = menuRole;
  exports.default = _default2;
} });
var require_menubarRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var menubarRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-orientation": "horizontal" }, relatedConcepts: [{ concept: { name: "toolbar" }, module: "ARIA" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]], requiredProps: {}, superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]] }, _default2 = menubarRole;
  exports.default = _default2;
} });
var require_menuitemRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var menuitemRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-disabled": null, "aria-expanded": null, "aria-haspopup": null, "aria-posinset": null, "aria-setsize": null }, relatedConcepts: [{ concept: { name: "MENU_ITEM" }, module: "JAPI" }, { concept: { name: "listitem" }, module: "ARIA" }, { concept: { name: "option" }, module: "ARIA" }], requireContextRole: ["group", "menu", "menubar"], requiredContextRole: ["group", "menu", "menubar"], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget", "command"]] }, _default2 = menuitemRole;
  exports.default = _default2;
} });
var require_menuitemcheckboxRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var menuitemcheckboxRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author", "contents"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "menuitem" }, module: "ARIA" }], requireContextRole: ["group", "menu", "menubar"], requiredContextRole: ["group", "menu", "menubar"], requiredOwnedElements: [], requiredProps: { "aria-checked": null }, superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]] }, _default2 = menuitemcheckboxRole;
  exports.default = _default2;
} });
var require_menuitemradioRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var menuitemradioRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author", "contents"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "menuitem" }, module: "ARIA" }], requireContextRole: ["group", "menu", "menubar"], requiredContextRole: ["group", "menu", "menubar"], requiredOwnedElements: [], requiredProps: { "aria-checked": null }, superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]] }, _default2 = menuitemradioRole;
  exports.default = _default2;
} });
var require_meterRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var meterRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author"], prohibitedProps: [], props: { "aria-valuetext": null, "aria-valuemax": "100", "aria-valuemin": "0" }, relatedConcepts: [{ concept: { name: "meter" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: { "aria-valuenow": null }, superClass: [["roletype", "structure", "range"]] }, _default2 = meterRole;
  exports.default = _default2;
} });
var require_navigationRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var navigationRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "nav" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = navigationRole;
  exports.default = _default2;
} });
var require_noneRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var noneRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: [], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [] }, _default2 = noneRole;
  exports.default = _default2;
} });
var require_noteRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var noteRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = noteRole;
  exports.default = _default2;
} });
var require_optionRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var optionRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-checked": null, "aria-posinset": null, "aria-setsize": null, "aria-selected": "false" }, relatedConcepts: [{ concept: { name: "item" }, module: "XForms" }, { concept: { name: "listitem" }, module: "ARIA" }, { concept: { name: "option" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: { "aria-selected": "false" }, superClass: [["roletype", "widget", "input"]] }, _default2 = optionRole;
  exports.default = _default2;
} });
var require_paragraphRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var paragraphRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["prohibited"], prohibitedProps: ["aria-label", "aria-labelledby"], props: {}, relatedConcepts: [{ concept: { name: "p" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = paragraphRole;
  exports.default = _default2;
} });
var require_presentationRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var presentationRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["prohibited"], prohibitedProps: ["aria-label", "aria-labelledby"], props: {}, relatedConcepts: [{ concept: { attributes: [{ name: "alt", value: "" }], name: "img" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure"]] }, _default2 = presentationRole;
  exports.default = _default2;
} });
var require_progressbarRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var progressbarRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author"], prohibitedProps: [], props: { "aria-valuetext": null }, relatedConcepts: [{ concept: { name: "progress" }, module: "HTML" }, { concept: { name: "status" }, module: "ARIA" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "range"], ["roletype", "widget"]] }, _default2 = progressbarRole;
  exports.default = _default2;
} });
var require_radioRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var radioRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-checked": null, "aria-posinset": null, "aria-setsize": null }, relatedConcepts: [{ concept: { attributes: [{ name: "type", value: "radio" }], name: "input" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: { "aria-checked": null }, superClass: [["roletype", "widget", "input"]] }, _default2 = radioRole;
  exports.default = _default2;
} });
var require_radiogroupRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var radiogroupRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-errormessage": null, "aria-invalid": null, "aria-readonly": null, "aria-required": null }, relatedConcepts: [{ concept: { name: "list" }, module: "ARIA" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["radio"]], requiredProps: {}, superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]] }, _default2 = radiogroupRole;
  exports.default = _default2;
} });
var require_regionRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var regionRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { attributes: [{ constraints: ["set"], name: "aria-label" }], name: "section" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["set"], name: "aria-labelledby" }], name: "section" }, module: "HTML" }, { concept: { name: "Device Independence Glossart perceivable unit" } }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = regionRole;
  exports.default = _default2;
} });
var require_rowRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var rowRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-colindex": null, "aria-expanded": null, "aria-level": null, "aria-posinset": null, "aria-rowindex": null, "aria-selected": null, "aria-setsize": null }, relatedConcepts: [{ concept: { name: "tr" }, module: "HTML" }], requireContextRole: ["grid", "rowgroup", "table", "treegrid"], requiredContextRole: ["grid", "rowgroup", "table", "treegrid"], requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]], requiredProps: {}, superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]] }, _default2 = rowRole;
  exports.default = _default2;
} });
var require_rowgroupRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var rowgroupRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "tbody" }, module: "HTML" }, { concept: { name: "tfoot" }, module: "HTML" }, { concept: { name: "thead" }, module: "HTML" }], requireContextRole: ["grid", "table", "treegrid"], requiredContextRole: ["grid", "table", "treegrid"], requiredOwnedElements: [["row"]], requiredProps: {}, superClass: [["roletype", "structure"]] }, _default2 = rowgroupRole;
  exports.default = _default2;
} });
var require_rowheaderRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var rowheaderRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-sort": null }, relatedConcepts: [{ concept: { attributes: [{ name: "scope", value: "row" }], name: "th" }, module: "HTML" }, { concept: { attributes: [{ name: "scope", value: "rowgroup" }], name: "th" }, module: "HTML" }], requireContextRole: ["row", "rowgroup"], requiredContextRole: ["row", "rowgroup"], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]] }, _default2 = rowheaderRole;
  exports.default = _default2;
} });
var require_scrollbarRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var scrollbarRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: true, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-valuetext": null, "aria-orientation": "vertical", "aria-valuemax": "100", "aria-valuemin": "0" }, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: { "aria-controls": null, "aria-valuenow": null }, superClass: [["roletype", "structure", "range"], ["roletype", "widget"]] }, _default2 = scrollbarRole;
  exports.default = _default2;
} });
var require_searchRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var searchRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = searchRole;
  exports.default = _default2;
} });
var require_searchboxRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var searchboxRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { attributes: [{ constraints: ["undefined"], name: "list" }, { name: "type", value: "search" }], constraints: ["the list attribute is not set"], name: "input" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget", "input", "textbox"]] }, _default2 = searchboxRole;
  exports.default = _default2;
} });
var require_separatorRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var separatorRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: true, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-orientation": "horizontal", "aria-valuemax": "100", "aria-valuemin": "0", "aria-valuenow": null, "aria-valuetext": null }, relatedConcepts: [{ concept: { name: "hr" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure"]] }, _default2 = separatorRole;
  exports.default = _default2;
} });
var require_sliderRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var sliderRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author"], prohibitedProps: [], props: { "aria-errormessage": null, "aria-haspopup": null, "aria-invalid": null, "aria-readonly": null, "aria-valuetext": null, "aria-orientation": "horizontal", "aria-valuemax": "100", "aria-valuemin": "0" }, relatedConcepts: [{ concept: { attributes: [{ name: "type", value: "range" }], name: "input" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: { "aria-valuenow": null }, superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]] }, _default2 = sliderRole;
  exports.default = _default2;
} });
var require_spinbuttonRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var spinbuttonRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-errormessage": null, "aria-invalid": null, "aria-readonly": null, "aria-required": null, "aria-valuetext": null, "aria-valuenow": "0" }, relatedConcepts: [{ concept: { attributes: [{ name: "type", value: "number" }], name: "input" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]] }, _default2 = spinbuttonRole;
  exports.default = _default2;
} });
var require_statusRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var statusRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-atomic": "true", "aria-live": "polite" }, relatedConcepts: [{ concept: { name: "output" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = statusRole;
  exports.default = _default2;
} });
var require_strongRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var strongRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["prohibited"], prohibitedProps: ["aria-label", "aria-labelledby"], props: {}, relatedConcepts: [{ concept: { name: "strong" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = strongRole;
  exports.default = _default2;
} });
var require_subscriptRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var subscriptRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["prohibited"], prohibitedProps: ["aria-label", "aria-labelledby"], props: {}, relatedConcepts: [{ concept: { name: "sub" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = subscriptRole;
  exports.default = _default2;
} });
var require_superscriptRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var superscriptRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["prohibited"], prohibitedProps: ["aria-label", "aria-labelledby"], props: {}, relatedConcepts: [{ concept: { name: "sup" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = superscriptRole;
  exports.default = _default2;
} });
var require_switchRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var switchRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author", "contents"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "button" }, module: "ARIA" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: { "aria-checked": null }, superClass: [["roletype", "widget", "input", "checkbox"]] }, _default2 = switchRole;
  exports.default = _default2;
} });
var require_tabRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var tabRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: true, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-disabled": null, "aria-expanded": null, "aria-haspopup": null, "aria-posinset": null, "aria-setsize": null, "aria-selected": "false" }, relatedConcepts: [], requireContextRole: ["tablist"], requiredContextRole: ["tablist"], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]] }, _default2 = tabRole;
  exports.default = _default2;
} });
var require_tableRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var tableRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-colcount": null, "aria-rowcount": null }, relatedConcepts: [{ concept: { name: "table" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["row"], ["row", "rowgroup"]], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = tableRole;
  exports.default = _default2;
} });
var require_tablistRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var tablistRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-level": null, "aria-multiselectable": null, "aria-orientation": "horizontal" }, relatedConcepts: [{ module: "DAISY", concept: { name: "guide" } }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["tab"]], requiredProps: {}, superClass: [["roletype", "widget", "composite"]] }, _default2 = tablistRole;
  exports.default = _default2;
} });
var require_tabpanelRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var tabpanelRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = tabpanelRole;
  exports.default = _default2;
} });
var require_termRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/termRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var termRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "dfn" }, module: "HTML" }, { concept: { name: "dt" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = termRole;
  exports.default = _default2;
} });
var require_textboxRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var textboxRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-activedescendant": null, "aria-autocomplete": null, "aria-errormessage": null, "aria-haspopup": null, "aria-invalid": null, "aria-multiline": null, "aria-placeholder": null, "aria-readonly": null, "aria-required": null }, relatedConcepts: [{ concept: { attributes: [{ constraints: ["undefined"], name: "type" }, { constraints: ["undefined"], name: "list" }], constraints: ["the list attribute is not set"], name: "input" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["undefined"], name: "list" }, { name: "type", value: "email" }], constraints: ["the list attribute is not set"], name: "input" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["undefined"], name: "list" }, { name: "type", value: "tel" }], constraints: ["the list attribute is not set"], name: "input" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["undefined"], name: "list" }, { name: "type", value: "text" }], constraints: ["the list attribute is not set"], name: "input" }, module: "HTML" }, { concept: { attributes: [{ constraints: ["undefined"], name: "list" }, { name: "type", value: "url" }], constraints: ["the list attribute is not set"], name: "input" }, module: "HTML" }, { concept: { name: "input" }, module: "XForms" }, { concept: { name: "textarea" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget", "input"]] }, _default2 = textboxRole;
  exports.default = _default2;
} });
var require_timeRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var timeRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "time" }, module: "HTML" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = timeRole;
  exports.default = _default2;
} });
var require_timerRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var timerRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "status"]] }, _default2 = timerRole;
  exports.default = _default2;
} });
var require_toolbarRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var toolbarRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-orientation": "horizontal" }, relatedConcepts: [{ concept: { name: "menubar" }, module: "ARIA" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "group"]] }, _default2 = toolbarRole;
  exports.default = _default2;
} });
var require_tooltipRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var tooltipRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = tooltipRole;
  exports.default = _default2;
} });
var require_treeRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var treeRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-errormessage": null, "aria-invalid": null, "aria-multiselectable": null, "aria-required": null, "aria-orientation": "vertical" }, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["treeitem", "group"], ["treeitem"]], requiredProps: {}, superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]] }, _default2 = treeRole;
  exports.default = _default2;
} });
var require_treegridRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var treegridRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["row"], ["row", "rowgroup"]], requiredProps: {}, superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]] }, _default2 = treegridRole;
  exports.default = _default2;
} });
var require_treeitemRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var treeitemRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-expanded": null, "aria-haspopup": null }, relatedConcepts: [], requireContextRole: ["group", "tree"], requiredContextRole: ["group", "tree"], requiredOwnedElements: [], requiredProps: { "aria-selected": null }, superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]] }, _default2 = treeitemRole;
  exports.default = _default2;
} });
var require_ariaLiteralRoles = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var _alertRole = _interopRequireDefault(require_alertRole()), _alertdialogRole = _interopRequireDefault(require_alertdialogRole()), _applicationRole = _interopRequireDefault(require_applicationRole()), _articleRole = _interopRequireDefault(require_articleRole()), _bannerRole = _interopRequireDefault(require_bannerRole()), _blockquoteRole = _interopRequireDefault(require_blockquoteRole()), _buttonRole = _interopRequireDefault(require_buttonRole()), _captionRole = _interopRequireDefault(require_captionRole()), _cellRole = _interopRequireDefault(require_cellRole()), _checkboxRole = _interopRequireDefault(require_checkboxRole()), _codeRole = _interopRequireDefault(require_codeRole()), _columnheaderRole = _interopRequireDefault(require_columnheaderRole()), _comboboxRole = _interopRequireDefault(require_comboboxRole()), _complementaryRole = _interopRequireDefault(require_complementaryRole()), _contentinfoRole = _interopRequireDefault(require_contentinfoRole()), _definitionRole = _interopRequireDefault(require_definitionRole()), _deletionRole = _interopRequireDefault(require_deletionRole()), _dialogRole = _interopRequireDefault(require_dialogRole()), _directoryRole = _interopRequireDefault(require_directoryRole()), _documentRole = _interopRequireDefault(require_documentRole()), _emphasisRole = _interopRequireDefault(require_emphasisRole()), _feedRole = _interopRequireDefault(require_feedRole()), _figureRole = _interopRequireDefault(require_figureRole()), _formRole = _interopRequireDefault(require_formRole()), _genericRole = _interopRequireDefault(require_genericRole()), _gridRole = _interopRequireDefault(require_gridRole()), _gridcellRole = _interopRequireDefault(require_gridcellRole()), _groupRole = _interopRequireDefault(require_groupRole()), _headingRole = _interopRequireDefault(require_headingRole()), _imgRole = _interopRequireDefault(require_imgRole()), _insertionRole = _interopRequireDefault(require_insertionRole()), _linkRole = _interopRequireDefault(require_linkRole()), _listRole = _interopRequireDefault(require_listRole()), _listboxRole = _interopRequireDefault(require_listboxRole()), _listitemRole = _interopRequireDefault(require_listitemRole()), _logRole = _interopRequireDefault(require_logRole()), _mainRole = _interopRequireDefault(require_mainRole()), _markRole = _interopRequireDefault(require_markRole()), _marqueeRole = _interopRequireDefault(require_marqueeRole()), _mathRole = _interopRequireDefault(require_mathRole()), _menuRole = _interopRequireDefault(require_menuRole()), _menubarRole = _interopRequireDefault(require_menubarRole()), _menuitemRole = _interopRequireDefault(require_menuitemRole()), _menuitemcheckboxRole = _interopRequireDefault(require_menuitemcheckboxRole()), _menuitemradioRole = _interopRequireDefault(require_menuitemradioRole()), _meterRole = _interopRequireDefault(require_meterRole()), _navigationRole = _interopRequireDefault(require_navigationRole()), _noneRole = _interopRequireDefault(require_noneRole()), _noteRole = _interopRequireDefault(require_noteRole()), _optionRole = _interopRequireDefault(require_optionRole()), _paragraphRole = _interopRequireDefault(require_paragraphRole()), _presentationRole = _interopRequireDefault(require_presentationRole()), _progressbarRole = _interopRequireDefault(require_progressbarRole()), _radioRole = _interopRequireDefault(require_radioRole()), _radiogroupRole = _interopRequireDefault(require_radiogroupRole()), _regionRole = _interopRequireDefault(require_regionRole()), _rowRole = _interopRequireDefault(require_rowRole()), _rowgroupRole = _interopRequireDefault(require_rowgroupRole()), _rowheaderRole = _interopRequireDefault(require_rowheaderRole()), _scrollbarRole = _interopRequireDefault(require_scrollbarRole()), _searchRole = _interopRequireDefault(require_searchRole()), _searchboxRole = _interopRequireDefault(require_searchboxRole()), _separatorRole = _interopRequireDefault(require_separatorRole()), _sliderRole = _interopRequireDefault(require_sliderRole()), _spinbuttonRole = _interopRequireDefault(require_spinbuttonRole()), _statusRole = _interopRequireDefault(require_statusRole()), _strongRole = _interopRequireDefault(require_strongRole()), _subscriptRole = _interopRequireDefault(require_subscriptRole()), _superscriptRole = _interopRequireDefault(require_superscriptRole()), _switchRole = _interopRequireDefault(require_switchRole()), _tabRole = _interopRequireDefault(require_tabRole()), _tableRole = _interopRequireDefault(require_tableRole()), _tablistRole = _interopRequireDefault(require_tablistRole()), _tabpanelRole = _interopRequireDefault(require_tabpanelRole()), _termRole = _interopRequireDefault(require_termRole()), _textboxRole = _interopRequireDefault(require_textboxRole()), _timeRole = _interopRequireDefault(require_timeRole()), _timerRole = _interopRequireDefault(require_timerRole()), _toolbarRole = _interopRequireDefault(require_toolbarRole()), _tooltipRole = _interopRequireDefault(require_tooltipRole()), _treeRole = _interopRequireDefault(require_treeRole()), _treegridRole = _interopRequireDefault(require_treegridRole()), _treeitemRole = _interopRequireDefault(require_treeitemRole());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["mark", _markRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]], _default2 = ariaLiteralRoles;
  exports.default = _default2;
} });
var require_docAbstractRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docAbstractRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "abstract [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = docAbstractRole;
  exports.default = _default2;
} });
var require_docAcknowledgmentsRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docAcknowledgmentsRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "acknowledgments [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docAcknowledgmentsRole;
  exports.default = _default2;
} });
var require_docAfterwordRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docAfterwordRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "afterword [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docAfterwordRole;
  exports.default = _default2;
} });
var require_docAppendixRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docAppendixRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "appendix [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docAppendixRole;
  exports.default = _default2;
} });
var require_docBacklinkRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docBacklinkRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-errormessage": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "referrer [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget", "command", "link"]] }, _default2 = docBacklinkRole;
  exports.default = _default2;
} });
var require_docBiblioentryRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docBiblioentryRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "EPUB biblioentry [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: ["doc-bibliography"], requiredContextRole: ["doc-bibliography"], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "listitem"]] }, _default2 = docBiblioentryRole;
  exports.default = _default2;
} });
var require_docBibliographyRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docBibliographyRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "bibliography [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["doc-biblioentry"]], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docBibliographyRole;
  exports.default = _default2;
} });
var require_docBibliorefRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docBibliorefRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-errormessage": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "biblioref [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget", "command", "link"]] }, _default2 = docBibliorefRole;
  exports.default = _default2;
} });
var require_docChapterRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docChapterRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "chapter [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docChapterRole;
  exports.default = _default2;
} });
var require_docColophonRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docColophonRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "colophon [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = docColophonRole;
  exports.default = _default2;
} });
var require_docConclusionRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docConclusionRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "conclusion [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docConclusionRole;
  exports.default = _default2;
} });
var require_docCoverRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docCoverRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "cover [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "img"]] }, _default2 = docCoverRole;
  exports.default = _default2;
} });
var require_docCreditRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docCreditRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "credit [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = docCreditRole;
  exports.default = _default2;
} });
var require_docCreditsRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docCreditsRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "credits [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docCreditsRole;
  exports.default = _default2;
} });
var require_docDedicationRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docDedicationRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "dedication [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = docDedicationRole;
  exports.default = _default2;
} });
var require_docEndnoteRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docEndnoteRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "rearnote [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: ["doc-endnotes"], requiredContextRole: ["doc-endnotes"], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "listitem"]] }, _default2 = docEndnoteRole;
  exports.default = _default2;
} });
var require_docEndnotesRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docEndnotesRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "rearnotes [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["doc-endnote"]], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docEndnotesRole;
  exports.default = _default2;
} });
var require_docEpigraphRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docEpigraphRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "epigraph [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = docEpigraphRole;
  exports.default = _default2;
} });
var require_docEpilogueRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docEpilogueRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "epilogue [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docEpilogueRole;
  exports.default = _default2;
} });
var require_docErrataRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docErrataRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "errata [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docErrataRole;
  exports.default = _default2;
} });
var require_docExampleRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docExampleRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = docExampleRole;
  exports.default = _default2;
} });
var require_docFootnoteRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docFootnoteRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "footnote [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = docFootnoteRole;
  exports.default = _default2;
} });
var require_docForewordRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docForewordRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "foreword [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docForewordRole;
  exports.default = _default2;
} });
var require_docGlossaryRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docGlossaryRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "glossary [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [["definition"], ["term"]], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docGlossaryRole;
  exports.default = _default2;
} });
var require_docGlossrefRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docGlossrefRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-errormessage": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "glossref [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget", "command", "link"]] }, _default2 = docGlossrefRole;
  exports.default = _default2;
} });
var require_docIndexRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docIndexRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "index [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark", "navigation"]] }, _default2 = docIndexRole;
  exports.default = _default2;
} });
var require_docIntroductionRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docIntroductionRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "introduction [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docIntroductionRole;
  exports.default = _default2;
} });
var require_docNoterefRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docNoterefRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-errormessage": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "noteref [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "widget", "command", "link"]] }, _default2 = docNoterefRole;
  exports.default = _default2;
} });
var require_docNoticeRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docNoticeRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "notice [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "note"]] }, _default2 = docNoticeRole;
  exports.default = _default2;
} });
var require_docPagebreakRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docPagebreakRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author"], prohibitedProps: [], props: { "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "pagebreak [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "separator"]] }, _default2 = docPagebreakRole;
  exports.default = _default2;
} });
var require_docPagelistRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docPagelistRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "page-list [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark", "navigation"]] }, _default2 = docPagelistRole;
  exports.default = _default2;
} });
var require_docPartRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docPartRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "part [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docPartRole;
  exports.default = _default2;
} });
var require_docPrefaceRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docPrefaceRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "preface [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docPrefaceRole;
  exports.default = _default2;
} });
var require_docPrologueRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docPrologueRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "prologue [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark"]] }, _default2 = docPrologueRole;
  exports.default = _default2;
} });
var require_docPullquoteRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docPullquoteRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: {}, relatedConcepts: [{ concept: { name: "pullquote [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["none"]] }, _default2 = docPullquoteRole;
  exports.default = _default2;
} });
var require_docQnaRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docQnaRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "qna [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section"]] }, _default2 = docQnaRole;
  exports.default = _default2;
} });
var require_docSubtitleRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docSubtitleRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "subtitle [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "sectionhead"]] }, _default2 = docSubtitleRole;
  exports.default = _default2;
} });
var require_docTipRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docTipRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "help [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "note"]] }, _default2 = docTipRole;
  exports.default = _default2;
} });
var require_docTocRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var docTocRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ concept: { name: "toc [EPUB-SSV]" }, module: "EPUB" }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "landmark", "navigation"]] }, _default2 = docTocRole;
  exports.default = _default2;
} });
var require_ariaDpubRoles = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var _docAbstractRole = _interopRequireDefault(require_docAbstractRole()), _docAcknowledgmentsRole = _interopRequireDefault(require_docAcknowledgmentsRole()), _docAfterwordRole = _interopRequireDefault(require_docAfterwordRole()), _docAppendixRole = _interopRequireDefault(require_docAppendixRole()), _docBacklinkRole = _interopRequireDefault(require_docBacklinkRole()), _docBiblioentryRole = _interopRequireDefault(require_docBiblioentryRole()), _docBibliographyRole = _interopRequireDefault(require_docBibliographyRole()), _docBibliorefRole = _interopRequireDefault(require_docBibliorefRole()), _docChapterRole = _interopRequireDefault(require_docChapterRole()), _docColophonRole = _interopRequireDefault(require_docColophonRole()), _docConclusionRole = _interopRequireDefault(require_docConclusionRole()), _docCoverRole = _interopRequireDefault(require_docCoverRole()), _docCreditRole = _interopRequireDefault(require_docCreditRole()), _docCreditsRole = _interopRequireDefault(require_docCreditsRole()), _docDedicationRole = _interopRequireDefault(require_docDedicationRole()), _docEndnoteRole = _interopRequireDefault(require_docEndnoteRole()), _docEndnotesRole = _interopRequireDefault(require_docEndnotesRole()), _docEpigraphRole = _interopRequireDefault(require_docEpigraphRole()), _docEpilogueRole = _interopRequireDefault(require_docEpilogueRole()), _docErrataRole = _interopRequireDefault(require_docErrataRole()), _docExampleRole = _interopRequireDefault(require_docExampleRole()), _docFootnoteRole = _interopRequireDefault(require_docFootnoteRole()), _docForewordRole = _interopRequireDefault(require_docForewordRole()), _docGlossaryRole = _interopRequireDefault(require_docGlossaryRole()), _docGlossrefRole = _interopRequireDefault(require_docGlossrefRole()), _docIndexRole = _interopRequireDefault(require_docIndexRole()), _docIntroductionRole = _interopRequireDefault(require_docIntroductionRole()), _docNoterefRole = _interopRequireDefault(require_docNoterefRole()), _docNoticeRole = _interopRequireDefault(require_docNoticeRole()), _docPagebreakRole = _interopRequireDefault(require_docPagebreakRole()), _docPagelistRole = _interopRequireDefault(require_docPagelistRole()), _docPartRole = _interopRequireDefault(require_docPartRole()), _docPrefaceRole = _interopRequireDefault(require_docPrefaceRole()), _docPrologueRole = _interopRequireDefault(require_docPrologueRole()), _docPullquoteRole = _interopRequireDefault(require_docPullquoteRole()), _docQnaRole = _interopRequireDefault(require_docQnaRole()), _docSubtitleRole = _interopRequireDefault(require_docSubtitleRole()), _docTipRole = _interopRequireDefault(require_docTipRole()), _docTocRole = _interopRequireDefault(require_docTocRole());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]], _default2 = ariaDpubRoles;
  exports.default = _default2;
} });
var require_graphicsDocumentRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var graphicsDocumentRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: false, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ module: "GRAPHICS", concept: { name: "graphics-object" } }, { module: "ARIA", concept: { name: "img" } }, { module: "ARIA", concept: { name: "article" } }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "document"]] }, _default2 = graphicsDocumentRole;
  exports.default = _default2;
} });
var require_graphicsObjectRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var graphicsObjectRole = { abstract: false, accessibleNameRequired: false, baseConcepts: [], childrenPresentational: false, nameFrom: ["author", "contents"], prohibitedProps: [], props: { "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [{ module: "GRAPHICS", concept: { name: "graphics-document" } }, { module: "ARIA", concept: { name: "group" } }, { module: "ARIA", concept: { name: "img" } }, { module: "GRAPHICS", concept: { name: "graphics-symbol" } }], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "group"]] }, _default2 = graphicsObjectRole;
  exports.default = _default2;
} });
var require_graphicsSymbolRole = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var graphicsSymbolRole = { abstract: false, accessibleNameRequired: true, baseConcepts: [], childrenPresentational: true, nameFrom: ["author"], prohibitedProps: [], props: { "aria-disabled": null, "aria-errormessage": null, "aria-expanded": null, "aria-haspopup": null, "aria-invalid": null }, relatedConcepts: [], requireContextRole: [], requiredContextRole: [], requiredOwnedElements: [], requiredProps: {}, superClass: [["roletype", "structure", "section", "img"]] }, _default2 = graphicsSymbolRole;
  exports.default = _default2;
} });
var require_ariaGraphicsRoles = __commonJS({ "../../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var _graphicsDocumentRole = _interopRequireDefault(require_graphicsDocumentRole()), _graphicsObjectRole = _interopRequireDefault(require_graphicsObjectRole()), _graphicsSymbolRole = _interopRequireDefault(require_graphicsSymbolRole());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ariaGraphicsRoles = [["graphics-document", _graphicsDocumentRole.default], ["graphics-object", _graphicsObjectRole.default], ["graphics-symbol", _graphicsSymbolRole.default]], _default2 = ariaGraphicsRoles;
  exports.default = _default2;
} });
var require_rolesMap = __commonJS({ "../../node_modules/aria-query/lib/rolesMap.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var _ariaAbstractRoles = _interopRequireDefault(require_ariaAbstractRoles()), _ariaLiteralRoles = _interopRequireDefault(require_ariaLiteralRoles()), _ariaDpubRoles = _interopRequireDefault(require_ariaDpubRoles()), _ariaGraphicsRoles = _interopRequireDefault(require_ariaGraphicsRoles()), _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperty5(obj, key2, value2) {
    return key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
  }
  function _createForOfIteratorHelper(o3, allowArrayLike) {
    var it2 = typeof Symbol < "u" && o3[Symbol.iterator] || o3["@@iterator"];
    if (!it2) {
      if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length == "number") {
        it2 && (o3 = it2);
        var i4 = 0, F5 = function() {
        };
        return { s: F5, n: function() {
          return i4 >= o3.length ? { done: true } : { done: false, value: o3[i4++] };
        }, e: function(_e2) {
          throw _e2;
        }, f: F5 };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function() {
      it2 = it2.call(o3);
    }, n: function() {
      var step = it2.next();
      return normalCompletion = step.done, step;
    }, e: function(_e3) {
      didErr = true, err = _e3;
    }, f: function() {
      try {
        !normalCompletion && it2.return != null && it2.return();
      } finally {
        if (didErr) throw err;
      }
    } };
  }
  function _slicedToArray(arr, i4) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i4) || _unsupportedIterableToArray(arr, i4) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function _unsupportedIterableToArray(o3, minLen) {
    if (o3) {
      if (typeof o3 == "string") return _arrayLikeToArray(o3, minLen);
      var n3 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n3 === "Object" && o3.constructor && (n3 = o3.constructor.name), n3 === "Map" || n3 === "Set") return Array.from(o3);
      if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return _arrayLikeToArray(o3, minLen);
    }
  }
  function _arrayLikeToArray(arr, len) {
    (len == null || len > arr.length) && (len = arr.length);
    for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++) arr2[i4] = arr[i4];
    return arr2;
  }
  function _iterableToArrayLimit(arr, i4) {
    var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i != null) {
      var _arr = [], _n3 = true, _d = false, _s2, _e2;
      try {
        for (_i = _i.call(arr); !(_n3 = (_s2 = _i.next()).done) && (_arr.push(_s2.value), !(i4 && _arr.length === i4)); _n3 = true) ;
      } catch (err) {
        _d = true, _e2 = err;
      } finally {
        try {
          !_n3 && _i.return != null && _i.return();
        } finally {
          if (_d) throw _e2;
        }
      }
      return _arr;
    }
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  var roles3 = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
  roles3.forEach(function(_ref) {
    var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1], _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var superClassIter = _step.value, _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
        try {
          var _loop = function() {
            var superClassName = _step2.value, superClassRoleTuple = roles3.find(function(_ref3) {
              var _ref4 = _slicedToArray(_ref3, 1), name2 = _ref4[0];
              return name2 === superClassName;
            });
            if (superClassRoleTuple) for (var superClassDefinition = superClassRoleTuple[1], _i2 = 0, _Object$keys = Object.keys(superClassDefinition.props); _i2 < _Object$keys.length; _i2++) {
              var prop = _Object$keys[_i2];
              Object.prototype.hasOwnProperty.call(roleDefinition.props, prop) || Object.assign(roleDefinition.props, _defineProperty5({}, prop, superClassDefinition.props[prop]));
            }
          };
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) _loop();
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  });
  var rolesMap = { entries: function() {
    return roles3;
  }, forEach: function(fn3) {
    var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _iterator3 = _createForOfIteratorHelper(roles3), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var _step3$value = _slicedToArray(_step3.value, 2), key2 = _step3$value[0], values = _step3$value[1];
        fn3.call(thisArg, values, key2, roles3);
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }, get: function(key2) {
    var item = roles3.find(function(tuple) {
      return tuple[0] === key2;
    });
    return item && item[1];
  }, has: function(key2) {
    return !!rolesMap.get(key2);
  }, keys: function() {
    return roles3.map(function(_ref5) {
      var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
      return key2;
    });
  }, values: function() {
    return roles3.map(function(_ref7) {
      var _ref8 = _slicedToArray(_ref7, 2), values2 = _ref8[1];
      return values2;
    });
  } }, _default2 = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
  exports.default = _default2;
} });
var require_lite = __commonJS({ "../../node_modules/dequal/lite/index.js"(exports) {
  var has = Object.prototype.hasOwnProperty;
  function dequal(foo, bar) {
    var ctor, len;
    if (foo === bar) return true;
    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
      if (ctor === Date) return foo.getTime() === bar.getTime();
      if (ctor === RegExp) return foo.toString() === bar.toString();
      if (ctor === Array) {
        if ((len = foo.length) === bar.length) for (; len-- && dequal(foo[len], bar[len]); ) ;
        return len === -1;
      }
      if (!ctor || typeof foo == "object") {
        len = 0;
        for (ctor in foo) if (has.call(foo, ctor) && ++len && !has.call(bar, ctor) || !(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
        return Object.keys(bar).length === len;
      }
    }
    return foo !== foo && bar !== bar;
  }
  exports.dequal = dequal;
} });
var require_elementRoleMap = __commonJS({ "../../node_modules/aria-query/lib/elementRoleMap.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var _lite = require_lite(), _iterationDecorator = _interopRequireDefault(require_iterationDecorator()), _rolesMap = _interopRequireDefault(require_rolesMap());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i22) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i22) || _unsupportedIterableToArray(arr, i22) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function _iterableToArrayLimit(arr, i22) {
    var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i != null) {
      var _arr = [], _n3 = true, _d = false, _s2, _e2;
      try {
        for (_i = _i.call(arr); !(_n3 = (_s2 = _i.next()).done) && (_arr.push(_s2.value), !(i22 && _arr.length === i22)); _n3 = true) ;
      } catch (err) {
        _d = true, _e2 = err;
      } finally {
        try {
          !_n3 && _i.return != null && _i.return();
        } finally {
          if (_d) throw _e2;
        }
      }
      return _arr;
    }
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _createForOfIteratorHelper(o3, allowArrayLike) {
    var it2 = typeof Symbol < "u" && o3[Symbol.iterator] || o3["@@iterator"];
    if (!it2) {
      if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length == "number") {
        it2 && (o3 = it2);
        var i22 = 0, F5 = function() {
        };
        return { s: F5, n: function() {
          return i22 >= o3.length ? { done: true } : { done: false, value: o3[i22++] };
        }, e: function(_e2) {
          throw _e2;
        }, f: F5 };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function() {
      it2 = it2.call(o3);
    }, n: function() {
      var step = it2.next();
      return normalCompletion = step.done, step;
    }, e: function(_e3) {
      didErr = true, err = _e3;
    }, f: function() {
      try {
        !normalCompletion && it2.return != null && it2.return();
      } finally {
        if (didErr) throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o3, minLen) {
    if (o3) {
      if (typeof o3 == "string") return _arrayLikeToArray(o3, minLen);
      var n3 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n3 === "Object" && o3.constructor && (n3 = o3.constructor.name), n3 === "Map" || n3 === "Set") return Array.from(o3);
      if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return _arrayLikeToArray(o3, minLen);
    }
  }
  function _arrayLikeToArray(arr, len) {
    (len == null || len > arr.length) && (len = arr.length);
    for (var i22 = 0, arr2 = new Array(len); i22 < len; i22++) arr2[i22] = arr[i22];
    return arr2;
  }
  var elementRoles3 = [], keys2 = _rolesMap.default.keys();
  for (i4 = 0; i4 < keys2.length; i4++) if (key2 = keys2[i4], role = _rolesMap.default.get(key2), role) for (concepts = [].concat(role.baseConcepts, role.relatedConcepts), k22 = 0; k22 < concepts.length; k22++) relation = concepts[k22], relation.module === "HTML" && function() {
    var concept = relation.concept;
    if (concept) {
      var elementRoleRelation = elementRoles3.find(function(relation2) {
        return (0, _lite.dequal)(relation2, concept);
      }), roles3;
      elementRoleRelation ? roles3 = elementRoleRelation[1] : roles3 = [];
      for (var isUnique = true, _i = 0; _i < roles3.length; _i++) if (roles3[_i] === key2) {
        isUnique = false;
        break;
      }
      isUnique && roles3.push(key2), elementRoles3.push([concept, roles3]);
    }
  }();
  var key2, role, concepts, relation, k22, i4, elementRoleMap = { entries: function() {
    return elementRoles3;
  }, forEach: function(fn3) {
    var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _iterator = _createForOfIteratorHelper(elementRoles3), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _slicedToArray(_step.value, 2), _key = _step$value[0], values = _step$value[1];
        fn3.call(thisArg, values, _key, elementRoles3);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }, get: function(key22) {
    var item = elementRoles3.find(function(tuple) {
      return key22.name === tuple[0].name && (0, _lite.dequal)(key22.attributes, tuple[0].attributes);
    });
    return item && item[1];
  }, has: function(key22) {
    return !!elementRoleMap.get(key22);
  }, keys: function() {
    return elementRoles3.map(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 1), key22 = _ref2[0];
      return key22;
    });
  }, values: function() {
    return elementRoles3.map(function(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
      return values2;
    });
  } }, _default2 = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
  exports.default = _default2;
} });
var require_roleElementMap = __commonJS({ "../../node_modules/aria-query/lib/roleElementMap.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = void 0;
  var _iterationDecorator = _interopRequireDefault(require_iterationDecorator()), _rolesMap = _interopRequireDefault(require_rolesMap());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i22) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i22) || _unsupportedIterableToArray(arr, i22) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function _iterableToArrayLimit(arr, i22) {
    var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i != null) {
      var _arr = [], _n3 = true, _d = false, _s2, _e2;
      try {
        for (_i = _i.call(arr); !(_n3 = (_s2 = _i.next()).done) && (_arr.push(_s2.value), !(i22 && _arr.length === i22)); _n3 = true) ;
      } catch (err) {
        _d = true, _e2 = err;
      } finally {
        try {
          !_n3 && _i.return != null && _i.return();
        } finally {
          if (_d) throw _e2;
        }
      }
      return _arr;
    }
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _createForOfIteratorHelper(o3, allowArrayLike) {
    var it2 = typeof Symbol < "u" && o3[Symbol.iterator] || o3["@@iterator"];
    if (!it2) {
      if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length == "number") {
        it2 && (o3 = it2);
        var i22 = 0, F5 = function() {
        };
        return { s: F5, n: function() {
          return i22 >= o3.length ? { done: true } : { done: false, value: o3[i22++] };
        }, e: function(_e2) {
          throw _e2;
        }, f: F5 };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function() {
      it2 = it2.call(o3);
    }, n: function() {
      var step = it2.next();
      return normalCompletion = step.done, step;
    }, e: function(_e3) {
      didErr = true, err = _e3;
    }, f: function() {
      try {
        !normalCompletion && it2.return != null && it2.return();
      } finally {
        if (didErr) throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o3, minLen) {
    if (o3) {
      if (typeof o3 == "string") return _arrayLikeToArray(o3, minLen);
      var n3 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n3 === "Object" && o3.constructor && (n3 = o3.constructor.name), n3 === "Map" || n3 === "Set") return Array.from(o3);
      if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return _arrayLikeToArray(o3, minLen);
    }
  }
  function _arrayLikeToArray(arr, len) {
    (len == null || len > arr.length) && (len = arr.length);
    for (var i22 = 0, arr2 = new Array(len); i22 < len; i22++) arr2[i22] = arr[i22];
    return arr2;
  }
  var roleElement = [], keys2 = _rolesMap.default.keys();
  for (i4 = 0; i4 < keys2.length; i4++) if (key2 = keys2[i4], role = _rolesMap.default.get(key2), relationConcepts = [], role) {
    for (concepts = [].concat(role.baseConcepts, role.relatedConcepts), k22 = 0; k22 < concepts.length; k22++) relation = concepts[k22], relation.module === "HTML" && (concept = relation.concept, concept != null && relationConcepts.push(concept));
    relationConcepts.length > 0 && roleElement.push([key2, relationConcepts]);
  }
  var key2, role, relationConcepts, concepts, relation, concept, k22, i4, roleElementMap = { entries: function() {
    return roleElement;
  }, forEach: function(fn3) {
    var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _iterator = _createForOfIteratorHelper(roleElement), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _slicedToArray(_step.value, 2), _key = _step$value[0], values = _step$value[1];
        fn3.call(thisArg, values, _key, roleElement);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }, get: function(key22) {
    var item = roleElement.find(function(tuple) {
      return tuple[0] === key22;
    });
    return item && item[1];
  }, has: function(key22) {
    return !!roleElementMap.get(key22);
  }, keys: function() {
    return roleElement.map(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 1), key22 = _ref2[0];
      return key22;
    });
  }, values: function() {
    return roleElement.map(function(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
      return values2;
    });
  } }, _default2 = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
  exports.default = _default2;
} });
var require_lib = __commonJS({ "../../node_modules/aria-query/lib/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.roles = exports.roleElements = exports.elementRoles = exports.dom = exports.aria = void 0;
  var _ariaPropsMap = _interopRequireDefault(require_ariaPropsMap()), _domMap = _interopRequireDefault(require_domMap()), _rolesMap = _interopRequireDefault(require_rolesMap()), _elementRoleMap = _interopRequireDefault(require_elementRoleMap()), _roleElementMap = _interopRequireDefault(require_roleElementMap());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var aria = _ariaPropsMap.default;
  exports.aria = aria;
  var dom = _domMap.default;
  exports.dom = dom;
  var roles3 = _rolesMap.default;
  exports.roles = roles3;
  var elementRoles3 = _elementRoleMap.default;
  exports.elementRoles = elementRoles3;
  var roleElements2 = _roleElementMap.default;
  exports.roleElements = roleElements2;
} });
var require_color_name = __commonJS({ "../../node_modules/color-name/index.js"(exports, module2) {
  module2.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
} });
var require_conversions = __commonJS({ "../../node_modules/color-convert/conversions.js"(exports, module2) {
  var cssKeywords = require_color_name(), reverseKeywords = {};
  for (let key2 of Object.keys(cssKeywords)) reverseKeywords[cssKeywords[key2]] = key2;
  var convert = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
  module2.exports = convert;
  for (let model of Object.keys(convert)) {
    if (!("channels" in convert[model])) throw new Error("missing channels property: " + model);
    if (!("labels" in convert[model])) throw new Error("missing channel labels property: " + model);
    if (convert[model].labels.length !== convert[model].channels) throw new Error("channel and label counts mismatch: " + model);
    let { channels, labels } = convert[model];
    delete convert[model].channels, delete convert[model].labels, Object.defineProperty(convert[model], "channels", { value: channels }), Object.defineProperty(convert[model], "labels", { value: labels });
  }
  convert.rgb.hsl = function(rgb) {
    let r4 = rgb[0] / 255, g3 = rgb[1] / 255, b6 = rgb[2] / 255, min = Math.min(r4, g3, b6), max = Math.max(r4, g3, b6), delta = max - min, h22, s4;
    max === min ? h22 = 0 : r4 === max ? h22 = (g3 - b6) / delta : g3 === max ? h22 = 2 + (b6 - r4) / delta : b6 === max && (h22 = 4 + (r4 - g3) / delta), h22 = Math.min(h22 * 60, 360), h22 < 0 && (h22 += 360);
    let l3 = (min + max) / 2;
    return max === min ? s4 = 0 : l3 <= 0.5 ? s4 = delta / (max + min) : s4 = delta / (2 - max - min), [h22, s4 * 100, l3 * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif, gdif, bdif, h22, s4, r4 = rgb[0] / 255, g3 = rgb[1] / 255, b6 = rgb[2] / 255, v6 = Math.max(r4, g3, b6), diff22 = v6 - Math.min(r4, g3, b6), diffc = function(c3) {
      return (v6 - c3) / 6 / diff22 + 1 / 2;
    };
    return diff22 === 0 ? (h22 = 0, s4 = 0) : (s4 = diff22 / v6, rdif = diffc(r4), gdif = diffc(g3), bdif = diffc(b6), r4 === v6 ? h22 = bdif - gdif : g3 === v6 ? h22 = 1 / 3 + rdif - bdif : b6 === v6 && (h22 = 2 / 3 + gdif - rdif), h22 < 0 ? h22 += 1 : h22 > 1 && (h22 -= 1)), [h22 * 360, s4 * 100, v6 * 100];
  };
  convert.rgb.hwb = function(rgb) {
    let r4 = rgb[0], g3 = rgb[1], b6 = rgb[2], h22 = convert.rgb.hsl(rgb)[0], w22 = 1 / 255 * Math.min(r4, Math.min(g3, b6));
    return b6 = 1 - 1 / 255 * Math.max(r4, Math.max(g3, b6)), [h22, w22 * 100, b6 * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    let r4 = rgb[0] / 255, g3 = rgb[1] / 255, b6 = rgb[2] / 255, k22 = Math.min(1 - r4, 1 - g3, 1 - b6), c3 = (1 - r4 - k22) / (1 - k22) || 0, m22 = (1 - g3 - k22) / (1 - k22) || 0, y22 = (1 - b6 - k22) / (1 - k22) || 0;
    return [c3 * 100, m22 * 100, y22 * 100, k22 * 100];
  };
  function comparativeDistance(x22, y22) {
    return (x22[0] - y22[0]) ** 2 + (x22[1] - y22[1]) ** 2 + (x22[2] - y22[2]) ** 2;
  }
  convert.rgb.keyword = function(rgb) {
    let reversed = reverseKeywords[rgb];
    if (reversed) return reversed;
    let currentClosestDistance = 1 / 0, currentClosestKeyword;
    for (let keyword of Object.keys(cssKeywords)) {
      let value2 = cssKeywords[keyword], distance = comparativeDistance(rgb, value2);
      distance < currentClosestDistance && (currentClosestDistance = distance, currentClosestKeyword = keyword);
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    let r4 = rgb[0] / 255, g3 = rgb[1] / 255, b6 = rgb[2] / 255;
    r4 = r4 > 0.04045 ? ((r4 + 0.055) / 1.055) ** 2.4 : r4 / 12.92, g3 = g3 > 0.04045 ? ((g3 + 0.055) / 1.055) ** 2.4 : g3 / 12.92, b6 = b6 > 0.04045 ? ((b6 + 0.055) / 1.055) ** 2.4 : b6 / 12.92;
    let x22 = r4 * 0.4124 + g3 * 0.3576 + b6 * 0.1805, y22 = r4 * 0.2126 + g3 * 0.7152 + b6 * 0.0722, z5 = r4 * 0.0193 + g3 * 0.1192 + b6 * 0.9505;
    return [x22 * 100, y22 * 100, z5 * 100];
  };
  convert.rgb.lab = function(rgb) {
    let xyz = convert.rgb.xyz(rgb), x22 = xyz[0], y22 = xyz[1], z5 = xyz[2];
    x22 /= 95.047, y22 /= 100, z5 /= 108.883, x22 = x22 > 8856e-6 ? x22 ** (1 / 3) : 7.787 * x22 + 16 / 116, y22 = y22 > 8856e-6 ? y22 ** (1 / 3) : 7.787 * y22 + 16 / 116, z5 = z5 > 8856e-6 ? z5 ** (1 / 3) : 7.787 * z5 + 16 / 116;
    let l3 = 116 * y22 - 16, a22 = 500 * (x22 - y22), b6 = 200 * (y22 - z5);
    return [l3, a22, b6];
  };
  convert.hsl.rgb = function(hsl) {
    let h22 = hsl[0] / 360, s4 = hsl[1] / 100, l3 = hsl[2] / 100, t22, t32, val;
    if (s4 === 0) return val = l3 * 255, [val, val, val];
    l3 < 0.5 ? t22 = l3 * (1 + s4) : t22 = l3 + s4 - l3 * s4;
    let t1 = 2 * l3 - t22, rgb = [0, 0, 0];
    for (let i4 = 0; i4 < 3; i4++) t32 = h22 + 1 / 3 * -(i4 - 1), t32 < 0 && t32++, t32 > 1 && t32--, 6 * t32 < 1 ? val = t1 + (t22 - t1) * 6 * t32 : 2 * t32 < 1 ? val = t22 : 3 * t32 < 2 ? val = t1 + (t22 - t1) * (2 / 3 - t32) * 6 : val = t1, rgb[i4] = val * 255;
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    let h22 = hsl[0], s4 = hsl[1] / 100, l3 = hsl[2] / 100, smin = s4, lmin = Math.max(l3, 0.01);
    l3 *= 2, s4 *= l3 <= 1 ? l3 : 2 - l3, smin *= lmin <= 1 ? lmin : 2 - lmin;
    let v6 = (l3 + s4) / 2, sv = l3 === 0 ? 2 * smin / (lmin + smin) : 2 * s4 / (l3 + s4);
    return [h22, sv * 100, v6 * 100];
  };
  convert.hsv.rgb = function(hsv) {
    let h22 = hsv[0] / 60, s4 = hsv[1] / 100, v6 = hsv[2] / 100, hi = Math.floor(h22) % 6, f42 = h22 - Math.floor(h22), p32 = 255 * v6 * (1 - s4), q5 = 255 * v6 * (1 - s4 * f42), t4 = 255 * v6 * (1 - s4 * (1 - f42));
    switch (v6 *= 255, hi) {
      case 0:
        return [v6, t4, p32];
      case 1:
        return [q5, v6, p32];
      case 2:
        return [p32, v6, t4];
      case 3:
        return [p32, q5, v6];
      case 4:
        return [t4, p32, v6];
      case 5:
        return [v6, p32, q5];
    }
  };
  convert.hsv.hsl = function(hsv) {
    let h22 = hsv[0], s4 = hsv[1] / 100, v6 = hsv[2] / 100, vmin = Math.max(v6, 0.01), sl, l3;
    l3 = (2 - s4) * v6;
    let lmin = (2 - s4) * vmin;
    return sl = s4 * vmin, sl /= lmin <= 1 ? lmin : 2 - lmin, sl = sl || 0, l3 /= 2, [h22, sl * 100, l3 * 100];
  };
  convert.hwb.rgb = function(hwb) {
    let h22 = hwb[0] / 360, wh = hwb[1] / 100, bl = hwb[2] / 100, ratio = wh + bl, f42;
    ratio > 1 && (wh /= ratio, bl /= ratio);
    let i4 = Math.floor(6 * h22), v6 = 1 - bl;
    f42 = 6 * h22 - i4, i4 & 1 && (f42 = 1 - f42);
    let n3 = wh + f42 * (v6 - wh), r4, g3, b6;
    switch (i4) {
      default:
      case 6:
      case 0:
        r4 = v6, g3 = n3, b6 = wh;
        break;
      case 1:
        r4 = n3, g3 = v6, b6 = wh;
        break;
      case 2:
        r4 = wh, g3 = v6, b6 = n3;
        break;
      case 3:
        r4 = wh, g3 = n3, b6 = v6;
        break;
      case 4:
        r4 = n3, g3 = wh, b6 = v6;
        break;
      case 5:
        r4 = v6, g3 = wh, b6 = n3;
        break;
    }
    return [r4 * 255, g3 * 255, b6 * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    let c3 = cmyk[0] / 100, m22 = cmyk[1] / 100, y22 = cmyk[2] / 100, k22 = cmyk[3] / 100, r4 = 1 - Math.min(1, c3 * (1 - k22) + k22), g3 = 1 - Math.min(1, m22 * (1 - k22) + k22), b6 = 1 - Math.min(1, y22 * (1 - k22) + k22);
    return [r4 * 255, g3 * 255, b6 * 255];
  };
  convert.xyz.rgb = function(xyz) {
    let x22 = xyz[0] / 100, y22 = xyz[1] / 100, z5 = xyz[2] / 100, r4, g3, b6;
    return r4 = x22 * 3.2406 + y22 * -1.5372 + z5 * -0.4986, g3 = x22 * -0.9689 + y22 * 1.8758 + z5 * 0.0415, b6 = x22 * 0.0557 + y22 * -0.204 + z5 * 1.057, r4 = r4 > 31308e-7 ? 1.055 * r4 ** (1 / 2.4) - 0.055 : r4 * 12.92, g3 = g3 > 31308e-7 ? 1.055 * g3 ** (1 / 2.4) - 0.055 : g3 * 12.92, b6 = b6 > 31308e-7 ? 1.055 * b6 ** (1 / 2.4) - 0.055 : b6 * 12.92, r4 = Math.min(Math.max(0, r4), 1), g3 = Math.min(Math.max(0, g3), 1), b6 = Math.min(Math.max(0, b6), 1), [r4 * 255, g3 * 255, b6 * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x22 = xyz[0], y22 = xyz[1], z5 = xyz[2];
    x22 /= 95.047, y22 /= 100, z5 /= 108.883, x22 = x22 > 8856e-6 ? x22 ** (1 / 3) : 7.787 * x22 + 16 / 116, y22 = y22 > 8856e-6 ? y22 ** (1 / 3) : 7.787 * y22 + 16 / 116, z5 = z5 > 8856e-6 ? z5 ** (1 / 3) : 7.787 * z5 + 16 / 116;
    let l3 = 116 * y22 - 16, a22 = 500 * (x22 - y22), b6 = 200 * (y22 - z5);
    return [l3, a22, b6];
  };
  convert.lab.xyz = function(lab) {
    let l3 = lab[0], a22 = lab[1], b6 = lab[2], x22, y22, z5;
    y22 = (l3 + 16) / 116, x22 = a22 / 500 + y22, z5 = y22 - b6 / 200;
    let y222 = y22 ** 3, x222 = x22 ** 3, z22 = z5 ** 3;
    return y22 = y222 > 8856e-6 ? y222 : (y22 - 16 / 116) / 7.787, x22 = x222 > 8856e-6 ? x222 : (x22 - 16 / 116) / 7.787, z5 = z22 > 8856e-6 ? z22 : (z5 - 16 / 116) / 7.787, x22 *= 95.047, y22 *= 100, z5 *= 108.883, [x22, y22, z5];
  };
  convert.lab.lch = function(lab) {
    let l3 = lab[0], a22 = lab[1], b6 = lab[2], h22;
    h22 = Math.atan2(b6, a22) * 360 / 2 / Math.PI, h22 < 0 && (h22 += 360);
    let c3 = Math.sqrt(a22 * a22 + b6 * b6);
    return [l3, c3, h22];
  };
  convert.lch.lab = function(lch) {
    let l3 = lch[0], c3 = lch[1], hr4 = lch[2] / 360 * 2 * Math.PI, a22 = c3 * Math.cos(hr4), b6 = c3 * Math.sin(hr4);
    return [l3, a22, b6];
  };
  convert.rgb.ansi16 = function(args2, saturation = null) {
    let [r4, g3, b6] = args2, value2 = saturation === null ? convert.rgb.hsv(args2)[2] : saturation;
    if (value2 = Math.round(value2 / 50), value2 === 0) return 30;
    let ansi = 30 + (Math.round(b6 / 255) << 2 | Math.round(g3 / 255) << 1 | Math.round(r4 / 255));
    return value2 === 2 && (ansi += 60), ansi;
  };
  convert.hsv.ansi16 = function(args2) {
    return convert.rgb.ansi16(convert.hsv.rgb(args2), args2[2]);
  };
  convert.rgb.ansi256 = function(args2) {
    let r4 = args2[0], g3 = args2[1], b6 = args2[2];
    return r4 === g3 && g3 === b6 ? r4 < 8 ? 16 : r4 > 248 ? 231 : Math.round((r4 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(r4 / 255 * 5) + 6 * Math.round(g3 / 255 * 5) + Math.round(b6 / 255 * 5);
  };
  convert.ansi16.rgb = function(args2) {
    let color = args2 % 10;
    if (color === 0 || color === 7) return args2 > 50 && (color += 3.5), color = color / 10.5 * 255, [color, color, color];
    let mult = (~~(args2 > 50) + 1) * 0.5, r4 = (color & 1) * mult * 255, g3 = (color >> 1 & 1) * mult * 255, b6 = (color >> 2 & 1) * mult * 255;
    return [r4, g3, b6];
  };
  convert.ansi256.rgb = function(args2) {
    if (args2 >= 232) {
      let c3 = (args2 - 232) * 10 + 8;
      return [c3, c3, c3];
    }
    args2 -= 16;
    let rem, r4 = Math.floor(args2 / 36) / 5 * 255, g3 = Math.floor((rem = args2 % 36) / 6) / 5 * 255, b6 = rem % 6 / 5 * 255;
    return [r4, g3, b6];
  };
  convert.rgb.hex = function(args2) {
    let string = (((Math.round(args2[0]) & 255) << 16) + ((Math.round(args2[1]) & 255) << 8) + (Math.round(args2[2]) & 255)).toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args2) {
    let match = args2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) return [0, 0, 0];
    let colorString = match[0];
    match[0].length === 3 && (colorString = colorString.split("").map((char) => char + char).join(""));
    let integer = parseInt(colorString, 16), r4 = integer >> 16 & 255, g3 = integer >> 8 & 255, b6 = integer & 255;
    return [r4, g3, b6];
  };
  convert.rgb.hcg = function(rgb) {
    let r4 = rgb[0] / 255, g3 = rgb[1] / 255, b6 = rgb[2] / 255, max = Math.max(Math.max(r4, g3), b6), min = Math.min(Math.min(r4, g3), b6), chroma = max - min, grayscale, hue;
    return chroma < 1 ? grayscale = min / (1 - chroma) : grayscale = 0, chroma <= 0 ? hue = 0 : max === r4 ? hue = (g3 - b6) / chroma % 6 : max === g3 ? hue = 2 + (b6 - r4) / chroma : hue = 4 + (r4 - g3) / chroma, hue /= 6, hue %= 1, [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    let s4 = hsl[1] / 100, l3 = hsl[2] / 100, c3 = l3 < 0.5 ? 2 * s4 * l3 : 2 * s4 * (1 - l3), f42 = 0;
    return c3 < 1 && (f42 = (l3 - 0.5 * c3) / (1 - c3)), [hsl[0], c3 * 100, f42 * 100];
  };
  convert.hsv.hcg = function(hsv) {
    let s4 = hsv[1] / 100, v6 = hsv[2] / 100, c3 = s4 * v6, f42 = 0;
    return c3 < 1 && (f42 = (v6 - c3) / (1 - c3)), [hsv[0], c3 * 100, f42 * 100];
  };
  convert.hcg.rgb = function(hcg) {
    let h22 = hcg[0] / 360, c3 = hcg[1] / 100, g3 = hcg[2] / 100;
    if (c3 === 0) return [g3 * 255, g3 * 255, g3 * 255];
    let pure = [0, 0, 0], hi = h22 % 1 * 6, v6 = hi % 1, w22 = 1 - v6, mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1, pure[1] = v6, pure[2] = 0;
        break;
      case 1:
        pure[0] = w22, pure[1] = 1, pure[2] = 0;
        break;
      case 2:
        pure[0] = 0, pure[1] = 1, pure[2] = v6;
        break;
      case 3:
        pure[0] = 0, pure[1] = w22, pure[2] = 1;
        break;
      case 4:
        pure[0] = v6, pure[1] = 0, pure[2] = 1;
        break;
      default:
        pure[0] = 1, pure[1] = 0, pure[2] = w22;
    }
    return mg = (1 - c3) * g3, [(c3 * pure[0] + mg) * 255, (c3 * pure[1] + mg) * 255, (c3 * pure[2] + mg) * 255];
  };
  convert.hcg.hsv = function(hcg) {
    let c3 = hcg[1] / 100, g3 = hcg[2] / 100, v6 = c3 + g3 * (1 - c3), f42 = 0;
    return v6 > 0 && (f42 = c3 / v6), [hcg[0], f42 * 100, v6 * 100];
  };
  convert.hcg.hsl = function(hcg) {
    let c3 = hcg[1] / 100, l3 = hcg[2] / 100 * (1 - c3) + 0.5 * c3, s4 = 0;
    return l3 > 0 && l3 < 0.5 ? s4 = c3 / (2 * l3) : l3 >= 0.5 && l3 < 1 && (s4 = c3 / (2 * (1 - l3))), [hcg[0], s4 * 100, l3 * 100];
  };
  convert.hcg.hwb = function(hcg) {
    let c3 = hcg[1] / 100, g3 = hcg[2] / 100, v6 = c3 + g3 * (1 - c3);
    return [hcg[0], (v6 - c3) * 100, (1 - v6) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    let w22 = hwb[1] / 100, v6 = 1 - hwb[2] / 100, c3 = v6 - w22, g3 = 0;
    return c3 < 1 && (g3 = (v6 - c3) / (1 - c3)), [hwb[0], c3 * 100, g3 * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args2) {
    return [args2[0] / 100 * 255, args2[0] / 100 * 255, args2[0] / 100 * 255];
  };
  convert.gray.hsl = function(args2) {
    return [0, 0, args2[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    let val = Math.round(gray[0] / 100 * 255) & 255, string = ((val << 16) + (val << 8) + val).toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    return [(rgb[0] + rgb[1] + rgb[2]) / 3 / 255 * 100];
  };
} });
var require_route = __commonJS({ "../../node_modules/color-convert/route.js"(exports, module2) {
  var conversions = require_conversions();
  function buildGraph() {
    let graph = {}, models = Object.keys(conversions);
    for (let len = models.length, i4 = 0; i4 < len; i4++) graph[models[i4]] = { distance: -1, parent: null };
    return graph;
  }
  function deriveBFS(fromModel) {
    let graph = buildGraph(), queue = [fromModel];
    for (graph[fromModel].distance = 0; queue.length; ) {
      let current = queue.pop(), adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i4 = 0; i4 < len; i4++) {
        let adjacent = adjacents[i4], node = graph[adjacent];
        node.distance === -1 && (node.distance = graph[current].distance + 1, node.parent = current, queue.unshift(adjacent));
      }
    }
    return graph;
  }
  function link(from, to3) {
    return function(args2) {
      return to3(from(args2));
    };
  }
  function wrapConversion(toModel, graph) {
    let path = [graph[toModel].parent, toModel], fn3 = conversions[graph[toModel].parent][toModel], cur = graph[toModel].parent;
    for (; graph[cur].parent; ) path.unshift(graph[cur].parent), fn3 = link(conversions[graph[cur].parent][cur], fn3), cur = graph[cur].parent;
    return fn3.conversion = path, fn3;
  }
  module2.exports = function(fromModel) {
    let graph = deriveBFS(fromModel), conversion = {}, models = Object.keys(graph);
    for (let len = models.length, i4 = 0; i4 < len; i4++) {
      let toModel = models[i4];
      graph[toModel].parent !== null && (conversion[toModel] = wrapConversion(toModel, graph));
    }
    return conversion;
  };
} });
var require_color_convert = __commonJS({ "../../node_modules/color-convert/index.js"(exports, module2) {
  var conversions = require_conversions(), route = require_route(), convert = {}, models = Object.keys(conversions);
  function wrapRaw(fn3) {
    let wrappedFn = function(...args2) {
      let arg0 = args2[0];
      return arg0 == null ? arg0 : (arg0.length > 1 && (args2 = arg0), fn3(args2));
    };
    return "conversion" in fn3 && (wrappedFn.conversion = fn3.conversion), wrappedFn;
  }
  function wrapRounded(fn3) {
    let wrappedFn = function(...args2) {
      let arg0 = args2[0];
      if (arg0 == null) return arg0;
      arg0.length > 1 && (args2 = arg0);
      let result2 = fn3(args2);
      if (typeof result2 == "object") for (let len = result2.length, i4 = 0; i4 < len; i4++) result2[i4] = Math.round(result2[i4]);
      return result2;
    };
    return "conversion" in fn3 && (wrappedFn.conversion = fn3.conversion), wrappedFn;
  }
  models.forEach((fromModel) => {
    convert[fromModel] = {}, Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels }), Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
    let routes = route(fromModel);
    Object.keys(routes).forEach((toModel) => {
      let fn3 = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn3), convert[fromModel][toModel].raw = wrapRaw(fn3);
    });
  });
  module2.exports = convert;
} });
var require_ansi_styles = __commonJS({ "../../node_modules/ansi-styles/index.js"(exports, module2) {
  var wrapAnsi16 = (fn3, offset) => (...args2) => `\x1B[${fn3(...args2) + offset}m`, wrapAnsi256 = (fn3, offset) => (...args2) => {
    let code = fn3(...args2);
    return `\x1B[${38 + offset};5;${code}m`;
  }, wrapAnsi16m = (fn3, offset) => (...args2) => {
    let rgb = fn3(...args2);
    return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  }, ansi2ansi = (n3) => n3, rgb2rgb = (r4, g3, b6) => [r4, g3, b6], setLazyProperty = (object, property, get2) => {
    Object.defineProperty(object, property, { get: () => {
      let value2 = get2();
      return Object.defineProperty(object, property, { value: value2, enumerable: true, configurable: true }), value2;
    }, enumerable: true, configurable: true });
  }, colorConvert, makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    colorConvert === void 0 && (colorConvert = require_color_convert());
    let offset = isBackground ? 10 : 0, styles3 = {};
    for (let [sourceSpace, suite] of Object.entries(colorConvert)) {
      let name2 = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      sourceSpace === targetSpace ? styles3[name2] = wrap(identity, offset) : typeof suite == "object" && (styles3[name2] = wrap(suite[targetSpace], offset));
    }
    return styles3;
  };
  function assembleStyles() {
    let codes = /* @__PURE__ */ new Map(), styles3 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
    styles3.color.gray = styles3.color.blackBright, styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright, styles3.color.grey = styles3.color.blackBright, styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
    for (let [groupName, group] of Object.entries(styles3)) {
      for (let [styleName, style] of Object.entries(group)) styles3[styleName] = { open: `\x1B[${style[0]}m`, close: `\x1B[${style[1]}m` }, group[styleName] = styles3[styleName], codes.set(style[0], style[1]);
      Object.defineProperty(styles3, groupName, { value: group, enumerable: false });
    }
    return Object.defineProperty(styles3, "codes", { value: codes, enumerable: false }), styles3.color.close = "\x1B[39m", styles3.bgColor.close = "\x1B[49m", setLazyProperty(styles3.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false)), setLazyProperty(styles3.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false)), setLazyProperty(styles3.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false)), setLazyProperty(styles3.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true)), setLazyProperty(styles3.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true)), setLazyProperty(styles3.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true)), styles3;
  }
  Object.defineProperty(module2, "exports", { enumerable: true, get: assembleStyles });
} });
var require_browser = __commonJS({ "../../node_modules/supports-color/browser.js"(exports, module2) {
  module2.exports = { stdout: false, stderr: false };
} });
var require_util2 = __commonJS({ "../../node_modules/@testing-library/jest-dom/node_modules/chalk/source/util.js"(exports, module2) {
  var stringReplaceAll = (string, substring, replacer) => {
    let index = string.indexOf(substring);
    if (index === -1) return string;
    let substringLength = substring.length, endIndex = 0, returnValue = "";
    do
      returnValue += string.substr(endIndex, index - endIndex) + substring + replacer, endIndex = index + substringLength, index = string.indexOf(substring, endIndex);
    while (index !== -1);
    return returnValue += string.substr(endIndex), returnValue;
  }, stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
    let endIndex = 0, returnValue = "";
    do {
      let gotCR = string[index - 1] === "\r";
      returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? `\r
` : `
`) + postfix, endIndex = index + 1, index = string.indexOf(`
`, endIndex);
    } while (index !== -1);
    return returnValue += string.substr(endIndex), returnValue;
  };
  module2.exports = { stringReplaceAll, stringEncaseCRLFWithFirstIndex };
} });
var require_templates = __commonJS({ "../../node_modules/@testing-library/jest-dom/node_modules/chalk/source/templates.js"(exports, module2) {
  var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.)|([^\\])/gi, ESCAPES = /* @__PURE__ */ new Map([["n", `
`], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", "\x1B"], ["a", "\x07"]]);
  function unescape(c3) {
    let u22 = c3[0] === "u", bracket = c3[1] === "{";
    return u22 && !bracket && c3.length === 5 || c3[0] === "x" && c3.length === 3 ? String.fromCharCode(parseInt(c3.slice(1), 16)) : u22 && bracket ? String.fromCodePoint(parseInt(c3.slice(2, -1), 16)) : ESCAPES.get(c3) || c3;
  }
  function parseArguments(name2, arguments_) {
    let results = [], chunks = arguments_.trim().split(/\s*,\s*/g), matches3;
    for (let chunk of chunks) {
      let number = Number(chunk);
      if (!Number.isNaN(number)) results.push(number);
      else if (matches3 = chunk.match(STRING_REGEX)) results.push(matches3[2].replace(ESCAPE_REGEX, (m22, escape4, character) => escape4 ? unescape(escape4) : character));
      else throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    let results = [], matches3;
    for (; (matches3 = STYLE_REGEX.exec(style)) !== null; ) {
      let name2 = matches3[1];
      if (matches3[2]) {
        let args2 = parseArguments(name2, matches3[2]);
        results.push([name2].concat(args2));
      } else results.push([name2]);
    }
    return results;
  }
  function buildStyle(chalk3, styles3) {
    let enabled = {};
    for (let layer of styles3) for (let style of layer.styles) enabled[style[0]] = layer.inverse ? null : style.slice(1);
    let current = chalk3;
    for (let [styleName, styles4] of Object.entries(enabled)) if (Array.isArray(styles4)) {
      if (!(styleName in current)) throw new Error(`Unknown Chalk style: ${styleName}`);
      current = styles4.length > 0 ? current[styleName](...styles4) : current[styleName];
    }
    return current;
  }
  module2.exports = (chalk3, temporary) => {
    let styles3 = [], chunks = [], chunk = [];
    if (temporary.replace(TEMPLATE_REGEX, (m22, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) chunk.push(unescape(escapeCharacter));
      else if (style) {
        let string = chunk.join("");
        chunk = [], chunks.push(styles3.length === 0 ? string : buildStyle(chalk3, styles3)(string)), styles3.push({ inverse, styles: parseStyle(style) });
      } else if (close) {
        if (styles3.length === 0) throw new Error("Found extraneous } in Chalk template literal");
        chunks.push(buildStyle(chalk3, styles3)(chunk.join(""))), chunk = [], styles3.pop();
      } else chunk.push(character);
    }), chunks.push(chunk.join("")), styles3.length > 0) {
      let errMsg = `Chalk template literal is missing ${styles3.length} closing bracket${styles3.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMsg);
    }
    return chunks.join("");
  };
} });
var require_source = __commonJS({ "../../node_modules/@testing-library/jest-dom/node_modules/chalk/source/index.js"(exports, module2) {
  var ansiStyles = require_ansi_styles(), { stdout: stdoutColor, stderr: stderrColor } = require_browser(), { stringReplaceAll, stringEncaseCRLFWithFirstIndex } = require_util2(), levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"], styles3 = /* @__PURE__ */ Object.create(null), applyOptions = (object, options2 = {}) => {
    if (options2.level > 3 || options2.level < 0) throw new Error("The `level` option should be an integer from 0 to 3");
    let colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options2.level === void 0 ? colorLevel : options2.level;
  }, ChalkClass = class {
    constructor(options2) {
      return chalkFactory(options2);
    }
  }, chalkFactory = (options2) => {
    let chalk4 = {};
    return applyOptions(chalk4, options2), chalk4.template = (...arguments_) => chalkTag(chalk4.template, ...arguments_), Object.setPrototypeOf(chalk4, Chalk.prototype), Object.setPrototypeOf(chalk4.template, chalk4), chalk4.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    }, chalk4.template.Instance = ChalkClass, chalk4.template;
  };
  function Chalk(options2) {
    return chalkFactory(options2);
  }
  for (let [styleName, style] of Object.entries(ansiStyles)) styles3[styleName] = { get() {
    let builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
    return Object.defineProperty(this, styleName, { value: builder }), builder;
  } };
  styles3.visible = { get() {
    let builder = createBuilder(this, this._styler, true);
    return Object.defineProperty(this, "visible", { value: builder }), builder;
  } };
  var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (let model of usedModels) styles3[model] = { get() {
    let { level } = this;
    return function(...arguments_) {
      let styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
      return createBuilder(this, styler, this._isEmpty);
    };
  } };
  for (let model of usedModels) {
    let bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles3[bgModel] = { get() {
      let { level } = this;
      return function(...arguments_) {
        let styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    } };
  }
  var proto = Object.defineProperties(() => {
  }, { ...styles3, level: { enumerable: true, get() {
    return this._generator.level;
  }, set(level) {
    this._generator.level = level;
  } } }), createStyler = (open, close, parent) => {
    let openAll, closeAll;
    return parent === void 0 ? (openAll = open, closeAll = close) : (openAll = parent.openAll + open, closeAll = close + parent.closeAll), { open, close, openAll, closeAll, parent };
  }, createBuilder = (self2, _styler, _isEmpty) => {
    let builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    return builder.__proto__ = proto, builder._generator = self2, builder._styler = _styler, builder._isEmpty = _isEmpty, builder;
  }, applyStyle = (self2, string) => {
    if (self2.level <= 0 || !string) return self2._isEmpty ? "" : string;
    let styler = self2._styler;
    if (styler === void 0) return string;
    let { openAll, closeAll } = styler;
    if (string.indexOf("\x1B") !== -1) for (; styler !== void 0; ) string = stringReplaceAll(string, styler.close, styler.open), styler = styler.parent;
    let lfIndex = string.indexOf(`
`);
    return lfIndex !== -1 && (string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex)), openAll + string + closeAll;
  }, template, chalkTag = (chalk4, ...strings) => {
    let [firstString] = strings;
    if (!Array.isArray(firstString)) return strings.join(" ");
    let arguments_ = strings.slice(1), parts = [firstString.raw[0]];
    for (let i4 = 1; i4 < firstString.length; i4++) parts.push(String(arguments_[i4 - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i4]));
    return template === void 0 && (template = require_templates()), template(chalk4, parts.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles3);
  var chalk3 = Chalk();
  chalk3.supportsColor = stdoutColor;
  chalk3.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
  chalk3.stderr.supportsColor = stderrColor;
  chalk3.Level = { None: 0, Basic: 1, Ansi256: 2, TrueColor: 3, 0: "None", 1: "Basic", 2: "Ansi256", 3: "TrueColor" };
  module2.exports = chalk3;
} });
var require_listCacheClear = __commonJS({ "../../node_modules/lodash/_listCacheClear.js"(exports, module2) {
  function listCacheClear() {
    this.__data__ = [], this.size = 0;
  }
  module2.exports = listCacheClear;
} });
var require_eq = __commonJS({ "../../node_modules/lodash/eq.js"(exports, module2) {
  function eq2(value2, other) {
    return value2 === other || value2 !== value2 && other !== other;
  }
  module2.exports = eq2;
} });
var require_assocIndexOf = __commonJS({ "../../node_modules/lodash/_assocIndexOf.js"(exports, module2) {
  var eq2 = require_eq();
  function assocIndexOf(array, key2) {
    for (var length = array.length; length--; ) if (eq2(array[length][0], key2)) return length;
    return -1;
  }
  module2.exports = assocIndexOf;
} });
var require_listCacheDelete = __commonJS({ "../../node_modules/lodash/_listCacheDelete.js"(exports, module2) {
  var assocIndexOf = require_assocIndexOf(), arrayProto = Array.prototype, splice = arrayProto.splice;
  function listCacheDelete(key2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    return index == lastIndex ? data.pop() : splice.call(data, index, 1), --this.size, true;
  }
  module2.exports = listCacheDelete;
} });
var require_listCacheGet = __commonJS({ "../../node_modules/lodash/_listCacheGet.js"(exports, module2) {
  var assocIndexOf = require_assocIndexOf();
  function listCacheGet(key2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    return index < 0 ? void 0 : data[index][1];
  }
  module2.exports = listCacheGet;
} });
var require_listCacheHas = __commonJS({ "../../node_modules/lodash/_listCacheHas.js"(exports, module2) {
  var assocIndexOf = require_assocIndexOf();
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  module2.exports = listCacheHas;
} });
var require_listCacheSet = __commonJS({ "../../node_modules/lodash/_listCacheSet.js"(exports, module2) {
  var assocIndexOf = require_assocIndexOf();
  function listCacheSet(key2, value2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    return index < 0 ? (++this.size, data.push([key2, value2])) : data[index][1] = value2, this;
  }
  module2.exports = listCacheSet;
} });
var require_ListCache = __commonJS({ "../../node_modules/lodash/_ListCache.js"(exports, module2) {
  var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    for (this.clear(); ++index < length; ) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype.delete = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module2.exports = ListCache;
} });
var require_stackClear = __commonJS({ "../../node_modules/lodash/_stackClear.js"(exports, module2) {
  var ListCache = require_ListCache();
  function stackClear() {
    this.__data__ = new ListCache(), this.size = 0;
  }
  module2.exports = stackClear;
} });
var require_stackDelete = __commonJS({ "../../node_modules/lodash/_stackDelete.js"(exports, module2) {
  function stackDelete(key2) {
    var data = this.__data__, result2 = data.delete(key2);
    return this.size = data.size, result2;
  }
  module2.exports = stackDelete;
} });
var require_stackGet = __commonJS({ "../../node_modules/lodash/_stackGet.js"(exports, module2) {
  function stackGet(key2) {
    return this.__data__.get(key2);
  }
  module2.exports = stackGet;
} });
var require_stackHas = __commonJS({ "../../node_modules/lodash/_stackHas.js"(exports, module2) {
  function stackHas(key2) {
    return this.__data__.has(key2);
  }
  module2.exports = stackHas;
} });
var require_freeGlobal = __commonJS({ "../../node_modules/lodash/_freeGlobal.js"(exports, module2) {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module2.exports = freeGlobal;
} });
var require_root = __commonJS({ "../../node_modules/lodash/_root.js"(exports, module2) {
  var freeGlobal = require_freeGlobal(), freeSelf = typeof self == "object" && self && self.Object === Object && self, root2 = freeGlobal || freeSelf || Function("return this")();
  module2.exports = root2;
} });
var require_Symbol = __commonJS({ "../../node_modules/lodash/_Symbol.js"(exports, module2) {
  var root2 = require_root(), Symbol2 = root2.Symbol;
  module2.exports = Symbol2;
} });
var require_getRawTag = __commonJS({ "../../node_modules/lodash/_getRawTag.js"(exports, module2) {
  var Symbol2 = require_Symbol(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value2) {
    var isOwn = hasOwnProperty.call(value2, symToStringTag), tag = value2[symToStringTag];
    try {
      value2[symToStringTag] = void 0;
      var unmasked = true;
    } catch {
    }
    var result2 = nativeObjectToString.call(value2);
    return unmasked && (isOwn ? value2[symToStringTag] = tag : delete value2[symToStringTag]), result2;
  }
  module2.exports = getRawTag;
} });
var require_objectToString = __commonJS({ "../../node_modules/lodash/_objectToString.js"(exports, module2) {
  var objectProto = Object.prototype, nativeObjectToString = objectProto.toString;
  function objectToString(value2) {
    return nativeObjectToString.call(value2);
  }
  module2.exports = objectToString;
} });
var require_baseGetTag = __commonJS({ "../../node_modules/lodash/_baseGetTag.js"(exports, module2) {
  var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString(), nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value2) {
    return value2 == null ? value2 === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
  }
  module2.exports = baseGetTag;
} });
var require_isObject = __commonJS({ "../../node_modules/lodash/isObject.js"(exports, module2) {
  function isObject22(value2) {
    var type5 = typeof value2;
    return value2 != null && (type5 == "object" || type5 == "function");
  }
  module2.exports = isObject22;
} });
var require_isFunction = __commonJS({ "../../node_modules/lodash/isFunction.js"(exports, module2) {
  var baseGetTag = require_baseGetTag(), isObject22 = require_isObject(), asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value2) {
    if (!isObject22(value2)) return false;
    var tag = baseGetTag(value2);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  module2.exports = isFunction;
} });
var require_coreJsData = __commonJS({ "../../node_modules/lodash/_coreJsData.js"(exports, module2) {
  var root2 = require_root(), coreJsData = root2["__core-js_shared__"];
  module2.exports = coreJsData;
} });
var require_isMasked = __commonJS({ "../../node_modules/lodash/_isMasked.js"(exports, module2) {
  var coreJsData = require_coreJsData(), maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  module2.exports = isMasked;
} });
var require_toSource = __commonJS({ "../../node_modules/lodash/_toSource.js"(exports, module2) {
  var funcProto = Function.prototype, funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch {
      }
      try {
        return func + "";
      } catch {
      }
    }
    return "";
  }
  module2.exports = toSource;
} });
var require_baseIsNative = __commonJS({ "../../node_modules/lodash/_baseIsNative.js"(exports, module2) {
  var isFunction = require_isFunction(), isMasked = require_isMasked(), isObject22 = require_isObject(), toSource = require_toSource(), reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  function baseIsNative(value2) {
    if (!isObject22(value2) || isMasked(value2)) return false;
    var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value2));
  }
  module2.exports = baseIsNative;
} });
var require_getValue = __commonJS({ "../../node_modules/lodash/_getValue.js"(exports, module2) {
  function getValue(object, key2) {
    return object == null ? void 0 : object[key2];
  }
  module2.exports = getValue;
} });
var require_getNative = __commonJS({ "../../node_modules/lodash/_getNative.js"(exports, module2) {
  var baseIsNative = require_baseIsNative(), getValue = require_getValue();
  function getNative(object, key2) {
    var value2 = getValue(object, key2);
    return baseIsNative(value2) ? value2 : void 0;
  }
  module2.exports = getNative;
} });
var require_Map = __commonJS({ "../../node_modules/lodash/_Map.js"(exports, module2) {
  var getNative = require_getNative(), root2 = require_root(), Map2 = getNative(root2, "Map");
  module2.exports = Map2;
} });
var require_nativeCreate = __commonJS({ "../../node_modules/lodash/_nativeCreate.js"(exports, module2) {
  var getNative = require_getNative(), nativeCreate = getNative(Object, "create");
  module2.exports = nativeCreate;
} });
var require_hashClear = __commonJS({ "../../node_modules/lodash/_hashClear.js"(exports, module2) {
  var nativeCreate = require_nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
  }
  module2.exports = hashClear;
} });
var require_hashDelete = __commonJS({ "../../node_modules/lodash/_hashDelete.js"(exports, module2) {
  function hashDelete(key2) {
    var result2 = this.has(key2) && delete this.__data__[key2];
    return this.size -= result2 ? 1 : 0, result2;
  }
  module2.exports = hashDelete;
} });
var require_hashGet = __commonJS({ "../../node_modules/lodash/_hashGet.js"(exports, module2) {
  var nativeCreate = require_nativeCreate(), HASH_UNDEFINED = "__lodash_hash_undefined__", objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
  function hashGet(key2) {
    var data = this.__data__;
    if (nativeCreate) {
      var result2 = data[key2];
      return result2 === HASH_UNDEFINED ? void 0 : result2;
    }
    return hasOwnProperty.call(data, key2) ? data[key2] : void 0;
  }
  module2.exports = hashGet;
} });
var require_hashHas = __commonJS({ "../../node_modules/lodash/_hashHas.js"(exports, module2) {
  var nativeCreate = require_nativeCreate(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
  function hashHas(key2) {
    var data = this.__data__;
    return nativeCreate ? data[key2] !== void 0 : hasOwnProperty.call(data, key2);
  }
  module2.exports = hashHas;
} });
var require_hashSet = __commonJS({ "../../node_modules/lodash/_hashSet.js"(exports, module2) {
  var nativeCreate = require_nativeCreate(), HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key2, value2) {
    var data = this.__data__;
    return this.size += this.has(key2) ? 0 : 1, data[key2] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED : value2, this;
  }
  module2.exports = hashSet;
} });
var require_Hash = __commonJS({ "../../node_modules/lodash/_Hash.js"(exports, module2) {
  var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    for (this.clear(); ++index < length; ) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype.delete = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  module2.exports = Hash;
} });
var require_mapCacheClear = __commonJS({ "../../node_modules/lodash/_mapCacheClear.js"(exports, module2) {
  var Hash = require_Hash(), ListCache = require_ListCache(), Map2 = require_Map();
  function mapCacheClear() {
    this.size = 0, this.__data__ = { hash: new Hash(), map: new (Map2 || ListCache)(), string: new Hash() };
  }
  module2.exports = mapCacheClear;
} });
var require_isKeyable = __commonJS({ "../../node_modules/lodash/_isKeyable.js"(exports, module2) {
  function isKeyable(value2) {
    var type5 = typeof value2;
    return type5 == "string" || type5 == "number" || type5 == "symbol" || type5 == "boolean" ? value2 !== "__proto__" : value2 === null;
  }
  module2.exports = isKeyable;
} });
var require_getMapData = __commonJS({ "../../node_modules/lodash/_getMapData.js"(exports, module2) {
  var isKeyable = require_isKeyable();
  function getMapData(map, key2) {
    var data = map.__data__;
    return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
  }
  module2.exports = getMapData;
} });
var require_mapCacheDelete = __commonJS({ "../../node_modules/lodash/_mapCacheDelete.js"(exports, module2) {
  var getMapData = require_getMapData();
  function mapCacheDelete(key2) {
    var result2 = getMapData(this, key2).delete(key2);
    return this.size -= result2 ? 1 : 0, result2;
  }
  module2.exports = mapCacheDelete;
} });
var require_mapCacheGet = __commonJS({ "../../node_modules/lodash/_mapCacheGet.js"(exports, module2) {
  var getMapData = require_getMapData();
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  module2.exports = mapCacheGet;
} });
var require_mapCacheHas = __commonJS({ "../../node_modules/lodash/_mapCacheHas.js"(exports, module2) {
  var getMapData = require_getMapData();
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  module2.exports = mapCacheHas;
} });
var require_mapCacheSet = __commonJS({ "../../node_modules/lodash/_mapCacheSet.js"(exports, module2) {
  var getMapData = require_getMapData();
  function mapCacheSet(key2, value2) {
    var data = getMapData(this, key2), size = data.size;
    return data.set(key2, value2), this.size += data.size == size ? 0 : 1, this;
  }
  module2.exports = mapCacheSet;
} });
var require_MapCache = __commonJS({ "../../node_modules/lodash/_MapCache.js"(exports, module2) {
  var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    for (this.clear(); ++index < length; ) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype.delete = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module2.exports = MapCache;
} });
var require_stackSet = __commonJS({ "../../node_modules/lodash/_stackSet.js"(exports, module2) {
  var ListCache = require_ListCache(), Map2 = require_Map(), MapCache = require_MapCache(), LARGE_ARRAY_SIZE = 200;
  function stackSet(key2, value2) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([key2, value2]), this.size = ++data.size, this;
      data = this.__data__ = new MapCache(pairs);
    }
    return data.set(key2, value2), this.size = data.size, this;
  }
  module2.exports = stackSet;
} });
var require_Stack = __commonJS({ "../../node_modules/lodash/_Stack.js"(exports, module2) {
  var ListCache = require_ListCache(), stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype.delete = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  module2.exports = Stack;
} });
var require_setCacheAdd = __commonJS({ "../../node_modules/lodash/_setCacheAdd.js"(exports, module2) {
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value2) {
    return this.__data__.set(value2, HASH_UNDEFINED), this;
  }
  module2.exports = setCacheAdd;
} });
var require_setCacheHas = __commonJS({ "../../node_modules/lodash/_setCacheHas.js"(exports, module2) {
  function setCacheHas(value2) {
    return this.__data__.has(value2);
  }
  module2.exports = setCacheHas;
} });
var require_SetCache = __commonJS({ "../../node_modules/lodash/_SetCache.js"(exports, module2) {
  var MapCache = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    for (this.__data__ = new MapCache(); ++index < length; ) this.add(values[index]);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  module2.exports = SetCache;
} });
var require_arraySome = __commonJS({ "../../node_modules/lodash/_arraySome.js"(exports, module2) {
  function arraySome(array, predicate) {
    for (var index = -1, length = array == null ? 0 : array.length; ++index < length; ) if (predicate(array[index], index, array)) return true;
    return false;
  }
  module2.exports = arraySome;
} });
var require_cacheHas = __commonJS({ "../../node_modules/lodash/_cacheHas.js"(exports, module2) {
  function cacheHas(cache, key2) {
    return cache.has(key2);
  }
  module2.exports = cacheHas;
} });
var require_equalArrays = __commonJS({ "../../node_modules/lodash/_equalArrays.js"(exports, module2) {
  var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas(), COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
    var arrStacked = stack.get(array), othStacked = stack.get(other);
    if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
    var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    for (stack.set(array, other), stack.set(other, array); ++index < arrLength; ) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      if (compared !== void 0) {
        if (compared) continue;
        result2 = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) return seen.push(othIndex);
        })) {
          result2 = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result2 = false;
        break;
      }
    }
    return stack.delete(array), stack.delete(other), result2;
  }
  module2.exports = equalArrays;
} });
var require_Uint8Array = __commonJS({ "../../node_modules/lodash/_Uint8Array.js"(exports, module2) {
  var root2 = require_root(), Uint8Array2 = root2.Uint8Array;
  module2.exports = Uint8Array2;
} });
var require_mapToArray = __commonJS({ "../../node_modules/lodash/_mapToArray.js"(exports, module2) {
  function mapToArray(map) {
    var index = -1, result2 = Array(map.size);
    return map.forEach(function(value2, key2) {
      result2[++index] = [key2, value2];
    }), result2;
  }
  module2.exports = mapToArray;
} });
var require_setToArray = __commonJS({ "../../node_modules/lodash/_setToArray.js"(exports, module2) {
  function setToArray(set2) {
    var index = -1, result2 = Array(set2.size);
    return set2.forEach(function(value2) {
      result2[++index] = value2;
    }), result2;
  }
  module2.exports = setToArray;
} });
var require_equalByTag = __commonJS({ "../../node_modules/lodash/_equalByTag.js"(exports, module2) {
  var Symbol2 = require_Symbol(), Uint8Array2 = require_Uint8Array(), eq2 = require_eq(), equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray(), COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
        object = object.buffer, other = other.buffer;
      case arrayBufferTag:
        return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other)));
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        if (convert || (convert = setToArray), object.size != other.size && !isPartial) return false;
        var stacked = stack.get(object);
        if (stacked) return stacked == other;
        bitmask |= COMPARE_UNORDERED_FLAG, stack.set(object, other);
        var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        return stack.delete(object), result2;
      case symbolTag:
        if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
    }
    return false;
  }
  module2.exports = equalByTag;
} });
var require_arrayPush = __commonJS({ "../../node_modules/lodash/_arrayPush.js"(exports, module2) {
  function arrayPush(array, values) {
    for (var index = -1, length = values.length, offset = array.length; ++index < length; ) array[offset + index] = values[index];
    return array;
  }
  module2.exports = arrayPush;
} });
var require_isArray = __commonJS({ "../../node_modules/lodash/isArray.js"(exports, module2) {
  var isArray = Array.isArray;
  module2.exports = isArray;
} });
var require_baseGetAllKeys = __commonJS({ "../../node_modules/lodash/_baseGetAllKeys.js"(exports, module2) {
  var arrayPush = require_arrayPush(), isArray = require_isArray();
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result2 = keysFunc(object);
    return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
  }
  module2.exports = baseGetAllKeys;
} });
var require_arrayFilter = __commonJS({ "../../node_modules/lodash/_arrayFilter.js"(exports, module2) {
  function arrayFilter(array, predicate) {
    for (var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = []; ++index < length; ) {
      var value2 = array[index];
      predicate(value2, index, array) && (result2[resIndex++] = value2);
    }
    return result2;
  }
  module2.exports = arrayFilter;
} });
var require_stubArray = __commonJS({ "../../node_modules/lodash/stubArray.js"(exports, module2) {
  function stubArray() {
    return [];
  }
  module2.exports = stubArray;
} });
var require_getSymbols = __commonJS({ "../../node_modules/lodash/_getSymbols.js"(exports, module2) {
  var arrayFilter = require_arrayFilter(), stubArray = require_stubArray(), objectProto = Object.prototype, propertyIsEnumerable = objectProto.propertyIsEnumerable, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols ? function(object) {
    return object == null ? [] : (object = Object(object), arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    }));
  } : stubArray;
  module2.exports = getSymbols;
} });
var require_baseTimes = __commonJS({ "../../node_modules/lodash/_baseTimes.js"(exports, module2) {
  function baseTimes(n3, iteratee) {
    for (var index = -1, result2 = Array(n3); ++index < n3; ) result2[index] = iteratee(index);
    return result2;
  }
  module2.exports = baseTimes;
} });
var require_isObjectLike = __commonJS({ "../../node_modules/lodash/isObjectLike.js"(exports, module2) {
  function isObjectLike(value2) {
    return value2 != null && typeof value2 == "object";
  }
  module2.exports = isObjectLike;
} });
var require_baseIsArguments = __commonJS({ "../../node_modules/lodash/_baseIsArguments.js"(exports, module2) {
  var baseGetTag = require_baseGetTag(), isObjectLike = require_isObjectLike(), argsTag = "[object Arguments]";
  function baseIsArguments(value2) {
    return isObjectLike(value2) && baseGetTag(value2) == argsTag;
  }
  module2.exports = baseIsArguments;
} });
var require_isArguments = __commonJS({ "../../node_modules/lodash/isArguments.js"(exports, module2) {
  var baseIsArguments = require_baseIsArguments(), isObjectLike = require_isObjectLike(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, propertyIsEnumerable = objectProto.propertyIsEnumerable, isArguments = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value2) {
    return isObjectLike(value2) && hasOwnProperty.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
  };
  module2.exports = isArguments;
} });
var require_stubFalse = __commonJS({ "../../node_modules/lodash/stubFalse.js"(exports, module2) {
  function stubFalse() {
    return false;
  }
  module2.exports = stubFalse;
} });
var require_isBuffer = __commonJS({ "../../node_modules/lodash/isBuffer.js"(exports, module2) {
  var root2 = require_root(), stubFalse = require_stubFalse(), freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2, moduleExports = freeModule && freeModule.exports === freeExports, Buffer2 = moduleExports ? root2.Buffer : void 0, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, isBuffer = nativeIsBuffer || stubFalse;
  module2.exports = isBuffer;
} });
var require_isIndex = __commonJS({ "../../node_modules/lodash/_isIndex.js"(exports, module2) {
  var MAX_SAFE_INTEGER = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value2, length) {
    var type5 = typeof value2;
    return length = length ?? MAX_SAFE_INTEGER, !!length && (type5 == "number" || type5 != "symbol" && reIsUint.test(value2)) && value2 > -1 && value2 % 1 == 0 && value2 < length;
  }
  module2.exports = isIndex;
} });
var require_isLength = __commonJS({ "../../node_modules/lodash/isLength.js"(exports, module2) {
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value2) {
    return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
  }
  module2.exports = isLength;
} });
var require_baseIsTypedArray = __commonJS({ "../../node_modules/lodash/_baseIsTypedArray.js"(exports, module2) {
  var baseGetTag = require_baseGetTag(), isLength = require_isLength(), isObjectLike = require_isObjectLike(), argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value2) {
    return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
  }
  module2.exports = baseIsTypedArray;
} });
var require_baseUnary = __commonJS({ "../../node_modules/lodash/_baseUnary.js"(exports, module2) {
  function baseUnary(func) {
    return function(value2) {
      return func(value2);
    };
  }
  module2.exports = baseUnary;
} });
var require_nodeUtil = __commonJS({ "../../node_modules/lodash/_nodeUtil.js"(exports, module2) {
  var freeGlobal = require_freeGlobal(), freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      return types || freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch {
    }
  }();
  module2.exports = nodeUtil;
} });
var require_isTypedArray = __commonJS({ "../../node_modules/lodash/isTypedArray.js"(exports, module2) {
  var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  module2.exports = isTypedArray;
} });
var require_arrayLikeKeys = __commonJS({ "../../node_modules/lodash/_arrayLikeKeys.js"(exports, module2) {
  var baseTimes = require_baseTimes(), isArguments = require_isArguments(), isArray = require_isArray(), isBuffer = require_isBuffer(), isIndex = require_isIndex(), isTypedArray = require_isTypedArray(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
  function arrayLikeKeys(value2, inherited) {
    var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value2.length, String) : [], length = result2.length;
    for (var key2 in value2) (inherited || hasOwnProperty.call(value2, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length))) && result2.push(key2);
    return result2;
  }
  module2.exports = arrayLikeKeys;
} });
var require_isPrototype = __commonJS({ "../../node_modules/lodash/_isPrototype.js"(exports, module2) {
  var objectProto = Object.prototype;
  function isPrototype(value2) {
    var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value2 === proto;
  }
  module2.exports = isPrototype;
} });
var require_overArg = __commonJS({ "../../node_modules/lodash/_overArg.js"(exports, module2) {
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  module2.exports = overArg;
} });
var require_nativeKeys = __commonJS({ "../../node_modules/lodash/_nativeKeys.js"(exports, module2) {
  var overArg = require_overArg(), nativeKeys = overArg(Object.keys, Object);
  module2.exports = nativeKeys;
} });
var require_baseKeys = __commonJS({ "../../node_modules/lodash/_baseKeys.js"(exports, module2) {
  var isPrototype = require_isPrototype(), nativeKeys = require_nativeKeys(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) return nativeKeys(object);
    var result2 = [];
    for (var key2 in Object(object)) hasOwnProperty.call(object, key2) && key2 != "constructor" && result2.push(key2);
    return result2;
  }
  module2.exports = baseKeys;
} });
var require_isArrayLike = __commonJS({ "../../node_modules/lodash/isArrayLike.js"(exports, module2) {
  var isFunction = require_isFunction(), isLength = require_isLength();
  function isArrayLike(value2) {
    return value2 != null && isLength(value2.length) && !isFunction(value2);
  }
  module2.exports = isArrayLike;
} });
var require_keys = __commonJS({ "../../node_modules/lodash/keys.js"(exports, module2) {
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike = require_isArrayLike();
  function keys2(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  module2.exports = keys2;
} });
var require_getAllKeys = __commonJS({ "../../node_modules/lodash/_getAllKeys.js"(exports, module2) {
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys2 = require_keys();
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys2, getSymbols);
  }
  module2.exports = getAllKeys;
} });
var require_equalObjects = __commonJS({ "../../node_modules/lodash/_equalObjects.js"(exports, module2) {
  var getAllKeys = require_getAllKeys(), COMPARE_PARTIAL_FLAG = 1, objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) return false;
    for (var index = objLength; index--; ) {
      var key2 = objProps[index];
      if (!(isPartial ? key2 in other : hasOwnProperty.call(other, key2))) return false;
    }
    var objStacked = stack.get(object), othStacked = stack.get(other);
    if (objStacked && othStacked) return objStacked == other && othStacked == object;
    var result2 = true;
    stack.set(object, other), stack.set(other, object);
    for (var skipCtor = isPartial; ++index < objLength; ) {
      key2 = objProps[index];
      var objValue = object[key2], othValue = other[key2];
      if (customizer) var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result2 = false;
        break;
      }
      skipCtor || (skipCtor = key2 == "constructor");
    }
    if (result2 && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor) && (result2 = false);
    }
    return stack.delete(object), stack.delete(other), result2;
  }
  module2.exports = equalObjects;
} });
var require_DataView = __commonJS({ "../../node_modules/lodash/_DataView.js"(exports, module2) {
  var getNative = require_getNative(), root2 = require_root(), DataView2 = getNative(root2, "DataView");
  module2.exports = DataView2;
} });
var require_Promise = __commonJS({ "../../node_modules/lodash/_Promise.js"(exports, module2) {
  var getNative = require_getNative(), root2 = require_root(), Promise2 = getNative(root2, "Promise");
  module2.exports = Promise2;
} });
var require_Set = __commonJS({ "../../node_modules/lodash/_Set.js"(exports, module2) {
  var getNative = require_getNative(), root2 = require_root(), Set2 = getNative(root2, "Set");
  module2.exports = Set2;
} });
var require_WeakMap = __commonJS({ "../../node_modules/lodash/_WeakMap.js"(exports, module2) {
  var getNative = require_getNative(), root2 = require_root(), WeakMap2 = getNative(root2, "WeakMap");
  module2.exports = WeakMap2;
} });
var require_getTag = __commonJS({ "../../node_modules/lodash/_getTag.js"(exports, module2) {
  var DataView2 = require_DataView(), Map2 = require_Map(), Promise2 = require_Promise(), Set2 = require_Set(), WeakMap2 = require_WeakMap(), baseGetTag = require_baseGetTag(), toSource = require_toSource(), mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]", dataViewTag = "[object DataView]", dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2), getTag2 = baseGetTag;
  (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) && (getTag2 = function(value2) {
    var result2 = baseGetTag(value2), Ctor = result2 == objectTag ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) switch (ctorString) {
      case dataViewCtorString:
        return dataViewTag;
      case mapCtorString:
        return mapTag;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag;
      case weakMapCtorString:
        return weakMapTag;
    }
    return result2;
  });
  module2.exports = getTag2;
} });
var require_baseIsEqualDeep = __commonJS({ "../../node_modules/lodash/_baseIsEqualDeep.js"(exports, module2) {
  var Stack = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag2 = require_getTag(), isArray = require_isArray(), isBuffer = require_isBuffer(), isTypedArray = require_isTypedArray(), COMPARE_PARTIAL_FLAG = 1, argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]", objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag2(object), othTag = othIsArr ? arrayTag : getTag2(other);
    objTag = objTag == argsTag ? objectTag : objTag, othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) return false;
      objIsArr = true, objIsObj = false;
    }
    if (isSameTag && !objIsObj) return stack || (stack = new Stack()), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        return stack || (stack = new Stack()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    return isSameTag ? (stack || (stack = new Stack()), equalObjects(object, other, bitmask, customizer, equalFunc, stack)) : false;
  }
  module2.exports = baseIsEqualDeep;
} });
var require_baseIsEqual = __commonJS({ "../../node_modules/lodash/_baseIsEqual.js"(exports, module2) {
  var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike = require_isObjectLike();
  function baseIsEqual(value2, other, bitmask, customizer, stack) {
    return value2 === other ? true : value2 == null || other == null || !isObjectLike(value2) && !isObjectLike(other) ? value2 !== value2 && other !== other : baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack);
  }
  module2.exports = baseIsEqual;
} });
var require_isEqualWith = __commonJS({ "../../node_modules/lodash/isEqualWith.js"(exports, module2) {
  var baseIsEqual = require_baseIsEqual();
  function isEqualWith2(value2, other, customizer) {
    customizer = typeof customizer == "function" ? customizer : void 0;
    var result2 = customizer ? customizer(value2, other) : void 0;
    return result2 === void 0 ? baseIsEqual(value2, other, void 0, customizer) : !!result2;
  }
  module2.exports = isEqualWith2;
} });
var require_css_escape = __commonJS({ "../../node_modules/css.escape/css.escape.js"(exports, module2) {
  (function(root2, factory) {
    typeof exports == "object" ? module2.exports = factory(root2) : typeof define == "function" && define.amd ? define([], factory.bind(root2, root2)) : factory(root2);
  })(typeof global < "u" ? global : exports, function(root2) {
    if (root2.CSS && root2.CSS.escape) return root2.CSS.escape;
    var cssEscape = function(value2) {
      if (arguments.length == 0) throw new TypeError("`CSS.escape` requires an argument.");
      for (var string = String(value2), length = string.length, index = -1, codeUnit, result2 = "", firstCodeUnit = string.charCodeAt(0); ++index < length; ) {
        if (codeUnit = string.charCodeAt(index), codeUnit == 0) {
          result2 += "";
          continue;
        }
        if (codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || index == 0 && codeUnit >= 48 && codeUnit <= 57 || index == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45) {
          result2 += "\\" + codeUnit.toString(16) + " ";
          continue;
        }
        if (index == 0 && length == 1 && codeUnit == 45) {
          result2 += "\\" + string.charAt(index);
          continue;
        }
        if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
          result2 += string.charAt(index);
          continue;
        }
        result2 += "\\" + string.charAt(index);
      }
      return result2;
    };
    return root2.CSS || (root2.CSS = {}), root2.CSS.escape = cssEscape, cssEscape;
  });
} });
var require_ansi_styles2 = __commonJS({ "../../node_modules/pretty-format/node_modules/ansi-styles/index.js"(exports, module2) {
  var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`, wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
  function assembleStyles() {
    let codes = /* @__PURE__ */ new Map(), styles3 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
    styles3.color.gray = styles3.color.blackBright, styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright, styles3.color.grey = styles3.color.blackBright, styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
    for (let [groupName, group] of Object.entries(styles3)) {
      for (let [styleName, style] of Object.entries(group)) styles3[styleName] = { open: `\x1B[${style[0]}m`, close: `\x1B[${style[1]}m` }, group[styleName] = styles3[styleName], codes.set(style[0], style[1]);
      Object.defineProperty(styles3, groupName, { value: group, enumerable: false });
    }
    return Object.defineProperty(styles3, "codes", { value: codes, enumerable: false }), styles3.color.close = "\x1B[39m", styles3.bgColor.close = "\x1B[49m", styles3.color.ansi256 = wrapAnsi256(), styles3.color.ansi16m = wrapAnsi16m(), styles3.bgColor.ansi256 = wrapAnsi256(10), styles3.bgColor.ansi16m = wrapAnsi16m(10), Object.defineProperties(styles3, { rgbToAnsi256: { value: (red, green, blue) => red === green && green === blue ? red < 8 ? 16 : red > 248 ? 231 : Math.round((red - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5), enumerable: false }, hexToRgb: { value: (hex3) => {
      let matches3 = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex3.toString(16));
      if (!matches3) return [0, 0, 0];
      let { colorString } = matches3.groups;
      colorString.length === 3 && (colorString = colorString.split("").map((character) => character + character).join(""));
      let integer = Number.parseInt(colorString, 16);
      return [integer >> 16 & 255, integer >> 8 & 255, integer & 255];
    }, enumerable: false }, hexToAnsi256: { value: (hex3) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex3)), enumerable: false } }), styles3;
  }
  Object.defineProperty(module2, "exports", { enumerable: true, get: assembleStyles });
} });
var require_collections = __commonJS({ "../../node_modules/pretty-format/build/collections.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.printIteratorEntries = printIteratorEntries22;
  exports.printIteratorValues = printIteratorValues22;
  exports.printListItems = printListItems22;
  exports.printObjectProperties = printObjectProperties22;
  var getKeysOfEnumerableProperties22 = (object, compareKeys) => {
    let keys2 = Object.keys(object).sort(compareKeys);
    return Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(object).forEach((symbol) => {
      Object.getOwnPropertyDescriptor(object, symbol).enumerable && keys2.push(symbol);
    }), keys2;
  };
  function printIteratorEntries22(iterator, config3, indentation, depth, refs2, printer22, separator = ": ") {
    let result2 = "", current = iterator.next();
    if (!current.done) {
      result2 += config3.spacingOuter;
      let indentationNext = indentation + config3.indent;
      for (; !current.done; ) {
        let name2 = printer22(current.value[0], config3, indentationNext, depth, refs2), value2 = printer22(current.value[1], config3, indentationNext, depth, refs2);
        result2 += indentationNext + name2 + separator + value2, current = iterator.next(), current.done ? config3.min || (result2 += ",") : result2 += "," + config3.spacingInner;
      }
      result2 += config3.spacingOuter + indentation;
    }
    return result2;
  }
  function printIteratorValues22(iterator, config3, indentation, depth, refs2, printer22) {
    let result2 = "", current = iterator.next();
    if (!current.done) {
      result2 += config3.spacingOuter;
      let indentationNext = indentation + config3.indent;
      for (; !current.done; ) result2 += indentationNext + printer22(current.value, config3, indentationNext, depth, refs2), current = iterator.next(), current.done ? config3.min || (result2 += ",") : result2 += "," + config3.spacingInner;
      result2 += config3.spacingOuter + indentation;
    }
    return result2;
  }
  function printListItems22(list, config3, indentation, depth, refs2, printer22) {
    let result2 = "";
    if (list.length) {
      result2 += config3.spacingOuter;
      let indentationNext = indentation + config3.indent;
      for (let i4 = 0; i4 < list.length; i4++) result2 += indentationNext, i4 in list && (result2 += printer22(list[i4], config3, indentationNext, depth, refs2)), i4 < list.length - 1 ? result2 += "," + config3.spacingInner : config3.min || (result2 += ",");
      result2 += config3.spacingOuter + indentation;
    }
    return result2;
  }
  function printObjectProperties22(val, config3, indentation, depth, refs2, printer22) {
    let result2 = "", keys2 = getKeysOfEnumerableProperties22(val, config3.compareKeys);
    if (keys2.length) {
      result2 += config3.spacingOuter;
      let indentationNext = indentation + config3.indent;
      for (let i4 = 0; i4 < keys2.length; i4++) {
        let key2 = keys2[i4], name2 = printer22(key2, config3, indentationNext, depth, refs2), value2 = printer22(val[key2], config3, indentationNext, depth, refs2);
        result2 += indentationNext + name2 + ": " + value2, i4 < keys2.length - 1 ? result2 += "," + config3.spacingInner : config3.min || (result2 += ",");
      }
      result2 += config3.spacingOuter + indentation;
    }
    return result2;
  }
} });
var require_AsymmetricMatcher = __commonJS({ "../../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.test = exports.serialize = exports.default = void 0;
  var _collections = require_collections(), global3 = function() {
    return typeof globalThis < "u" ? globalThis : typeof global3 < "u" ? global3 : typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
  }(), Symbol2 = global3["jest-symbol-do-not-touch"] || global3.Symbol, asymmetricMatcher22 = typeof Symbol2 == "function" && Symbol2.for ? Symbol2.for("jest.asymmetricMatcher") : 1267621, SPACE22 = " ", serialize22 = (val, config3, indentation, depth, refs2, printer22) => {
    let stringedValue = val.toString();
    return stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining" ? ++depth > config3.maxDepth ? "[" + stringedValue + "]" : stringedValue + SPACE22 + "[" + (0, _collections.printListItems)(val.sample, config3, indentation, depth, refs2, printer22) + "]" : stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining" ? ++depth > config3.maxDepth ? "[" + stringedValue + "]" : stringedValue + SPACE22 + "{" + (0, _collections.printObjectProperties)(val.sample, config3, indentation, depth, refs2, printer22) + "}" : stringedValue === "StringMatching" || stringedValue === "StringNotMatching" || stringedValue === "StringContaining" || stringedValue === "StringNotContaining" ? stringedValue + SPACE22 + printer22(val.sample, config3, indentation, depth, refs2) : val.toAsymmetricMatcher();
  };
  exports.serialize = serialize22;
  var test3 = (val) => val && val.$$typeof === asymmetricMatcher22;
  exports.test = test3;
  var plugin22 = { serialize: serialize22, test: test3 }, _default2 = plugin22;
  exports.default = _default2;
} });
var require_ansi_regex = __commonJS({ "../../node_modules/pretty-format/node_modules/ansi-regex/index.js"(exports, module2) {
  module2.exports = ({ onlyFirst = false } = {}) => {
    let pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  };
} });
var require_ConvertAnsi = __commonJS({ "../../node_modules/pretty-format/build/plugins/ConvertAnsi.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.test = exports.serialize = exports.default = void 0;
  var _ansiRegex = _interopRequireDefault(require_ansi_regex()), _ansiStyles = _interopRequireDefault(require_ansi_styles2());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var toHumanReadableAnsi = (text) => text.replace((0, _ansiRegex.default)(), (match) => {
    switch (match) {
      case _ansiStyles.default.red.close:
      case _ansiStyles.default.green.close:
      case _ansiStyles.default.cyan.close:
      case _ansiStyles.default.gray.close:
      case _ansiStyles.default.white.close:
      case _ansiStyles.default.yellow.close:
      case _ansiStyles.default.bgRed.close:
      case _ansiStyles.default.bgGreen.close:
      case _ansiStyles.default.bgYellow.close:
      case _ansiStyles.default.inverse.close:
      case _ansiStyles.default.dim.close:
      case _ansiStyles.default.bold.close:
      case _ansiStyles.default.reset.open:
      case _ansiStyles.default.reset.close:
        return "</>";
      case _ansiStyles.default.red.open:
        return "<red>";
      case _ansiStyles.default.green.open:
        return "<green>";
      case _ansiStyles.default.cyan.open:
        return "<cyan>";
      case _ansiStyles.default.gray.open:
        return "<gray>";
      case _ansiStyles.default.white.open:
        return "<white>";
      case _ansiStyles.default.yellow.open:
        return "<yellow>";
      case _ansiStyles.default.bgRed.open:
        return "<bgRed>";
      case _ansiStyles.default.bgGreen.open:
        return "<bgGreen>";
      case _ansiStyles.default.bgYellow.open:
        return "<bgYellow>";
      case _ansiStyles.default.inverse.open:
        return "<inverse>";
      case _ansiStyles.default.dim.open:
        return "<dim>";
      case _ansiStyles.default.bold.open:
        return "<bold>";
      default:
        return "";
    }
  }), test3 = (val) => typeof val == "string" && !!val.match((0, _ansiRegex.default)());
  exports.test = test3;
  var serialize22 = (val, config3, indentation, depth, refs2, printer22) => printer22(toHumanReadableAnsi(val), config3, indentation, depth, refs2);
  exports.serialize = serialize22;
  var plugin22 = { serialize: serialize22, test: test3 }, _default2 = plugin22;
  exports.default = _default2;
} });
var require_DOMCollection = __commonJS({ "../../node_modules/pretty-format/build/plugins/DOMCollection.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.test = exports.serialize = exports.default = void 0;
  var _collections = require_collections(), SPACE22 = " ", OBJECT_NAMES22 = ["DOMStringMap", "NamedNodeMap"], ARRAY_REGEXP22 = /^(HTML\w*Collection|NodeList)$/, testName22 = (name2) => OBJECT_NAMES22.indexOf(name2) !== -1 || ARRAY_REGEXP22.test(name2), test3 = (val) => val && val.constructor && !!val.constructor.name && testName22(val.constructor.name);
  exports.test = test3;
  var isNamedNodeMap22 = (collection) => collection.constructor.name === "NamedNodeMap", serialize22 = (collection, config3, indentation, depth, refs2, printer22) => {
    let name2 = collection.constructor.name;
    return ++depth > config3.maxDepth ? "[" + name2 + "]" : (config3.min ? "" : name2 + SPACE22) + (OBJECT_NAMES22.indexOf(name2) !== -1 ? "{" + (0, _collections.printObjectProperties)(isNamedNodeMap22(collection) ? Array.from(collection).reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}) : { ...collection }, config3, indentation, depth, refs2, printer22) + "}" : "[" + (0, _collections.printListItems)(Array.from(collection), config3, indentation, depth, refs2, printer22) + "]");
  };
  exports.serialize = serialize22;
  var plugin22 = { serialize: serialize22, test: test3 }, _default2 = plugin22;
  exports.default = _default2;
} });
var require_escapeHTML = __commonJS({ "../../node_modules/pretty-format/build/plugins/lib/escapeHTML.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = escapeHTML3;
  function escapeHTML3(str) {
    return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
} });
var require_markup = __commonJS({ "../../node_modules/pretty-format/build/plugins/lib/markup.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.printText = exports.printProps = exports.printElementAsLeaf = exports.printElement = exports.printComment = exports.printChildren = void 0;
  var _escapeHTML = _interopRequireDefault(require_escapeHTML());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var printProps3 = (keys2, props, config3, indentation, depth, refs2, printer22) => {
    let indentationNext = indentation + config3.indent, colors = config3.colors;
    return keys2.map((key2) => {
      let value2 = props[key2], printed = printer22(value2, config3, indentationNext, depth, refs2);
      return typeof value2 != "string" && (printed.indexOf(`
`) !== -1 && (printed = config3.spacingOuter + indentationNext + printed + config3.spacingOuter + indentation), printed = "{" + printed + "}"), config3.spacingInner + indentation + colors.prop.open + key2 + colors.prop.close + "=" + colors.value.open + printed + colors.value.close;
    }).join("");
  };
  exports.printProps = printProps3;
  var printChildren3 = (children, config3, indentation, depth, refs2, printer22) => children.map((child) => config3.spacingOuter + indentation + (typeof child == "string" ? printText3(child, config3) : printer22(child, config3, indentation, depth, refs2))).join("");
  exports.printChildren = printChildren3;
  var printText3 = (text, config3) => {
    let contentColor = config3.colors.content;
    return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
  };
  exports.printText = printText3;
  var printComment3 = (comment, config3) => {
    let commentColor = config3.colors.comment;
    return commentColor.open + "<!--" + (0, _escapeHTML.default)(comment) + "-->" + commentColor.close;
  };
  exports.printComment = printComment3;
  var printElement3 = (type5, printedProps, printedChildren, config3, indentation) => {
    let tagColor = config3.colors.tag;
    return tagColor.open + "<" + type5 + (printedProps && tagColor.close + printedProps + config3.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config3.spacingOuter + indentation + tagColor.open + "</" + type5 : (printedProps && !config3.min ? "" : " ") + "/") + ">" + tagColor.close;
  };
  exports.printElement = printElement3;
  var printElementAsLeaf3 = (type5, config3) => {
    let tagColor = config3.colors.tag;
    return tagColor.open + "<" + type5 + tagColor.close + " " + tagColor.open + " />" + tagColor.close;
  };
  exports.printElementAsLeaf = printElementAsLeaf3;
} });
var require_DOMElement = __commonJS({ "../../node_modules/pretty-format/build/plugins/DOMElement.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.test = exports.serialize = exports.default = void 0;
  var _markup = require_markup(), ELEMENT_NODE3 = 1, TEXT_NODE3 = 3, COMMENT_NODE3 = 8, FRAGMENT_NODE3 = 11, ELEMENT_REGEXP3 = /^((HTML|SVG)\w*)?Element$/, testHasAttribute22 = (val) => {
    try {
      return typeof val.hasAttribute == "function" && val.hasAttribute("is");
    } catch {
      return false;
    }
  }, testNode3 = (val) => {
    let constructorName = val.constructor.name, { nodeType, tagName } = val, isCustomElement3 = typeof tagName == "string" && tagName.includes("-") || testHasAttribute22(val);
    return nodeType === ELEMENT_NODE3 && (ELEMENT_REGEXP3.test(constructorName) || isCustomElement3) || nodeType === TEXT_NODE3 && constructorName === "Text" || nodeType === COMMENT_NODE3 && constructorName === "Comment" || nodeType === FRAGMENT_NODE3 && constructorName === "DocumentFragment";
  }, test3 = (val) => {
    var _val$constructor;
    return (val == null || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode3(val);
  };
  exports.test = test3;
  function nodeIsText3(node) {
    return node.nodeType === TEXT_NODE3;
  }
  function nodeIsComment3(node) {
    return node.nodeType === COMMENT_NODE3;
  }
  function nodeIsFragment3(node) {
    return node.nodeType === FRAGMENT_NODE3;
  }
  var serialize22 = (node, config3, indentation, depth, refs2, printer22) => {
    if (nodeIsText3(node)) return (0, _markup.printText)(node.data, config3);
    if (nodeIsComment3(node)) return (0, _markup.printComment)(node.data, config3);
    let type5 = nodeIsFragment3(node) ? "DocumentFragment" : node.tagName.toLowerCase();
    return ++depth > config3.maxDepth ? (0, _markup.printElementAsLeaf)(type5, config3) : (0, _markup.printElement)(type5, (0, _markup.printProps)(nodeIsFragment3(node) ? [] : Array.from(node.attributes).map((attr) => attr.name).sort(), nodeIsFragment3(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}), config3, indentation + config3.indent, depth, refs2, printer22), (0, _markup.printChildren)(Array.prototype.slice.call(node.childNodes || node.children), config3, indentation + config3.indent, depth, refs2, printer22), config3, indentation);
  };
  exports.serialize = serialize22;
  var plugin22 = { serialize: serialize22, test: test3 }, _default2 = plugin22;
  exports.default = _default2;
} });
var require_Immutable = __commonJS({ "../../node_modules/pretty-format/build/plugins/Immutable.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.test = exports.serialize = exports.default = void 0;
  var _collections = require_collections(), IS_ITERABLE_SENTINEL22 = "@@__IMMUTABLE_ITERABLE__@@", IS_LIST_SENTINEL3 = "@@__IMMUTABLE_LIST__@@", IS_KEYED_SENTINEL3 = "@@__IMMUTABLE_KEYED__@@", IS_MAP_SENTINEL22 = "@@__IMMUTABLE_MAP__@@", IS_ORDERED_SENTINEL3 = "@@__IMMUTABLE_ORDERED__@@", IS_RECORD_SENTINEL22 = "@@__IMMUTABLE_RECORD__@@", IS_SEQ_SENTINEL22 = "@@__IMMUTABLE_SEQ__@@", IS_SET_SENTINEL3 = "@@__IMMUTABLE_SET__@@", IS_STACK_SENTINEL22 = "@@__IMMUTABLE_STACK__@@", getImmutableName22 = (name2) => "Immutable." + name2, printAsLeaf22 = (name2) => "[" + name2 + "]", SPACE22 = " ", LAZY22 = "", printImmutableEntries22 = (val, config3, indentation, depth, refs2, printer22, type5) => ++depth > config3.maxDepth ? printAsLeaf22(getImmutableName22(type5)) : getImmutableName22(type5) + SPACE22 + "{" + (0, _collections.printIteratorEntries)(val.entries(), config3, indentation, depth, refs2, printer22) + "}";
  function getRecordEntries22(val) {
    let i4 = 0;
    return { next() {
      if (i4 < val._keys.length) {
        let key2 = val._keys[i4++];
        return { done: false, value: [key2, val.get(key2)] };
      }
      return { done: true, value: void 0 };
    } };
  }
  var printImmutableRecord22 = (val, config3, indentation, depth, refs2, printer22) => {
    let name2 = getImmutableName22(val._name || "Record");
    return ++depth > config3.maxDepth ? printAsLeaf22(name2) : name2 + SPACE22 + "{" + (0, _collections.printIteratorEntries)(getRecordEntries22(val), config3, indentation, depth, refs2, printer22) + "}";
  }, printImmutableSeq22 = (val, config3, indentation, depth, refs2, printer22) => {
    let name2 = getImmutableName22("Seq");
    return ++depth > config3.maxDepth ? printAsLeaf22(name2) : val[IS_KEYED_SENTINEL3] ? name2 + SPACE22 + "{" + (val._iter || val._object ? (0, _collections.printIteratorEntries)(val.entries(), config3, indentation, depth, refs2, printer22) : LAZY22) + "}" : name2 + SPACE22 + "[" + (val._iter || val._array || val._collection || val._iterable ? (0, _collections.printIteratorValues)(val.values(), config3, indentation, depth, refs2, printer22) : LAZY22) + "]";
  }, printImmutableValues22 = (val, config3, indentation, depth, refs2, printer22, type5) => ++depth > config3.maxDepth ? printAsLeaf22(getImmutableName22(type5)) : getImmutableName22(type5) + SPACE22 + "[" + (0, _collections.printIteratorValues)(val.values(), config3, indentation, depth, refs2, printer22) + "]", serialize22 = (val, config3, indentation, depth, refs2, printer22) => val[IS_MAP_SENTINEL22] ? printImmutableEntries22(val, config3, indentation, depth, refs2, printer22, val[IS_ORDERED_SENTINEL3] ? "OrderedMap" : "Map") : val[IS_LIST_SENTINEL3] ? printImmutableValues22(val, config3, indentation, depth, refs2, printer22, "List") : val[IS_SET_SENTINEL3] ? printImmutableValues22(val, config3, indentation, depth, refs2, printer22, val[IS_ORDERED_SENTINEL3] ? "OrderedSet" : "Set") : val[IS_STACK_SENTINEL22] ? printImmutableValues22(val, config3, indentation, depth, refs2, printer22, "Stack") : val[IS_SEQ_SENTINEL22] ? printImmutableSeq22(val, config3, indentation, depth, refs2, printer22) : printImmutableRecord22(val, config3, indentation, depth, refs2, printer22);
  exports.serialize = serialize22;
  var test3 = (val) => val && (val[IS_ITERABLE_SENTINEL22] === true || val[IS_RECORD_SENTINEL22] === true);
  exports.test = test3;
  var plugin22 = { serialize: serialize22, test: test3 }, _default2 = plugin22;
  exports.default = _default2;
} });
var require_react_is_development = __commonJS({ "../../node_modules/pretty-format/node_modules/react-is/cjs/react-is.development.js"(exports) {
  (function() {
    var REACT_ELEMENT_TYPE = 60103, REACT_PORTAL_TYPE = 60106, REACT_FRAGMENT_TYPE = 60107, REACT_STRICT_MODE_TYPE = 60108, REACT_PROFILER_TYPE = 60114, REACT_PROVIDER_TYPE = 60109, REACT_CONTEXT_TYPE = 60110, REACT_FORWARD_REF_TYPE = 60112, REACT_SUSPENSE_TYPE = 60113, REACT_SUSPENSE_LIST_TYPE = 60120, REACT_MEMO_TYPE = 60115, REACT_LAZY_TYPE = 60116, REACT_BLOCK_TYPE = 60121, REACT_SERVER_BLOCK_TYPE = 60122, REACT_FUNDAMENTAL_TYPE = 60117, REACT_DEBUG_TRACING_MODE_TYPE = 60129, REACT_LEGACY_HIDDEN_TYPE = 60131;
    if (typeof Symbol == "function" && Symbol.for) {
      var symbolFor = Symbol.for;
      REACT_ELEMENT_TYPE = symbolFor("react.element"), REACT_PORTAL_TYPE = symbolFor("react.portal"), REACT_FRAGMENT_TYPE = symbolFor("react.fragment"), REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode"), REACT_PROFILER_TYPE = symbolFor("react.profiler"), REACT_PROVIDER_TYPE = symbolFor("react.provider"), REACT_CONTEXT_TYPE = symbolFor("react.context"), REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref"), REACT_SUSPENSE_TYPE = symbolFor("react.suspense"), REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list"), REACT_MEMO_TYPE = symbolFor("react.memo"), REACT_LAZY_TYPE = symbolFor("react.lazy"), REACT_BLOCK_TYPE = symbolFor("react.block"), REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block"), REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental"), symbolFor("react.scope"), symbolFor("react.opaque.id"), REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode"), symbolFor("react.offscreen"), REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
    }
    var enableScopeAPI = false;
    function isValidElementType(type5) {
      return !!(typeof type5 == "string" || typeof type5 == "function" || type5 === REACT_FRAGMENT_TYPE || type5 === REACT_PROFILER_TYPE || type5 === REACT_DEBUG_TRACING_MODE_TYPE || type5 === REACT_STRICT_MODE_TYPE || type5 === REACT_SUSPENSE_TYPE || type5 === REACT_SUSPENSE_LIST_TYPE || type5 === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI || typeof type5 == "object" && type5 !== null && (type5.$$typeof === REACT_LAZY_TYPE || type5.$$typeof === REACT_MEMO_TYPE || type5.$$typeof === REACT_PROVIDER_TYPE || type5.$$typeof === REACT_CONTEXT_TYPE || type5.$$typeof === REACT_FORWARD_REF_TYPE || type5.$$typeof === REACT_FUNDAMENTAL_TYPE || type5.$$typeof === REACT_BLOCK_TYPE || type5[0] === REACT_SERVER_BLOCK_TYPE));
    }
    function typeOf(object) {
      if (typeof object == "object" && object !== null) {
        var $$typeof = object.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type5 = object.type;
            switch (type5) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
                return type5;
              default:
                var $$typeofType = type5 && type5.$$typeof;
                switch ($$typeofType) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    var ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo = REACT_MEMO_TYPE, Portal = REACT_PORTAL_TYPE, Profiler = REACT_PROFILER_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, Suspense = REACT_SUSPENSE_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = false, hasWarnedAboutDeprecatedIsConcurrentMode = false;
    function isAsyncMode(object) {
      return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), false;
    }
    function isConcurrentMode(object) {
      return hasWarnedAboutDeprecatedIsConcurrentMode || (hasWarnedAboutDeprecatedIsConcurrentMode = true, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), false;
    }
    function isContextConsumer(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    }
    function isContextProvider(object) {
      return typeOf(object) === REACT_PROVIDER_TYPE;
    }
    function isElement5(object) {
      return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function isForwardRef(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }
    function isFragment(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    }
    function isLazy(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    }
    function isMemo(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    }
    function isPortal(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    }
    function isProfiler(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    }
    function isStrictMode(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }
    function isSuspense(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    }
    exports.ContextConsumer = ContextConsumer, exports.ContextProvider = ContextProvider, exports.Element = Element2, exports.ForwardRef = ForwardRef, exports.Fragment = Fragment, exports.Lazy = Lazy, exports.Memo = Memo, exports.Portal = Portal, exports.Profiler = Profiler, exports.StrictMode = StrictMode, exports.Suspense = Suspense, exports.isAsyncMode = isAsyncMode, exports.isConcurrentMode = isConcurrentMode, exports.isContextConsumer = isContextConsumer, exports.isContextProvider = isContextProvider, exports.isElement = isElement5, exports.isForwardRef = isForwardRef, exports.isFragment = isFragment, exports.isLazy = isLazy, exports.isMemo = isMemo, exports.isPortal = isPortal, exports.isProfiler = isProfiler, exports.isStrictMode = isStrictMode, exports.isSuspense = isSuspense, exports.isValidElementType = isValidElementType, exports.typeOf = typeOf;
  })();
} });
var require_react_is = __commonJS({ "../../node_modules/pretty-format/node_modules/react-is/index.js"(exports, module2) {
  module2.exports = require_react_is_development();
} });
var require_ReactElement = __commonJS({ "../../node_modules/pretty-format/build/plugins/ReactElement.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.test = exports.serialize = exports.default = void 0;
  var ReactIs = _interopRequireWildcard(require_react_is()), _markup = require_markup();
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap != "function") return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap(), cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj != "object" && typeof obj != "function") return { default: obj };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key2 in obj) if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj, key2)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key2, desc) : newObj[key2] = obj[key2];
    }
    return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
  }
  var getChildren22 = (arg, children = []) => (Array.isArray(arg) ? arg.forEach((item) => {
    getChildren22(item, children);
  }) : arg != null && arg !== false && children.push(arg), children), getType42 = (element) => {
    let type5 = element.type;
    if (typeof type5 == "string") return type5;
    if (typeof type5 == "function") return type5.displayName || type5.name || "Unknown";
    if (ReactIs.isFragment(element)) return "React.Fragment";
    if (ReactIs.isSuspense(element)) return "React.Suspense";
    if (typeof type5 == "object" && type5 !== null) {
      if (ReactIs.isContextProvider(element)) return "Context.Provider";
      if (ReactIs.isContextConsumer(element)) return "Context.Consumer";
      if (ReactIs.isForwardRef(element)) {
        if (type5.displayName) return type5.displayName;
        let functionName = type5.render.displayName || type5.render.name || "";
        return functionName !== "" ? "ForwardRef(" + functionName + ")" : "ForwardRef";
      }
      if (ReactIs.isMemo(element)) {
        let functionName = type5.displayName || type5.type.displayName || type5.type.name || "";
        return functionName !== "" ? "Memo(" + functionName + ")" : "Memo";
      }
    }
    return "UNDEFINED";
  }, getPropKeys22 = (element) => {
    let { props } = element;
    return Object.keys(props).filter((key2) => key2 !== "children" && props[key2] !== void 0).sort();
  }, serialize22 = (element, config3, indentation, depth, refs2, printer22) => ++depth > config3.maxDepth ? (0, _markup.printElementAsLeaf)(getType42(element), config3) : (0, _markup.printElement)(getType42(element), (0, _markup.printProps)(getPropKeys22(element), element.props, config3, indentation + config3.indent, depth, refs2, printer22), (0, _markup.printChildren)(getChildren22(element.props.children), config3, indentation + config3.indent, depth, refs2, printer22), config3, indentation);
  exports.serialize = serialize22;
  var test3 = (val) => val != null && ReactIs.isElement(val);
  exports.test = test3;
  var plugin22 = { serialize: serialize22, test: test3 }, _default2 = plugin22;
  exports.default = _default2;
} });
var require_ReactTestComponent = __commonJS({ "../../node_modules/pretty-format/build/plugins/ReactTestComponent.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.test = exports.serialize = exports.default = void 0;
  var _markup = require_markup(), global3 = function() {
    return typeof globalThis < "u" ? globalThis : typeof global3 < "u" ? global3 : typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
  }(), Symbol2 = global3["jest-symbol-do-not-touch"] || global3.Symbol, testSymbol22 = typeof Symbol2 == "function" && Symbol2.for ? Symbol2.for("react.test.json") : 245830487, getPropKeys22 = (object) => {
    let { props } = object;
    return props ? Object.keys(props).filter((key2) => props[key2] !== void 0).sort() : [];
  }, serialize22 = (object, config3, indentation, depth, refs2, printer22) => ++depth > config3.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config3) : (0, _markup.printElement)(object.type, object.props ? (0, _markup.printProps)(getPropKeys22(object), object.props, config3, indentation + config3.indent, depth, refs2, printer22) : "", object.children ? (0, _markup.printChildren)(object.children, config3, indentation + config3.indent, depth, refs2, printer22) : "", config3, indentation);
  exports.serialize = serialize22;
  var test3 = (val) => val && val.$$typeof === testSymbol22;
  exports.test = test3;
  var plugin22 = { serialize: serialize22, test: test3 }, _default2 = plugin22;
  exports.default = _default2;
} });
var require_build = __commonJS({ "../../node_modules/pretty-format/build/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = exports.DEFAULT_OPTIONS = void 0;
  exports.format = format4;
  exports.plugins = void 0;
  var _ansiStyles = _interopRequireDefault(require_ansi_styles2()), _collections = require_collections(), _AsymmetricMatcher = _interopRequireDefault(require_AsymmetricMatcher()), _ConvertAnsi = _interopRequireDefault(require_ConvertAnsi()), _DOMCollection = _interopRequireDefault(require_DOMCollection()), _DOMElement = _interopRequireDefault(require_DOMElement()), _Immutable = _interopRequireDefault(require_Immutable()), _ReactElement = _interopRequireDefault(require_ReactElement()), _ReactTestComponent = _interopRequireDefault(require_ReactTestComponent());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var toString4 = Object.prototype.toString, toISOString22 = Date.prototype.toISOString, errorToString22 = Error.prototype.toString, regExpToString22 = RegExp.prototype.toString, getConstructorName3 = (val) => typeof val.constructor == "function" && val.constructor.name || "Object", isWindow22 = (val) => typeof window < "u" && val === window, SYMBOL_REGEXP22 = /^Symbol\((.*)\)(.*)$/, NEWLINE_REGEXP22 = /\n/gi, PrettyFormatPluginError22 = class extends Error {
    constructor(message, stack) {
      super(message), this.stack = stack, this.name = this.constructor.name;
    }
  };
  function isToStringedArrayType22(toStringed) {
    return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
  }
  function printNumber22(val) {
    return Object.is(val, -0) ? "-0" : String(val);
  }
  function printBigInt22(val) {
    return `${val}n`;
  }
  function printFunction22(val, printFunctionName) {
    return printFunctionName ? "[Function " + (val.name || "anonymous") + "]" : "[Function]";
  }
  function printSymbol22(val) {
    return String(val).replace(SYMBOL_REGEXP22, "Symbol($1)");
  }
  function printError22(val) {
    return "[" + errorToString22.call(val) + "]";
  }
  function printBasicValue22(val, printFunctionName, escapeRegex, escapeString) {
    if (val === true || val === false) return "" + val;
    if (val === void 0) return "undefined";
    if (val === null) return "null";
    let typeOf = typeof val;
    if (typeOf === "number") return printNumber22(val);
    if (typeOf === "bigint") return printBigInt22(val);
    if (typeOf === "string") return escapeString ? '"' + val.replace(/"|\\/g, "\\$&") + '"' : '"' + val + '"';
    if (typeOf === "function") return printFunction22(val, printFunctionName);
    if (typeOf === "symbol") return printSymbol22(val);
    let toStringed = toString4.call(val);
    return toStringed === "[object WeakMap]" ? "WeakMap {}" : toStringed === "[object WeakSet]" ? "WeakSet {}" : toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]" ? printFunction22(val, printFunctionName) : toStringed === "[object Symbol]" ? printSymbol22(val) : toStringed === "[object Date]" ? isNaN(+val) ? "Date { NaN }" : toISOString22.call(val) : toStringed === "[object Error]" ? printError22(val) : toStringed === "[object RegExp]" ? escapeRegex ? regExpToString22.call(val).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&") : regExpToString22.call(val) : val instanceof Error ? printError22(val) : null;
  }
  function printComplexValue22(val, config3, indentation, depth, refs2, hasCalledToJSON) {
    if (refs2.indexOf(val) !== -1) return "[Circular]";
    refs2 = refs2.slice(), refs2.push(val);
    let hitMaxDepth = ++depth > config3.maxDepth, min = config3.min;
    if (config3.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON == "function" && !hasCalledToJSON) return printer22(val.toJSON(), config3, indentation, depth, refs2, true);
    let toStringed = toString4.call(val);
    return toStringed === "[object Arguments]" ? hitMaxDepth ? "[Arguments]" : (min ? "" : "Arguments ") + "[" + (0, _collections.printListItems)(val, config3, indentation, depth, refs2, printer22) + "]" : isToStringedArrayType22(toStringed) ? hitMaxDepth ? "[" + val.constructor.name + "]" : (min || !config3.printBasicPrototype && val.constructor.name === "Array" ? "" : val.constructor.name + " ") + "[" + (0, _collections.printListItems)(val, config3, indentation, depth, refs2, printer22) + "]" : toStringed === "[object Map]" ? hitMaxDepth ? "[Map]" : "Map {" + (0, _collections.printIteratorEntries)(val.entries(), config3, indentation, depth, refs2, printer22, " => ") + "}" : toStringed === "[object Set]" ? hitMaxDepth ? "[Set]" : "Set {" + (0, _collections.printIteratorValues)(val.values(), config3, indentation, depth, refs2, printer22) + "}" : hitMaxDepth || isWindow22(val) ? "[" + getConstructorName3(val) + "]" : (min || !config3.printBasicPrototype && getConstructorName3(val) === "Object" ? "" : getConstructorName3(val) + " ") + "{" + (0, _collections.printObjectProperties)(val, config3, indentation, depth, refs2, printer22) + "}";
  }
  function isNewPlugin22(plugin22) {
    return plugin22.serialize != null;
  }
  function printPlugin22(plugin22, val, config3, indentation, depth, refs2) {
    let printed;
    try {
      printed = isNewPlugin22(plugin22) ? plugin22.serialize(val, config3, indentation, depth, refs2, printer22) : plugin22.print(val, (valChild) => printer22(valChild, config3, indentation, depth, refs2), (str) => {
        let indentationNext = indentation + config3.indent;
        return indentationNext + str.replace(NEWLINE_REGEXP22, `
` + indentationNext);
      }, { edgeSpacing: config3.spacingOuter, min: config3.min, spacing: config3.spacingInner }, config3.colors);
    } catch (error) {
      throw new PrettyFormatPluginError22(error.message, error.stack);
    }
    if (typeof printed != "string") throw new Error(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
    return printed;
  }
  function findPlugin22(plugins4, val) {
    for (let p32 = 0; p32 < plugins4.length; p32++) try {
      if (plugins4[p32].test(val)) return plugins4[p32];
    } catch (error) {
      throw new PrettyFormatPluginError22(error.message, error.stack);
    }
    return null;
  }
  function printer22(val, config3, indentation, depth, refs2, hasCalledToJSON) {
    let plugin22 = findPlugin22(config3.plugins, val);
    if (plugin22 !== null) return printPlugin22(plugin22, val, config3, indentation, depth, refs2);
    let basicResult = printBasicValue22(val, config3.printFunctionName, config3.escapeRegex, config3.escapeString);
    return basicResult !== null ? basicResult : printComplexValue22(val, config3, indentation, depth, refs2, hasCalledToJSON);
  }
  var DEFAULT_THEME22 = { comment: "gray", content: "reset", prop: "yellow", tag: "cyan", value: "green" }, DEFAULT_THEME_KEYS22 = Object.keys(DEFAULT_THEME22), DEFAULT_OPTIONS22 = { callToJSON: true, compareKeys: void 0, escapeRegex: false, escapeString: true, highlight: false, indent: 2, maxDepth: 1 / 0, min: false, plugins: [], printBasicPrototype: true, printFunctionName: true, theme: DEFAULT_THEME22 };
  exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS22;
  function validateOptions22(options2) {
    if (Object.keys(options2).forEach((key2) => {
      if (!DEFAULT_OPTIONS22.hasOwnProperty(key2)) throw new Error(`pretty-format: Unknown option "${key2}".`);
    }), options2.min && options2.indent !== void 0 && options2.indent !== 0) throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
    if (options2.theme !== void 0) {
      if (options2.theme === null) throw new Error('pretty-format: Option "theme" must not be null.');
      if (typeof options2.theme != "object") throw new Error(`pretty-format: Option "theme" must be of type "object" but instead received "${typeof options2.theme}".`);
    }
  }
  var getColorsHighlight22 = (options2) => DEFAULT_THEME_KEYS22.reduce((colors, key2) => {
    let value2 = options2.theme && options2.theme[key2] !== void 0 ? options2.theme[key2] : DEFAULT_THEME22[key2], color = value2 && _ansiStyles.default[value2];
    if (color && typeof color.close == "string" && typeof color.open == "string") colors[key2] = color;
    else throw new Error(`pretty-format: Option "theme" has a key "${key2}" whose value "${value2}" is undefined in ansi-styles.`);
    return colors;
  }, /* @__PURE__ */ Object.create(null)), getColorsEmpty22 = () => DEFAULT_THEME_KEYS22.reduce((colors, key2) => (colors[key2] = { close: "", open: "" }, colors), /* @__PURE__ */ Object.create(null)), getPrintFunctionName22 = (options2) => options2 && options2.printFunctionName !== void 0 ? options2.printFunctionName : DEFAULT_OPTIONS22.printFunctionName, getEscapeRegex22 = (options2) => options2 && options2.escapeRegex !== void 0 ? options2.escapeRegex : DEFAULT_OPTIONS22.escapeRegex, getEscapeString22 = (options2) => options2 && options2.escapeString !== void 0 ? options2.escapeString : DEFAULT_OPTIONS22.escapeString, getConfig4 = (options2) => {
    var _options$printBasicPr;
    return { callToJSON: options2 && options2.callToJSON !== void 0 ? options2.callToJSON : DEFAULT_OPTIONS22.callToJSON, colors: options2 && options2.highlight ? getColorsHighlight22(options2) : getColorsEmpty22(), compareKeys: options2 && typeof options2.compareKeys == "function" ? options2.compareKeys : DEFAULT_OPTIONS22.compareKeys, escapeRegex: getEscapeRegex22(options2), escapeString: getEscapeString22(options2), indent: options2 && options2.min ? "" : createIndent22(options2 && options2.indent !== void 0 ? options2.indent : DEFAULT_OPTIONS22.indent), maxDepth: options2 && options2.maxDepth !== void 0 ? options2.maxDepth : DEFAULT_OPTIONS22.maxDepth, min: options2 && options2.min !== void 0 ? options2.min : DEFAULT_OPTIONS22.min, plugins: options2 && options2.plugins !== void 0 ? options2.plugins : DEFAULT_OPTIONS22.plugins, printBasicPrototype: (_options$printBasicPr = options2 == null ? void 0 : options2.printBasicPrototype) !== null && _options$printBasicPr !== void 0 ? _options$printBasicPr : true, printFunctionName: getPrintFunctionName22(options2), spacingInner: options2 && options2.min ? " " : `
`, spacingOuter: options2 && options2.min ? "" : `
` };
  };
  function createIndent22(indent) {
    return new Array(indent + 1).join(" ");
  }
  function format4(val, options2) {
    if (options2 && (validateOptions22(options2), options2.plugins)) {
      let plugin22 = findPlugin22(options2.plugins, val);
      if (plugin22 !== null) return printPlugin22(plugin22, val, getConfig4(options2), "", 0, []);
    }
    let basicResult = printBasicValue22(val, getPrintFunctionName22(options2), getEscapeRegex22(options2), getEscapeString22(options2));
    return basicResult !== null ? basicResult : printComplexValue22(val, getConfig4(options2), "", 0, []);
  }
  var plugins3 = { AsymmetricMatcher: _AsymmetricMatcher.default, ConvertAnsi: _ConvertAnsi.default, DOMCollection: _DOMCollection.default, DOMElement: _DOMElement.default, Immutable: _Immutable.default, ReactElement: _ReactElement.default, ReactTestComponent: _ReactTestComponent.default };
  exports.plugins = plugins3;
  var _default2 = format4;
  exports.default = _default2;
} });
var require_lz_string = __commonJS({ "../../node_modules/lz-string/libs/lz-string.js"(exports, module2) {
  var LZString = function() {
    var f42 = String.fromCharCode, keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", baseReverseDic = {};
    function getBaseValue(alphabet, character) {
      if (!baseReverseDic[alphabet]) {
        baseReverseDic[alphabet] = {};
        for (var i4 = 0; i4 < alphabet.length; i4++) baseReverseDic[alphabet][alphabet.charAt(i4)] = i4;
      }
      return baseReverseDic[alphabet][character];
    }
    var LZString2 = { compressToBase64: function(input2) {
      if (input2 == null) return "";
      var res = LZString2._compress(input2, 6, function(a22) {
        return keyStrBase64.charAt(a22);
      });
      switch (res.length % 4) {
        default:
        case 0:
          return res;
        case 1:
          return res + "===";
        case 2:
          return res + "==";
        case 3:
          return res + "=";
      }
    }, decompressFromBase64: function(input2) {
      return input2 == null ? "" : input2 == "" ? null : LZString2._decompress(input2.length, 32, function(index) {
        return getBaseValue(keyStrBase64, input2.charAt(index));
      });
    }, compressToUTF16: function(input2) {
      return input2 == null ? "" : LZString2._compress(input2, 15, function(a22) {
        return f42(a22 + 32);
      }) + " ";
    }, decompressFromUTF16: function(compressed) {
      return compressed == null ? "" : compressed == "" ? null : LZString2._decompress(compressed.length, 16384, function(index) {
        return compressed.charCodeAt(index) - 32;
      });
    }, compressToUint8Array: function(uncompressed) {
      for (var compressed = LZString2.compress(uncompressed), buf = new Uint8Array(compressed.length * 2), i4 = 0, TotalLen = compressed.length; i4 < TotalLen; i4++) {
        var current_value = compressed.charCodeAt(i4);
        buf[i4 * 2] = current_value >>> 8, buf[i4 * 2 + 1] = current_value % 256;
      }
      return buf;
    }, decompressFromUint8Array: function(compressed) {
      if (compressed == null) return LZString2.decompress(compressed);
      for (var buf = new Array(compressed.length / 2), i4 = 0, TotalLen = buf.length; i4 < TotalLen; i4++) buf[i4] = compressed[i4 * 2] * 256 + compressed[i4 * 2 + 1];
      var result2 = [];
      return buf.forEach(function(c3) {
        result2.push(f42(c3));
      }), LZString2.decompress(result2.join(""));
    }, compressToEncodedURIComponent: function(input2) {
      return input2 == null ? "" : LZString2._compress(input2, 6, function(a22) {
        return keyStrUriSafe.charAt(a22);
      });
    }, decompressFromEncodedURIComponent: function(input2) {
      return input2 == null ? "" : input2 == "" ? null : (input2 = input2.replace(/ /g, "+"), LZString2._decompress(input2.length, 32, function(index) {
        return getBaseValue(keyStrUriSafe, input2.charAt(index));
      }));
    }, compress: function(uncompressed) {
      return LZString2._compress(uncompressed, 16, function(a22) {
        return f42(a22);
      });
    }, _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
      if (uncompressed == null) return "";
      var i4, value2, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
      for (ii = 0; ii < uncompressed.length; ii += 1) if (context_c = uncompressed.charAt(ii), Object.prototype.hasOwnProperty.call(context_dictionary, context_c) || (context_dictionary[context_c] = context_dictSize++, context_dictionaryToCreate[context_c] = true), context_wc = context_w + context_c, Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) context_w = context_wc;
      else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
          if (context_w.charCodeAt(0) < 256) {
            for (i4 = 0; i4 < context_numBits; i4++) context_data_val = context_data_val << 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++;
            for (value2 = context_w.charCodeAt(0), i4 = 0; i4 < 8; i4++) context_data_val = context_data_val << 1 | value2 & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value2 = value2 >> 1;
          } else {
            for (value2 = 1, i4 = 0; i4 < context_numBits; i4++) context_data_val = context_data_val << 1 | value2, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value2 = 0;
            for (value2 = context_w.charCodeAt(0), i4 = 0; i4 < 16; i4++) context_data_val = context_data_val << 1 | value2 & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value2 = value2 >> 1;
          }
          context_enlargeIn--, context_enlargeIn == 0 && (context_enlargeIn = Math.pow(2, context_numBits), context_numBits++), delete context_dictionaryToCreate[context_w];
        } else for (value2 = context_dictionary[context_w], i4 = 0; i4 < context_numBits; i4++) context_data_val = context_data_val << 1 | value2 & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value2 = value2 >> 1;
        context_enlargeIn--, context_enlargeIn == 0 && (context_enlargeIn = Math.pow(2, context_numBits), context_numBits++), context_dictionary[context_wc] = context_dictSize++, context_w = String(context_c);
      }
      if (context_w !== "") {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
          if (context_w.charCodeAt(0) < 256) {
            for (i4 = 0; i4 < context_numBits; i4++) context_data_val = context_data_val << 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++;
            for (value2 = context_w.charCodeAt(0), i4 = 0; i4 < 8; i4++) context_data_val = context_data_val << 1 | value2 & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value2 = value2 >> 1;
          } else {
            for (value2 = 1, i4 = 0; i4 < context_numBits; i4++) context_data_val = context_data_val << 1 | value2, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value2 = 0;
            for (value2 = context_w.charCodeAt(0), i4 = 0; i4 < 16; i4++) context_data_val = context_data_val << 1 | value2 & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value2 = value2 >> 1;
          }
          context_enlargeIn--, context_enlargeIn == 0 && (context_enlargeIn = Math.pow(2, context_numBits), context_numBits++), delete context_dictionaryToCreate[context_w];
        } else for (value2 = context_dictionary[context_w], i4 = 0; i4 < context_numBits; i4++) context_data_val = context_data_val << 1 | value2 & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value2 = value2 >> 1;
        context_enlargeIn--, context_enlargeIn == 0 && (context_enlargeIn = Math.pow(2, context_numBits), context_numBits++);
      }
      for (value2 = 2, i4 = 0; i4 < context_numBits; i4++) context_data_val = context_data_val << 1 | value2 & 1, context_data_position == bitsPerChar - 1 ? (context_data_position = 0, context_data.push(getCharFromInt(context_data_val)), context_data_val = 0) : context_data_position++, value2 = value2 >> 1;
      for (; ; ) if (context_data_val = context_data_val << 1, context_data_position == bitsPerChar - 1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      } else context_data_position++;
      return context_data.join("");
    }, decompress: function(compressed) {
      return compressed == null ? "" : compressed == "" ? null : LZString2._decompress(compressed.length, 32768, function(index) {
        return compressed.charCodeAt(index);
      });
    }, _decompress: function(length, resetValue, getNextValue) {
      var dictionary = [], enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result2 = [], i4, w22, bits, resb, maxpower, power, c3, data = { val: getNextValue(0), position: resetValue, index: 1 };
      for (i4 = 0; i4 < 3; i4 += 1) dictionary[i4] = i4;
      for (bits = 0, maxpower = Math.pow(2, 2), power = 1; power != maxpower; ) resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
      switch (bits) {
        case 0:
          for (bits = 0, maxpower = Math.pow(2, 8), power = 1; power != maxpower; ) resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
          c3 = f42(bits);
          break;
        case 1:
          for (bits = 0, maxpower = Math.pow(2, 16), power = 1; power != maxpower; ) resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
          c3 = f42(bits);
          break;
        case 2:
          return "";
      }
      for (dictionary[3] = c3, w22 = c3, result2.push(c3); ; ) {
        if (data.index > length) return "";
        for (bits = 0, maxpower = Math.pow(2, numBits), power = 1; power != maxpower; ) resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
        switch (c3 = bits) {
          case 0:
            for (bits = 0, maxpower = Math.pow(2, 8), power = 1; power != maxpower; ) resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
            dictionary[dictSize++] = f42(bits), c3 = dictSize - 1, enlargeIn--;
            break;
          case 1:
            for (bits = 0, maxpower = Math.pow(2, 16), power = 1; power != maxpower; ) resb = data.val & data.position, data.position >>= 1, data.position == 0 && (data.position = resetValue, data.val = getNextValue(data.index++)), bits |= (resb > 0 ? 1 : 0) * power, power <<= 1;
            dictionary[dictSize++] = f42(bits), c3 = dictSize - 1, enlargeIn--;
            break;
          case 2:
            return result2.join("");
        }
        if (enlargeIn == 0 && (enlargeIn = Math.pow(2, numBits), numBits++), dictionary[c3]) entry = dictionary[c3];
        else if (c3 === dictSize) entry = w22 + w22.charAt(0);
        else return null;
        result2.push(entry), dictionary[dictSize++] = w22 + entry.charAt(0), enlargeIn--, w22 = entry, enlargeIn == 0 && (enlargeIn = Math.pow(2, numBits), numBits++);
      }
    } };
    return LZString2;
  }();
  typeof define == "function" && define.amd ? define(function() {
    return LZString;
  }) : typeof module2 < "u" && module2 != null ? module2.exports = LZString : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
    return LZString;
  });
} });
var __defProp2 = Object.defineProperty;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __name = (target, value2) => __defProp2(target, "name", { value: value2, configurable: true });
var __commonJS2 = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export22 = (target, all) => {
  for (var name2 in all) __defProp2(target, name2, { get: all[name2], enumerable: true });
};
var require_util = __commonJS2({ "(disabled):util"() {
} });
var utils_exports = {};
__export22(utils_exports, { addChainableMethod: () => addChainableMethod, addLengthGuard: () => addLengthGuard, addMethod: () => addMethod, addProperty: () => addProperty, checkError: () => check_error_exports, compareByInspect: () => compareByInspect, eql: () => deep_eql_default, expectTypes: () => expectTypes, flag: () => flag, getActual: () => getActual, getMessage: () => getMessage2, getName: () => getName, getOperator: () => getOperator, getOwnEnumerableProperties: () => getOwnEnumerableProperties, getOwnEnumerablePropertySymbols: () => getOwnEnumerablePropertySymbols, getPathInfo: () => getPathInfo, hasProperty: () => hasProperty, inspect: () => inspect22, isNaN: () => isNaN222, isProxyEnabled: () => isProxyEnabled, isRegExp: () => isRegExp2, objDisplay: () => objDisplay, overwriteChainableMethod: () => overwriteChainableMethod, overwriteMethod: () => overwriteMethod, overwriteProperty: () => overwriteProperty, proxify: () => proxify, test: () => test2, transferFlags: () => transferFlags, type: () => type });
var check_error_exports = {};
__export22(check_error_exports, { compatibleConstructor: () => compatibleConstructor, compatibleInstance: () => compatibleInstance, compatibleMessage: () => compatibleMessage, getConstructorName: () => getConstructorName2, getMessage: () => getMessage });
function isErrorInstance(obj) {
  return obj instanceof Error || Object.prototype.toString.call(obj) === "[object Error]";
}
__name(isErrorInstance, "isErrorInstance");
function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
function compatibleInstance(thrown, errorLike) {
  return isErrorInstance(errorLike) && thrown === errorLike;
}
__name(compatibleInstance, "compatibleInstance");
function compatibleConstructor(thrown, errorLike) {
  return isErrorInstance(errorLike) ? thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor : (typeof errorLike == "object" || typeof errorLike == "function") && errorLike.prototype ? thrown.constructor === errorLike || thrown instanceof errorLike : false;
}
__name(compatibleConstructor, "compatibleConstructor");
function compatibleMessage(thrown, errMatcher) {
  let comparisonString = typeof thrown == "string" ? thrown : thrown.message;
  return isRegExp(errMatcher) ? errMatcher.test(comparisonString) : typeof errMatcher == "string" ? comparisonString.indexOf(errMatcher) !== -1 : false;
}
__name(compatibleMessage, "compatibleMessage");
function getConstructorName2(errorLike) {
  let constructorName = errorLike;
  return isErrorInstance(errorLike) ? constructorName = errorLike.constructor.name : typeof errorLike == "function" && (constructorName = errorLike.name, constructorName === "" && (constructorName = new errorLike().name || constructorName)), constructorName;
}
__name(getConstructorName2, "getConstructorName");
function getMessage(errorLike) {
  let msg = "";
  return errorLike && errorLike.message ? msg = errorLike.message : typeof errorLike == "string" && (msg = errorLike), msg;
}
__name(getMessage, "getMessage");
function flag(obj, key2, value2) {
  var flags = obj.__flags || (obj.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3) flags[key2] = value2;
  else return flags[key2];
}
__name(flag, "flag");
function test2(obj, args2) {
  var negate = flag(obj, "negate"), expr = args2[0];
  return negate ? !expr : expr;
}
__name(test2, "test");
function type(obj) {
  if (typeof obj > "u") return "undefined";
  if (obj === null) return "null";
  let stringTag = obj[Symbol.toStringTag];
  return typeof stringTag == "string" ? stringTag : Object.prototype.toString.call(obj).slice(8, -1);
}
__name(type, "type");
var canElideFrames = "captureStackTrace" in Error;
var _a;
var AssertionError = (_a = class extends Error {
  constructor(message = "Unspecified AssertionError", props, ssf) {
    super(message);
    __publicField(this, "message");
    this.message = message, canElideFrames && Error.captureStackTrace(this, ssf || _a);
    for (let key2 in props) key2 in this || (this[key2] = props[key2]);
  }
  get name() {
    return "AssertionError";
  }
  get ok() {
    return false;
  }
  toJSON(stack) {
    return { ...this, name: this.name, message: this.message, ok: false, stack: stack !== false ? this.stack : void 0 };
  }
}, __name(_a, "AssertionError"), _a);
function expectTypes(obj, types) {
  var flagMsg = flag(obj, "message"), ssfi = flag(obj, "ssfi");
  flagMsg = flagMsg ? flagMsg + ": " : "", obj = flag(obj, "object"), types = types.map(function(t4) {
    return t4.toLowerCase();
  }), types.sort();
  var str = types.map(function(t4, index) {
    var art = ~["a", "e", "i", "o", "u"].indexOf(t4.charAt(0)) ? "an" : "a", or2 = types.length > 1 && index === types.length - 1 ? "or " : "";
    return or2 + art + " " + t4;
  }).join(", "), objType = type(obj).toLowerCase();
  if (!types.some(function(expected) {
    return objType === expected;
  })) throw new AssertionError(flagMsg + "object tested must be " + str + ", but " + objType + " given", void 0, ssfi);
}
__name(expectTypes, "expectTypes");
function getActual(obj, args2) {
  return args2.length > 4 ? args2[4] : obj._obj;
}
__name(getActual, "getActual");
var ansiColors2 = { bold: ["1", "22"], dim: ["2", "22"], italic: ["3", "23"], underline: ["4", "24"], inverse: ["7", "27"], hidden: ["8", "28"], strike: ["9", "29"], black: ["30", "39"], red: ["31", "39"], green: ["32", "39"], yellow: ["33", "39"], blue: ["34", "39"], magenta: ["35", "39"], cyan: ["36", "39"], white: ["37", "39"], brightblack: ["30;1", "39"], brightred: ["31;1", "39"], brightgreen: ["32;1", "39"], brightyellow: ["33;1", "39"], brightblue: ["34;1", "39"], brightmagenta: ["35;1", "39"], brightcyan: ["36;1", "39"], brightwhite: ["37;1", "39"], grey: ["90", "39"] };
var styles2 = { special: "cyan", number: "yellow", bigint: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", symbol: "green", date: "magenta", regexp: "red" };
var truncator2 = "";
function colorise2(value2, styleType) {
  let color = ansiColors2[styles2[styleType]] || ansiColors2[styleType] || "";
  return color ? `\x1B[${color[0]}m${String(value2)}\x1B[${color[1]}m` : String(value2);
}
__name(colorise2, "colorise");
function normaliseOptions2({ showHidden = false, depth = 2, colors = false, customInspect = true, showProxy = false, maxArrayLength = 1 / 0, breakLength = 1 / 0, seen = [], truncate: truncate222 = 1 / 0, stylize = String } = {}, inspect322) {
  let options2 = { showHidden: !!showHidden, depth: Number(depth), colors: !!colors, customInspect: !!customInspect, showProxy: !!showProxy, maxArrayLength: Number(maxArrayLength), breakLength: Number(breakLength), truncate: Number(truncate222), seen, inspect: inspect322, stylize };
  return options2.colors && (options2.stylize = colorise2), options2;
}
__name(normaliseOptions2, "normaliseOptions");
function truncate2(string, length, tail = truncator2) {
  string = String(string);
  let tailLength = tail.length, stringLength = string.length;
  return tailLength > length && stringLength > tailLength ? tail : stringLength > length && stringLength > tailLength ? `${string.slice(0, length - tailLength)}${tail}` : string;
}
__name(truncate2, "truncate");
function inspectList2(list, options2, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options2.inspect;
  let size = list.length;
  if (size === 0) return "";
  let originalLength = options2.truncate, output = "", peek = "", truncated = "";
  for (let i4 = 0; i4 < size; i4 += 1) {
    let last = i4 + 1 === list.length, secondToLast = i4 + 2 === list.length;
    truncated = `${truncator2}(${list.length - i4})`;
    let value2 = list[i4];
    options2.truncate = originalLength - output.length - (last ? 0 : separator.length);
    let string = peek || inspectItem(value2, options2) + (last ? "" : separator), nextLength = output.length + string.length, truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength || !last && !secondToLast && truncatedLength > originalLength || (peek = last ? "" : inspectItem(list[i4 + 1], options2) + (secondToLast ? "" : separator), !last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength)) break;
    if (output += string, !last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator2}(${list.length - i4 - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
__name(inspectList2, "inspectList");
function quoteComplexKey2(key2) {
  return key2.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? key2 : JSON.stringify(key2).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
__name(quoteComplexKey2, "quoteComplexKey");
function inspectProperty2([key2, value2], options2) {
  return options2.truncate -= 2, typeof key2 == "string" ? key2 = quoteComplexKey2(key2) : typeof key2 != "number" && (key2 = `[${options2.inspect(key2, options2)}]`), options2.truncate -= key2.length, value2 = options2.inspect(value2, options2), `${key2}: ${value2}`;
}
__name(inspectProperty2, "inspectProperty");
function inspectArray2(array, options2) {
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length) return "[]";
  options2.truncate -= 4;
  let listContents = inspectList2(array, options2);
  options2.truncate -= listContents.length;
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList2(nonIndexProperties.map((key2) => [key2, array[key2]]), options2, inspectProperty2)), `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectArray2, "inspectArray");
var getArrayName2 = __name((array) => typeof Buffer == "function" && array instanceof Buffer ? "Buffer" : array[Symbol.toStringTag] ? array[Symbol.toStringTag] : array.constructor.name, "getArrayName");
function inspectTypedArray2(array, options2) {
  let name2 = getArrayName2(array);
  options2.truncate -= name2.length + 4;
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length) return `${name2}[]`;
  let output = "";
  for (let i4 = 0; i4 < array.length; i4++) {
    let string = `${options2.stylize(truncate2(array[i4], options2.truncate), "number")}${i4 === array.length - 1 ? "" : ", "}`;
    if (options2.truncate -= string.length, array[i4] !== array.length && options2.truncate <= 3) {
      output += `${truncator2}(${array.length - array[i4] + 1})`;
      break;
    }
    output += string;
  }
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList2(nonIndexProperties.map((key2) => [key2, array[key2]]), options2, inspectProperty2)), `${name2}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectTypedArray2, "inspectTypedArray");
function inspectDate2(dateObject, options2) {
  let stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null) return "Invalid Date";
  let split = stringRepresentation.split("T"), date = split[0];
  return options2.stylize(`${date}T${truncate2(split[1], options2.truncate - date.length - 1)}`, "date");
}
__name(inspectDate2, "inspectDate");
function inspectFunction2(func, options2) {
  let functionType = func[Symbol.toStringTag] || "Function", name2 = func.name;
  return name2 ? options2.stylize(`[${functionType} ${truncate2(name2, options2.truncate - 11)}]`, "special") : options2.stylize(`[${functionType}]`, "special");
}
__name(inspectFunction2, "inspectFunction");
function inspectMapEntry2([key2, value2], options2) {
  return options2.truncate -= 4, key2 = options2.inspect(key2, options2), options2.truncate -= key2.length, value2 = options2.inspect(value2, options2), `${key2} => ${value2}`;
}
__name(inspectMapEntry2, "inspectMapEntry");
function mapToEntries2(map) {
  let entries = [];
  return map.forEach((value2, key2) => {
    entries.push([key2, value2]);
  }), entries;
}
__name(mapToEntries2, "mapToEntries");
function inspectMap2(map, options2) {
  return map.size - 1 <= 0 ? "Map{}" : (options2.truncate -= 7, `Map{ ${inspectList2(mapToEntries2(map), options2, inspectMapEntry2)} }`);
}
__name(inspectMap2, "inspectMap");
var isNaN22 = Number.isNaN || ((i4) => i4 !== i4);
function inspectNumber2(number, options2) {
  return isNaN22(number) ? options2.stylize("NaN", "number") : number === 1 / 0 ? options2.stylize("Infinity", "number") : number === -1 / 0 ? options2.stylize("-Infinity", "number") : number === 0 ? options2.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number") : options2.stylize(truncate2(String(number), options2.truncate), "number");
}
__name(inspectNumber2, "inspectNumber");
function inspectBigInt2(number, options2) {
  let nums = truncate2(number.toString(), options2.truncate - 1);
  return nums !== truncator2 && (nums += "n"), options2.stylize(nums, "bigint");
}
__name(inspectBigInt2, "inspectBigInt");
function inspectRegExp2(value2, options2) {
  let flags = value2.toString().split("/")[2], sourceLength = options2.truncate - (2 + flags.length), source2 = value2.source;
  return options2.stylize(`/${truncate2(source2, sourceLength)}/${flags}`, "regexp");
}
__name(inspectRegExp2, "inspectRegExp");
function arrayFromSet2(set2) {
  let values = [];
  return set2.forEach((value2) => {
    values.push(value2);
  }), values;
}
__name(arrayFromSet2, "arrayFromSet");
function inspectSet2(set2, options2) {
  return set2.size === 0 ? "Set{}" : (options2.truncate -= 7, `Set{ ${inspectList2(arrayFromSet2(set2), options2)} }`);
}
__name(inspectSet2, "inspectSet");
var stringEscapeChars2 = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var escapeCharacters2 = { "\b": "\\b", "	": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", "'": "\\'", "\\": "\\\\" };
var hex2 = 16;
var unicodeLength2 = 4;
function escape2(char) {
  return escapeCharacters2[char] || `\\u${`0000${char.charCodeAt(0).toString(hex2)}`.slice(-unicodeLength2)}`;
}
__name(escape2, "escape");
function inspectString2(string, options2) {
  return stringEscapeChars2.test(string) && (string = string.replace(stringEscapeChars2, escape2)), options2.stylize(`'${truncate2(string, options2.truncate - 2)}'`, "string");
}
__name(inspectString2, "inspectString");
function inspectSymbol2(value2) {
  return "description" in Symbol.prototype ? value2.description ? `Symbol(${value2.description})` : "Symbol()" : value2.toString();
}
__name(inspectSymbol2, "inspectSymbol");
var getPromiseValue2 = __name(() => "Promise{}", "getPromiseValue");
try {
  let { getPromiseDetails, kPending, kRejected } = process.binding("util");
  Array.isArray(getPromiseDetails(Promise.resolve())) && (getPromiseValue2 = __name((value2, options2) => {
    let [state, innerValue] = getPromiseDetails(value2);
    return state === kPending ? "Promise{<pending>}" : `Promise${state === kRejected ? "!" : ""}{${options2.inspect(innerValue, options2)}}`;
  }, "getPromiseValue"));
} catch {
}
var promise_default2 = getPromiseValue2;
function inspectObject3(object, options2) {
  let properties = Object.getOwnPropertyNames(object), symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
  if (properties.length === 0 && symbols.length === 0) return "{}";
  if (options2.truncate -= 4, options2.seen = options2.seen || [], options2.seen.indexOf(object) >= 0) return "[Circular]";
  options2.seen.push(object);
  let propertyContents = inspectList2(properties.map((key2) => [key2, object[key2]]), options2, inspectProperty2), symbolContents = inspectList2(symbols.map((key2) => [key2, object[key2]]), options2, inspectProperty2);
  options2.seen.pop();
  let sep = "";
  return propertyContents && symbolContents && (sep = ", "), `{ ${propertyContents}${sep}${symbolContents} }`;
}
__name(inspectObject3, "inspectObject");
var toStringTag2 = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass2(value2, options2) {
  let name2 = "";
  return toStringTag2 && toStringTag2 in value2 && (name2 = value2[toStringTag2]), name2 = name2 || value2.constructor.name, (!name2 || name2 === "_class") && (name2 = "<Anonymous Class>"), options2.truncate -= name2.length, `${name2}${inspectObject3(value2, options2)}`;
}
__name(inspectClass2, "inspectClass");
function inspectArguments2(args2, options2) {
  return args2.length === 0 ? "Arguments[]" : (options2.truncate -= 13, `Arguments[ ${inspectList2(args2, options2)} ]`);
}
__name(inspectArguments2, "inspectArguments");
var errorKeys2 = ["stack", "line", "column", "name", "message", "fileName", "lineNumber", "columnNumber", "number", "description"];
function inspectObject22(error, options2) {
  let properties = Object.getOwnPropertyNames(error).filter((key2) => errorKeys2.indexOf(key2) === -1), name2 = error.name;
  options2.truncate -= name2.length;
  let message = "";
  typeof error.message == "string" ? message = truncate2(error.message, options2.truncate) : properties.unshift("message"), message = message ? `: ${message}` : "", options2.truncate -= message.length + 5;
  let propertyContents = inspectList2(properties.map((key2) => [key2, error[key2]]), options2, inspectProperty2);
  return `${name2}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
__name(inspectObject22, "inspectObject");
function inspectAttribute2([key2, value2], options2) {
  return options2.truncate -= 3, value2 ? `${options2.stylize(String(key2), "yellow")}=${options2.stylize(`"${value2}"`, "string")}` : `${options2.stylize(String(key2), "yellow")}`;
}
__name(inspectAttribute2, "inspectAttribute");
function inspectHTMLCollection2(collection, options2) {
  return inspectList2(collection, options2, inspectHTML2, `
`);
}
__name(inspectHTMLCollection2, "inspectHTMLCollection");
function inspectHTML2(element, options2) {
  let properties = element.getAttributeNames(), name2 = element.tagName.toLowerCase(), head = options2.stylize(`<${name2}`, "special"), headClose = options2.stylize(">", "special"), tail = options2.stylize(`</${name2}>`, "special");
  options2.truncate -= name2.length * 2 + 5;
  let propertyContents = "";
  properties.length > 0 && (propertyContents += " ", propertyContents += inspectList2(properties.map((key2) => [key2, element.getAttribute(key2)]), options2, inspectAttribute2, " ")), options2.truncate -= propertyContents.length;
  let truncate222 = options2.truncate, children = inspectHTMLCollection2(element.children, options2);
  return children && children.length > truncate222 && (children = `${truncator2}(${element.children.length})`), `${head}${propertyContents}${headClose}${children}${tail}`;
}
__name(inspectHTML2, "inspectHTML");
var symbolsSupported2 = typeof Symbol == "function" && typeof Symbol.for == "function";
var chaiInspect2 = symbolsSupported2 ? Symbol.for("chai/inspect") : "@@chai/inspect";
var nodeInspect2 = false;
try {
  let nodeUtil = require_util();
  nodeInspect2 = nodeUtil.inspect ? nodeUtil.inspect.custom : false;
} catch {
  nodeInspect2 = false;
}
var constructorMap2 = /* @__PURE__ */ new WeakMap();
var stringTagMap2 = {};
var baseTypesMap2 = { undefined: (value2, options2) => options2.stylize("undefined", "undefined"), null: (value2, options2) => options2.stylize("null", "null"), boolean: (value2, options2) => options2.stylize(String(value2), "boolean"), Boolean: (value2, options2) => options2.stylize(String(value2), "boolean"), number: inspectNumber2, Number: inspectNumber2, bigint: inspectBigInt2, BigInt: inspectBigInt2, string: inspectString2, String: inspectString2, function: inspectFunction2, Function: inspectFunction2, symbol: inspectSymbol2, Symbol: inspectSymbol2, Array: inspectArray2, Date: inspectDate2, Map: inspectMap2, Set: inspectSet2, RegExp: inspectRegExp2, Promise: promise_default2, WeakSet: (value2, options2) => options2.stylize("WeakSet{}", "special"), WeakMap: (value2, options2) => options2.stylize("WeakMap{}", "special"), Arguments: inspectArguments2, Int8Array: inspectTypedArray2, Uint8Array: inspectTypedArray2, Uint8ClampedArray: inspectTypedArray2, Int16Array: inspectTypedArray2, Uint16Array: inspectTypedArray2, Int32Array: inspectTypedArray2, Uint32Array: inspectTypedArray2, Float32Array: inspectTypedArray2, Float64Array: inspectTypedArray2, Generator: () => "", DataView: () => "", ArrayBuffer: () => "", Error: inspectObject22, HTMLCollection: inspectHTMLCollection2, NodeList: inspectHTMLCollection2 };
var inspectCustom2 = __name((value2, options2, type32) => chaiInspect2 in value2 && typeof value2[chaiInspect2] == "function" ? value2[chaiInspect2](options2) : nodeInspect2 && nodeInspect2 in value2 && typeof value2[nodeInspect2] == "function" ? value2[nodeInspect2](options2.depth, options2) : "inspect" in value2 && typeof value2.inspect == "function" ? value2.inspect(options2.depth, options2) : "constructor" in value2 && constructorMap2.has(value2.constructor) ? constructorMap2.get(value2.constructor)(value2, options2) : stringTagMap2[type32] ? stringTagMap2[type32](value2, options2) : "", "inspectCustom");
var toString3 = Object.prototype.toString;
function inspect3(value2, opts = {}) {
  let options2 = normaliseOptions2(opts, inspect3), { customInspect } = options2, type32 = value2 === null ? "null" : typeof value2;
  if (type32 === "object" && (type32 = toString3.call(value2).slice(8, -1)), type32 in baseTypesMap2) return baseTypesMap2[type32](value2, options2);
  if (customInspect && value2) {
    let output = inspectCustom2(value2, options2, type32);
    if (output) return typeof output == "string" ? output : inspect3(output, options2);
  }
  let proto = value2 ? Object.getPrototypeOf(value2) : false;
  return proto === Object.prototype || proto === null ? inspectObject3(value2, options2) : value2 && typeof HTMLElement == "function" && value2 instanceof HTMLElement ? inspectHTML2(value2, options2) : "constructor" in value2 ? value2.constructor !== Object ? inspectClass2(value2, options2) : inspectObject3(value2, options2) : value2 === Object(value2) ? inspectObject3(value2, options2) : options2.stylize(String(value2), type32);
}
__name(inspect3, "inspect");
var config = { includeStack: false, showDiff: true, truncateThreshold: 40, useProxy: true, proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"], deepEqual: null };
function inspect22(obj, showHidden, depth, colors) {
  var options2 = { colors, depth: typeof depth > "u" ? 2 : depth, showHidden, truncate: config.truncateThreshold ? config.truncateThreshold : 1 / 0 };
  return inspect3(obj, options2);
}
__name(inspect22, "inspect");
function objDisplay(obj) {
  var str = inspect22(obj), type32 = Object.prototype.toString.call(obj);
  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type32 === "[object Function]") return !obj.name || obj.name === "" ? "[Function]" : "[Function: " + obj.name + "]";
    if (type32 === "[object Array]") return "[ Array(" + obj.length + ") ]";
    if (type32 === "[object Object]") {
      var keys2 = Object.keys(obj), kstr = keys2.length > 2 ? keys2.splice(0, 2).join(", ") + ", ..." : keys2.join(", ");
      return "{ Object (" + kstr + ") }";
    } else return str;
  } else return str;
}
__name(objDisplay, "objDisplay");
function getMessage2(obj, args2) {
  var negate = flag(obj, "negate"), val = flag(obj, "object"), expected = args2[3], actual = getActual(obj, args2), msg = negate ? args2[2] : args2[1], flagMsg = flag(obj, "message");
  return typeof msg == "function" && (msg = msg()), msg = msg || "", msg = msg.replace(/#\{this\}/g, function() {
    return objDisplay(val);
  }).replace(/#\{act\}/g, function() {
    return objDisplay(actual);
  }).replace(/#\{exp\}/g, function() {
    return objDisplay(expected);
  }), flagMsg ? flagMsg + ": " + msg : msg;
}
__name(getMessage2, "getMessage");
function transferFlags(assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */ Object.create(null));
  object.__flags || (object.__flags = /* @__PURE__ */ Object.create(null)), includeAll = arguments.length === 3 ? includeAll : true;
  for (var flag3 in flags) (includeAll || flag3 !== "object" && flag3 !== "ssfi" && flag3 !== "lockSsfi" && flag3 != "message") && (object.__flags[flag3] = flags[flag3]);
}
__name(transferFlags, "transferFlags");
function type2(obj) {
  if (typeof obj > "u") return "undefined";
  if (obj === null) return "null";
  let stringTag = obj[Symbol.toStringTag];
  return typeof stringTag == "string" ? stringTag : Object.prototype.toString.call(obj).slice(8, -1);
}
__name(type2, "type");
function FakeMap() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
__name(FakeMap, "FakeMap");
FakeMap.prototype = { get: __name(function(key2) {
  return key2[this._key];
}, "get"), set: __name(function(key2, value2) {
  Object.isExtensible(key2) && Object.defineProperty(key2, this._key, { value: value2, configurable: true });
}, "set") };
var MemoizeMap = typeof WeakMap == "function" ? WeakMap : FakeMap;
function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) return null;
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    var result2 = leftHandMap.get(rightHandOperand);
    if (typeof result2 == "boolean") return result2;
  }
  return null;
}
__name(memoizeCompare, "memoizeCompare");
function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result2) {
  if (!(!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand))) {
    var leftHandMap = memoizeMap.get(leftHandOperand);
    leftHandMap ? leftHandMap.set(rightHandOperand, result2) : (leftHandMap = new MemoizeMap(), leftHandMap.set(rightHandOperand, result2), memoizeMap.set(leftHandOperand, leftHandMap));
  }
}
__name(memoizeSet, "memoizeSet");
var deep_eql_default = deepEqual;
function deepEqual(leftHandOperand, rightHandOperand, options2) {
  if (options2 && options2.comparator) return extensiveDeepEqual(leftHandOperand, rightHandOperand, options2);
  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
  return simpleResult !== null ? simpleResult : extensiveDeepEqual(leftHandOperand, rightHandOperand, options2);
}
__name(deepEqual, "deepEqual");
function simpleEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand === rightHandOperand ? leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand : leftHandOperand !== leftHandOperand && rightHandOperand !== rightHandOperand ? true : isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand) ? false : null;
}
__name(simpleEqual, "simpleEqual");
function extensiveDeepEqual(leftHandOperand, rightHandOperand, options2) {
  options2 = options2 || {}, options2.memoize = options2.memoize === false ? false : options2.memoize || new MemoizeMap();
  var comparator = options2 && options2.comparator, memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options2.memoize);
  if (memoizeResultLeft !== null) return memoizeResultLeft;
  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options2.memoize);
  if (memoizeResultRight !== null) return memoizeResultRight;
  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand);
    if (comparatorResult === false || comparatorResult === true) return memoizeSet(leftHandOperand, rightHandOperand, options2.memoize, comparatorResult), comparatorResult;
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (simpleResult !== null) return simpleResult;
  }
  var leftHandType = type2(leftHandOperand);
  if (leftHandType !== type2(rightHandOperand)) return memoizeSet(leftHandOperand, rightHandOperand, options2.memoize, false), false;
  memoizeSet(leftHandOperand, rightHandOperand, options2.memoize, true);
  var result2 = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options2);
  return memoizeSet(leftHandOperand, rightHandOperand, options2.memoize, result2), result2;
}
__name(extensiveDeepEqual, "extensiveDeepEqual");
function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options2) {
  switch (leftHandType) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return leftHandOperand === rightHandOperand;
    case "Error":
      return keysEqual(leftHandOperand, rightHandOperand, ["name", "message", "code"], options2);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return iterableEqual(leftHandOperand, rightHandOperand, options2);
    case "RegExp":
      return regexpEqual(leftHandOperand, rightHandOperand);
    case "Generator":
      return generatorEqual(leftHandOperand, rightHandOperand, options2);
    case "DataView":
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options2);
    case "ArrayBuffer":
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options2);
    case "Set":
      return entriesEqual(leftHandOperand, rightHandOperand, options2);
    case "Map":
      return entriesEqual(leftHandOperand, rightHandOperand, options2);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return leftHandOperand.equals(rightHandOperand);
    case "Temporal.Duration":
      return leftHandOperand.total("nanoseconds") === rightHandOperand.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return leftHandOperand.toString() === rightHandOperand.toString();
    default:
      return objectEqual(leftHandOperand, rightHandOperand, options2);
  }
}
__name(extensiveDeepEqualByType, "extensiveDeepEqualByType");
function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
__name(regexpEqual, "regexpEqual");
function entriesEqual(leftHandOperand, rightHandOperand, options2) {
  if (leftHandOperand.size !== rightHandOperand.size) return false;
  if (leftHandOperand.size === 0) return true;
  var leftHandItems = [], rightHandItems = [];
  return leftHandOperand.forEach(__name(function(key2, value2) {
    leftHandItems.push([key2, value2]);
  }, "gatherEntries")), rightHandOperand.forEach(__name(function(key2, value2) {
    rightHandItems.push([key2, value2]);
  }, "gatherEntries")), iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options2);
}
__name(entriesEqual, "entriesEqual");
function iterableEqual(leftHandOperand, rightHandOperand, options2) {
  var length = leftHandOperand.length;
  if (length !== rightHandOperand.length) return false;
  if (length === 0) return true;
  for (var index = -1; ++index < length; ) if (deepEqual(leftHandOperand[index], rightHandOperand[index], options2) === false) return false;
  return true;
}
__name(iterableEqual, "iterableEqual");
function generatorEqual(leftHandOperand, rightHandOperand, options2) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options2);
}
__name(generatorEqual, "generatorEqual");
function hasIteratorFunction(target) {
  return typeof Symbol < "u" && typeof target == "object" && typeof Symbol.iterator < "u" && typeof target[Symbol.iterator] == "function";
}
__name(hasIteratorFunction, "hasIteratorFunction");
function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) try {
    return getGeneratorEntries(target[Symbol.iterator]());
  } catch {
    return [];
  }
  return [];
}
__name(getIteratorEntries, "getIteratorEntries");
function getGeneratorEntries(generator) {
  for (var generatorResult = generator.next(), accumulator = [generatorResult.value]; generatorResult.done === false; ) generatorResult = generator.next(), accumulator.push(generatorResult.value);
  return accumulator;
}
__name(getGeneratorEntries, "getGeneratorEntries");
function getEnumerableKeys(target) {
  var keys2 = [];
  for (var key2 in target) keys2.push(key2);
  return keys2;
}
__name(getEnumerableKeys, "getEnumerableKeys");
function getEnumerableSymbols(target) {
  for (var keys2 = [], allKeys = Object.getOwnPropertySymbols(target), i4 = 0; i4 < allKeys.length; i4 += 1) {
    var key2 = allKeys[i4];
    Object.getOwnPropertyDescriptor(target, key2).enumerable && keys2.push(key2);
  }
  return keys2;
}
__name(getEnumerableSymbols, "getEnumerableSymbols");
function keysEqual(leftHandOperand, rightHandOperand, keys2, options2) {
  var length = keys2.length;
  if (length === 0) return true;
  for (var i4 = 0; i4 < length; i4 += 1) if (deepEqual(leftHandOperand[keys2[i4]], rightHandOperand[keys2[i4]], options2) === false) return false;
  return true;
}
__name(keysEqual, "keysEqual");
function objectEqual(leftHandOperand, rightHandOperand, options2) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand), rightHandKeys = getEnumerableKeys(rightHandOperand), leftHandSymbols = getEnumerableSymbols(leftHandOperand), rightHandSymbols = getEnumerableSymbols(rightHandOperand);
  if (leftHandKeys = leftHandKeys.concat(leftHandSymbols), rightHandKeys = rightHandKeys.concat(rightHandSymbols), leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) return iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === false ? false : keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options2);
  var leftHandEntries = getIteratorEntries(leftHandOperand), rightHandEntries = getIteratorEntries(rightHandOperand);
  return leftHandEntries.length && leftHandEntries.length === rightHandEntries.length ? (leftHandEntries.sort(), rightHandEntries.sort(), iterableEqual(leftHandEntries, rightHandEntries, options2)) : leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0;
}
__name(objectEqual, "objectEqual");
function isPrimitive(value2) {
  return value2 === null || typeof value2 != "object";
}
__name(isPrimitive, "isPrimitive");
function mapSymbols(arr) {
  return arr.map(__name(function(entry) {
    return typeof entry == "symbol" ? entry.toString() : entry;
  }, "mapSymbol"));
}
__name(mapSymbols, "mapSymbols");
function hasProperty(obj, name2) {
  return typeof obj > "u" || obj === null ? false : name2 in Object(obj);
}
__name(hasProperty, "hasProperty");
function parsePath(path) {
  return path.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((value2) => {
    if (value2 === "constructor" || value2 === "__proto__" || value2 === "prototype") return {};
    let mArr = /^\[(\d+)\]$/.exec(value2), parsed = null;
    return mArr ? parsed = { i: parseFloat(mArr[1]) } : parsed = { p: value2.replace(/\\([.[\]])/g, "$1") }, parsed;
  });
}
__name(parsePath, "parsePath");
function internalGetPathValue(obj, parsed, pathDepth) {
  let temporaryValue = obj, res = null;
  pathDepth = typeof pathDepth > "u" ? parsed.length : pathDepth;
  for (let i4 = 0; i4 < pathDepth; i4++) {
    let part = parsed[i4];
    temporaryValue && (typeof part.p > "u" ? temporaryValue = temporaryValue[part.i] : temporaryValue = temporaryValue[part.p], i4 === pathDepth - 1 && (res = temporaryValue));
  }
  return res;
}
__name(internalGetPathValue, "internalGetPathValue");
function getPathInfo(obj, path) {
  let parsed = parsePath(path), last = parsed[parsed.length - 1], info = { parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj, name: last.p || last.i, value: internalGetPathValue(obj, parsed) };
  return info.exists = hasProperty(info.parent, info.name), info;
}
__name(getPathInfo, "getPathInfo");
function Assertion(obj, msg, ssfi, lockSsfi) {
  return flag(this, "ssfi", ssfi || Assertion), flag(this, "lockSsfi", lockSsfi), flag(this, "object", obj), flag(this, "message", msg), flag(this, "eql", config.deepEqual || deep_eql_default), proxify(this);
}
__name(Assertion, "Assertion");
Object.defineProperty(Assertion, "includeStack", { get: function() {
  return console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), config.includeStack;
}, set: function(value2) {
  console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), config.includeStack = value2;
} });
Object.defineProperty(Assertion, "showDiff", { get: function() {
  return console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), config.showDiff;
}, set: function(value2) {
  console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), config.showDiff = value2;
} });
Assertion.addProperty = function(name2, fn3) {
  addProperty(this.prototype, name2, fn3);
};
Assertion.addMethod = function(name2, fn3) {
  addMethod(this.prototype, name2, fn3);
};
Assertion.addChainableMethod = function(name2, fn3, chainingBehavior) {
  addChainableMethod(this.prototype, name2, fn3, chainingBehavior);
};
Assertion.overwriteProperty = function(name2, fn3) {
  overwriteProperty(this.prototype, name2, fn3);
};
Assertion.overwriteMethod = function(name2, fn3) {
  overwriteMethod(this.prototype, name2, fn3);
};
Assertion.overwriteChainableMethod = function(name2, fn3, chainingBehavior) {
  overwriteChainableMethod(this.prototype, name2, fn3, chainingBehavior);
};
Assertion.prototype.assert = function(expr, msg, negateMsg, expected, _actual, showDiff) {
  var ok = test2(this, arguments);
  if (showDiff !== false && (showDiff = true), expected === void 0 && _actual === void 0 && (showDiff = false), config.showDiff !== true && (showDiff = false), !ok) {
    msg = getMessage2(this, arguments);
    var actual = getActual(this, arguments), assertionErrorObjectProperties = { actual, expected, showDiff }, operator = getOperator(this, arguments);
    throw operator && (assertionErrorObjectProperties.operator = operator), new AssertionError(msg, assertionErrorObjectProperties, config.includeStack ? this.assert : flag(this, "ssfi"));
  }
};
Object.defineProperty(Assertion.prototype, "_obj", { get: function() {
  return flag(this, "object");
}, set: function(val) {
  flag(this, "object", val);
} });
function isProxyEnabled() {
  return config.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
__name(isProxyEnabled, "isProxyEnabled");
function addProperty(ctx, name2, getter) {
  getter = getter === void 0 ? function() {
  } : getter, Object.defineProperty(ctx, name2, { get: __name(function propertyGetter() {
    !isProxyEnabled() && !flag(this, "lockSsfi") && flag(this, "ssfi", propertyGetter);
    var result2 = getter.call(this);
    if (result2 !== void 0) return result2;
    var newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "propertyGetter"), configurable: true });
}
__name(addProperty, "addProperty");
var fnLengthDesc = Object.getOwnPropertyDescriptor(function() {
}, "length");
function addLengthGuard(fn3, assertionName, isChainable) {
  return fnLengthDesc.configurable && Object.defineProperty(fn3, "length", { get: function() {
    throw Error(isChainable ? "Invalid Chai property: " + assertionName + '.length. Due to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.' : "Invalid Chai property: " + assertionName + '.length. See docs for proper usage of "' + assertionName + '".');
  } }), fn3;
}
__name(addLengthGuard, "addLengthGuard");
function getProperties(object) {
  var result2 = Object.getOwnPropertyNames(object);
  function addProperty2(property) {
    result2.indexOf(property) === -1 && result2.push(property);
  }
  __name(addProperty2, "addProperty");
  for (var proto = Object.getPrototypeOf(object); proto !== null; ) Object.getOwnPropertyNames(proto).forEach(addProperty2), proto = Object.getPrototypeOf(proto);
  return result2;
}
__name(getProperties, "getProperties");
var builtins = ["__flags", "__methods", "_obj", "assert"];
function proxify(obj, nonChainableMethodName) {
  return isProxyEnabled() ? new Proxy(obj, { get: __name(function proxyGetter(target, property) {
    if (typeof property == "string" && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
      if (nonChainableMethodName) throw Error("Invalid Chai property: " + nonChainableMethodName + "." + property + '. See docs for proper usage of "' + nonChainableMethodName + '".');
      var suggestion = null, suggestionDistance = 4;
      throw getProperties(target).forEach(function(prop) {
        if (!Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1) {
          var dist = stringDistanceCapped(property, prop, suggestionDistance);
          dist < suggestionDistance && (suggestion = prop, suggestionDistance = dist);
        }
      }), Error(suggestion !== null ? "Invalid Chai property: " + property + '. Did you mean "' + suggestion + '"?' : "Invalid Chai property: " + property);
    }
    return builtins.indexOf(property) === -1 && !flag(target, "lockSsfi") && flag(target, "ssfi", proxyGetter), Reflect.get(target, property);
  }, "proxyGetter") }) : obj;
}
__name(proxify, "proxify");
function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap) return cap;
  for (var memo = [], i4 = 0; i4 <= strA.length; i4++) memo[i4] = Array(strB.length + 1).fill(0), memo[i4][0] = i4;
  for (var j2 = 0; j2 < strB.length; j2++) memo[0][j2] = j2;
  for (var i4 = 1; i4 <= strA.length; i4++) for (var ch = strA.charCodeAt(i4 - 1), j2 = 1; j2 <= strB.length; j2++) {
    if (Math.abs(i4 - j2) >= cap) {
      memo[i4][j2] = cap;
      continue;
    }
    memo[i4][j2] = Math.min(memo[i4 - 1][j2] + 1, memo[i4][j2 - 1] + 1, memo[i4 - 1][j2 - 1] + (ch === strB.charCodeAt(j2 - 1) ? 0 : 1));
  }
  return memo[strA.length][strB.length];
}
__name(stringDistanceCapped, "stringDistanceCapped");
function addMethod(ctx, name2, method) {
  var methodWrapper = __name(function() {
    flag(this, "lockSsfi") || flag(this, "ssfi", methodWrapper);
    var result2 = method.apply(this, arguments);
    if (result2 !== void 0) return result2;
    var newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "methodWrapper");
  addLengthGuard(methodWrapper, name2, false), ctx[name2] = proxify(methodWrapper, name2);
}
__name(addMethod, "addMethod");
function overwriteProperty(ctx, name2, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name2), _super = __name(function() {
  }, "_super");
  _get && typeof _get.get == "function" && (_super = _get.get), Object.defineProperty(ctx, name2, { get: __name(function overwritingPropertyGetter() {
    !isProxyEnabled() && !flag(this, "lockSsfi") && flag(this, "ssfi", overwritingPropertyGetter);
    var origLockSsfi = flag(this, "lockSsfi");
    flag(this, "lockSsfi", true);
    var result2 = getter(_super).call(this);
    if (flag(this, "lockSsfi", origLockSsfi), result2 !== void 0) return result2;
    var newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingPropertyGetter"), configurable: true });
}
__name(overwriteProperty, "overwriteProperty");
function overwriteMethod(ctx, name2, method) {
  var _method = ctx[name2], _super = __name(function() {
    throw new Error(name2 + " is not a function");
  }, "_super");
  _method && typeof _method == "function" && (_super = _method);
  var overwritingMethodWrapper = __name(function() {
    flag(this, "lockSsfi") || flag(this, "ssfi", overwritingMethodWrapper);
    var origLockSsfi = flag(this, "lockSsfi");
    flag(this, "lockSsfi", true);
    var result2 = method(_super).apply(this, arguments);
    if (flag(this, "lockSsfi", origLockSsfi), result2 !== void 0) return result2;
    var newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingMethodWrapper");
  addLengthGuard(overwritingMethodWrapper, name2, false), ctx[name2] = proxify(overwritingMethodWrapper, name2);
}
__name(overwriteMethod, "overwriteMethod");
var canSetPrototype = typeof Object.setPrototypeOf == "function";
var testFn = __name(function() {
}, "testFn");
var excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name2) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name2);
  return typeof propDesc != "object" ? true : !propDesc.configurable;
});
var call = Function.prototype.call;
var apply = Function.prototype.apply;
function addChainableMethod(ctx, name2, method, chainingBehavior) {
  typeof chainingBehavior != "function" && (chainingBehavior = __name(function() {
  }, "chainingBehavior"));
  var chainableBehavior = { method, chainingBehavior };
  ctx.__methods || (ctx.__methods = {}), ctx.__methods[name2] = chainableBehavior, Object.defineProperty(ctx, name2, { get: __name(function() {
    chainableBehavior.chainingBehavior.call(this);
    var chainableMethodWrapper = __name(function() {
      flag(this, "lockSsfi") || flag(this, "ssfi", chainableMethodWrapper);
      var result2 = chainableBehavior.method.apply(this, arguments);
      if (result2 !== void 0) return result2;
      var newAssertion = new Assertion();
      return transferFlags(this, newAssertion), newAssertion;
    }, "chainableMethodWrapper");
    if (addLengthGuard(chainableMethodWrapper, name2, true), canSetPrototype) {
      var prototype = Object.create(this);
      prototype.call = call, prototype.apply = apply, Object.setPrototypeOf(chainableMethodWrapper, prototype);
    } else {
      var asserterNames = Object.getOwnPropertyNames(ctx);
      asserterNames.forEach(function(asserterName) {
        if (excludeNames.indexOf(asserterName) === -1) {
          var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
          Object.defineProperty(chainableMethodWrapper, asserterName, pd);
        }
      });
    }
    return transferFlags(this, chainableMethodWrapper), proxify(chainableMethodWrapper);
  }, "chainableMethodGetter"), configurable: true });
}
__name(addChainableMethod, "addChainableMethod");
function overwriteChainableMethod(ctx, name2, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name2], _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = __name(function() {
    var result2 = chainingBehavior(_chainingBehavior).call(this);
    if (result2 !== void 0) return result2;
    var newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingChainableMethodGetter");
  var _method = chainableBehavior.method;
  chainableBehavior.method = __name(function() {
    var result2 = method(_method).apply(this, arguments);
    if (result2 !== void 0) return result2;
    var newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingChainableMethodWrapper");
}
__name(overwriteChainableMethod, "overwriteChainableMethod");
function compareByInspect(a22, b6) {
  return inspect22(a22) < inspect22(b6) ? -1 : 1;
}
__name(compareByInspect, "compareByInspect");
function getOwnEnumerablePropertySymbols(obj) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(obj).filter(function(sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
}
__name(getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols");
function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
}
__name(getOwnEnumerableProperties, "getOwnEnumerableProperties");
function _isNaN(value2) {
  return value2 !== value2;
}
__name(_isNaN, "_isNaN");
var isNaN222 = Number.isNaN || _isNaN;
function isObjectType(obj) {
  var objectType = type(obj), objectTypes = ["Array", "Object", "Function"];
  return objectTypes.indexOf(objectType) !== -1;
}
__name(isObjectType, "isObjectType");
function getOperator(obj, args2) {
  var operator = flag(obj, "operator"), negate = flag(obj, "negate"), expected = args2[3], msg = negate ? args2[2] : args2[1];
  if (operator) return operator;
  if (typeof msg == "function" && (msg = msg()), msg = msg || "", !!msg && !/\shave\s/.test(msg)) {
    var isObject22 = isObjectType(expected);
    return /\snot\s/.test(msg) ? isObject22 ? "notDeepStrictEqual" : "notStrictEqual" : isObject22 ? "deepStrictEqual" : "strictEqual";
  }
}
__name(getOperator, "getOperator");
function getName(fn3) {
  return fn3.name;
}
__name(getName, "getName");
function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp2, "isRegExp");
var { flag: flag2 } = utils_exports;
["to", "be", "been", "is", "and", "has", "have", "with", "that", "which", "at", "of", "same", "but", "does", "still", "also"].forEach(function(chain) {
  Assertion.addProperty(chain);
});
Assertion.addProperty("not", function() {
  flag2(this, "negate", true);
});
Assertion.addProperty("deep", function() {
  flag2(this, "deep", true);
});
Assertion.addProperty("nested", function() {
  flag2(this, "nested", true);
});
Assertion.addProperty("own", function() {
  flag2(this, "own", true);
});
Assertion.addProperty("ordered", function() {
  flag2(this, "ordered", true);
});
Assertion.addProperty("any", function() {
  flag2(this, "any", true), flag2(this, "all", false);
});
Assertion.addProperty("all", function() {
  flag2(this, "all", true), flag2(this, "any", false);
});
var functionTypes = { function: ["function", "asyncfunction", "generatorfunction", "asyncgeneratorfunction"], asyncfunction: ["asyncfunction", "asyncgeneratorfunction"], generatorfunction: ["generatorfunction", "asyncgeneratorfunction"], asyncgeneratorfunction: ["asyncgeneratorfunction"] };
function an2(type32, msg) {
  msg && flag2(this, "message", msg), type32 = type32.toLowerCase();
  var obj = flag2(this, "object"), article = ~["a", "e", "i", "o", "u"].indexOf(type32.charAt(0)) ? "an " : "a ";
  let detectedType = type(obj).toLowerCase();
  functionTypes.function.includes(type32) ? this.assert(functionTypes[type32].includes(detectedType), "expected #{this} to be " + article + type32, "expected #{this} not to be " + article + type32) : this.assert(type32 === detectedType, "expected #{this} to be " + article + type32, "expected #{this} not to be " + article + type32);
}
__name(an2, "an");
Assertion.addChainableMethod("an", an2);
Assertion.addChainableMethod("a", an2);
function SameValueZero(a22, b6) {
  return isNaN222(a22) && isNaN222(b6) || a22 === b6;
}
__name(SameValueZero, "SameValueZero");
function includeChainingBehavior() {
  flag2(this, "contains", true);
}
__name(includeChainingBehavior, "includeChainingBehavior");
function include(val, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), negate = flag2(this, "negate"), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), descriptor = isDeep ? "deep " : "", isEql = isDeep ? flag2(this, "eql") : SameValueZero;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  var included = false;
  switch (objType) {
    case "string":
      included = obj.indexOf(val) !== -1;
      break;
    case "weakset":
      if (isDeep) throw new AssertionError(flagMsg + "unable to use .deep.include with WeakSet", void 0, ssfi);
      included = obj.has(val);
      break;
    case "map":
      obj.forEach(function(item) {
        included = included || isEql(item, val);
      });
      break;
    case "set":
      isDeep ? obj.forEach(function(item) {
        included = included || isEql(item, val);
      }) : included = obj.has(val);
      break;
    case "array":
      isDeep ? included = obj.some(function(item) {
        return isEql(item, val);
      }) : included = obj.indexOf(val) !== -1;
      break;
    default:
      if (val !== Object(val)) throw new AssertionError(flagMsg + "the given combination of arguments (" + objType + " and " + type(val).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + type(val).toLowerCase(), void 0, ssfi);
      var props = Object.keys(val), firstErr = null, numErrs = 0;
      if (props.forEach(function(prop) {
        var propAssertion = new Assertion(obj);
        if (transferFlags(this, propAssertion, true), flag2(propAssertion, "lockSsfi", true), !negate || props.length === 1) {
          propAssertion.property(prop, val[prop]);
          return;
        }
        try {
          propAssertion.property(prop, val[prop]);
        } catch (err) {
          if (!check_error_exports.compatibleConstructor(err, AssertionError)) throw err;
          firstErr === null && (firstErr = err), numErrs++;
        }
      }, this), negate && props.length > 1 && numErrs === props.length) throw firstErr;
      return;
  }
  this.assert(included, "expected #{this} to " + descriptor + "include " + inspect22(val), "expected #{this} to not " + descriptor + "include " + inspect22(val));
}
__name(include, "include");
Assertion.addChainableMethod("include", include, includeChainingBehavior);
Assertion.addChainableMethod("contain", include, includeChainingBehavior);
Assertion.addChainableMethod("contains", include, includeChainingBehavior);
Assertion.addChainableMethod("includes", include, includeChainingBehavior);
Assertion.addProperty("ok", function() {
  this.assert(flag2(this, "object"), "expected #{this} to be truthy", "expected #{this} to be falsy");
});
Assertion.addProperty("true", function() {
  this.assert(flag2(this, "object") === true, "expected #{this} to be true", "expected #{this} to be false", !flag2(this, "negate"));
});
Assertion.addProperty("callable", function() {
  let val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), message = flag2(this, "message"), msg = message ? `${message}: ` : "", negate = flag2(this, "negate"), assertionMessage = negate ? `${msg}expected ${inspect22(val)} not to be a callable function` : `${msg}expected ${inspect22(val)} to be a callable function`, isCallable3 = ["Function", "AsyncFunction", "GeneratorFunction", "AsyncGeneratorFunction"].includes(type(val));
  if (isCallable3 && negate || !isCallable3 && !negate) throw new AssertionError(assertionMessage, void 0, ssfi);
});
Assertion.addProperty("false", function() {
  this.assert(flag2(this, "object") === false, "expected #{this} to be false", "expected #{this} to be true", !!flag2(this, "negate"));
});
Assertion.addProperty("null", function() {
  this.assert(flag2(this, "object") === null, "expected #{this} to be null", "expected #{this} not to be null");
});
Assertion.addProperty("undefined", function() {
  this.assert(flag2(this, "object") === void 0, "expected #{this} to be undefined", "expected #{this} not to be undefined");
});
Assertion.addProperty("NaN", function() {
  this.assert(isNaN222(flag2(this, "object")), "expected #{this} to be NaN", "expected #{this} not to be NaN");
});
function assertExist() {
  var val = flag2(this, "object");
  this.assert(val != null, "expected #{this} to exist", "expected #{this} to not exist");
}
__name(assertExist, "assertExist");
Assertion.addProperty("exist", assertExist);
Assertion.addProperty("exists", assertExist);
Assertion.addProperty("empty", function() {
  var val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), itemsCount;
  switch (flagMsg = flagMsg ? flagMsg + ": " : "", type(val).toLowerCase()) {
    case "array":
    case "string":
      itemsCount = val.length;
      break;
    case "map":
    case "set":
      itemsCount = val.size;
      break;
    case "weakmap":
    case "weakset":
      throw new AssertionError(flagMsg + ".empty was passed a weak collection", void 0, ssfi);
    case "function":
      var msg = flagMsg + ".empty was passed a function " + getName(val);
      throw new AssertionError(msg.trim(), void 0, ssfi);
    default:
      if (val !== Object(val)) throw new AssertionError(flagMsg + ".empty was passed non-string primitive " + inspect22(val), void 0, ssfi);
      itemsCount = Object.keys(val).length;
  }
  this.assert(itemsCount === 0, "expected #{this} to be empty", "expected #{this} not to be empty");
});
function checkArguments() {
  var obj = flag2(this, "object"), type32 = type(obj);
  this.assert(type32 === "Arguments", "expected #{this} to be arguments but got " + type32, "expected #{this} to not be arguments");
}
__name(checkArguments, "checkArguments");
Assertion.addProperty("arguments", checkArguments);
Assertion.addProperty("Arguments", checkArguments);
function assertEqual(val, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object");
  if (flag2(this, "deep")) {
    var prevLockSsfi = flag2(this, "lockSsfi");
    flag2(this, "lockSsfi", true), this.eql(val), flag2(this, "lockSsfi", prevLockSsfi);
  } else this.assert(val === obj, "expected #{this} to equal #{exp}", "expected #{this} to not equal #{exp}", val, this._obj, true);
}
__name(assertEqual, "assertEqual");
Assertion.addMethod("equal", assertEqual);
Assertion.addMethod("equals", assertEqual);
Assertion.addMethod("eq", assertEqual);
function assertEql(obj, msg) {
  msg && flag2(this, "message", msg);
  var eql = flag2(this, "eql");
  this.assert(eql(obj, flag2(this, "object")), "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", obj, this._obj, true);
}
__name(assertEql, "assertEql");
Assertion.addMethod("eql", assertEql);
Assertion.addMethod("eqls", assertEql);
function assertAbove(n3, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n3).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, true).to.have.property("length"), !doLength && objType === "date" && nType !== "date") errorMessage = msgPrefix + "the argument to above must be a date";
  else if (nType !== "number" && (doLength || objType === "number")) errorMessage = msgPrefix + "the argument to above must be a number";
  else if (!doLength && objType !== "date" && objType !== "number") {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else shouldThrow = false;
  if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    var descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(itemsCount > n3, "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " above #{exp}", n3, itemsCount);
  } else this.assert(obj > n3, "expected #{this} to be above #{exp}", "expected #{this} to be at most #{exp}", n3);
}
__name(assertAbove, "assertAbove");
Assertion.addMethod("above", assertAbove);
Assertion.addMethod("gt", assertAbove);
Assertion.addMethod("greaterThan", assertAbove);
function assertLeast(n3, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n3).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, true).to.have.property("length"), !doLength && objType === "date" && nType !== "date") errorMessage = msgPrefix + "the argument to least must be a date";
  else if (nType !== "number" && (doLength || objType === "number")) errorMessage = msgPrefix + "the argument to least must be a number";
  else if (!doLength && objType !== "date" && objType !== "number") {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else shouldThrow = false;
  if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    var descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(itemsCount >= n3, "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}", "expected #{this} to have a " + descriptor + " below #{exp}", n3, itemsCount);
  } else this.assert(obj >= n3, "expected #{this} to be at least #{exp}", "expected #{this} to be below #{exp}", n3);
}
__name(assertLeast, "assertLeast");
Assertion.addMethod("least", assertLeast);
Assertion.addMethod("gte", assertLeast);
Assertion.addMethod("greaterThanOrEqual", assertLeast);
function assertBelow(n3, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n3).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, true).to.have.property("length"), !doLength && objType === "date" && nType !== "date") errorMessage = msgPrefix + "the argument to below must be a date";
  else if (nType !== "number" && (doLength || objType === "number")) errorMessage = msgPrefix + "the argument to below must be a number";
  else if (!doLength && objType !== "date" && objType !== "number") {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else shouldThrow = false;
  if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    var descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(itemsCount < n3, "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " below #{exp}", n3, itemsCount);
  } else this.assert(obj < n3, "expected #{this} to be below #{exp}", "expected #{this} to be at least #{exp}", n3);
}
__name(assertBelow, "assertBelow");
Assertion.addMethod("below", assertBelow);
Assertion.addMethod("lt", assertBelow);
Assertion.addMethod("lessThan", assertBelow);
function assertMost(n3, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n3).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, true).to.have.property("length"), !doLength && objType === "date" && nType !== "date") errorMessage = msgPrefix + "the argument to most must be a date";
  else if (nType !== "number" && (doLength || objType === "number")) errorMessage = msgPrefix + "the argument to most must be a number";
  else if (!doLength && objType !== "date" && objType !== "number") {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else shouldThrow = false;
  if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    var descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(itemsCount <= n3, "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}", "expected #{this} to have a " + descriptor + " above #{exp}", n3, itemsCount);
  } else this.assert(obj <= n3, "expected #{this} to be at most #{exp}", "expected #{this} to be above #{exp}", n3);
}
__name(assertMost, "assertMost");
Assertion.addMethod("most", assertMost);
Assertion.addMethod("lte", assertMost);
Assertion.addMethod("lessThanOrEqual", assertMost);
Assertion.addMethod("within", function(start, finish, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), startType = type(start).toLowerCase(), finishType = type(finish).toLowerCase(), errorMessage, shouldThrow = true, range = startType === "date" && finishType === "date" ? start.toISOString() + ".." + finish.toISOString() : start + ".." + finish;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, true).to.have.property("length"), !doLength && objType === "date" && (startType !== "date" || finishType !== "date")) errorMessage = msgPrefix + "the arguments to within must be dates";
  else if ((startType !== "number" || finishType !== "number") && (doLength || objType === "number")) errorMessage = msgPrefix + "the arguments to within must be numbers";
  else if (!doLength && objType !== "date" && objType !== "number") {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else shouldThrow = false;
  if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    var descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(itemsCount >= start && itemsCount <= finish, "expected #{this} to have a " + descriptor + " within " + range, "expected #{this} to not have a " + descriptor + " within " + range);
  } else this.assert(obj >= start && obj <= finish, "expected #{this} to be within " + range, "expected #{this} to not be within " + range);
});
function assertInstanceOf(constructor, msg) {
  msg && flag2(this, "message", msg);
  var target = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message");
  try {
    var isInstanceOf = target instanceof constructor;
  } catch (err) {
    throw err instanceof TypeError ? (flagMsg = flagMsg ? flagMsg + ": " : "", new AssertionError(flagMsg + "The instanceof assertion needs a constructor but " + type(constructor) + " was given.", void 0, ssfi)) : err;
  }
  var name2 = getName(constructor);
  name2 == null && (name2 = "an unnamed constructor"), this.assert(isInstanceOf, "expected #{this} to be an instance of " + name2, "expected #{this} to not be an instance of " + name2);
}
__name(assertInstanceOf, "assertInstanceOf");
Assertion.addMethod("instanceof", assertInstanceOf);
Assertion.addMethod("instanceOf", assertInstanceOf);
function assertProperty(name2, val, msg) {
  msg && flag2(this, "message", msg);
  var isNested = flag2(this, "nested"), isOwn = flag2(this, "own"), flagMsg = flag2(this, "message"), obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), nameType = typeof name2;
  if (flagMsg = flagMsg ? flagMsg + ": " : "", isNested) {
    if (nameType !== "string") throw new AssertionError(flagMsg + "the argument to property must be a string when using nested syntax", void 0, ssfi);
  } else if (nameType !== "string" && nameType !== "number" && nameType !== "symbol") throw new AssertionError(flagMsg + "the argument to property must be a string, number, or symbol", void 0, ssfi);
  if (isNested && isOwn) throw new AssertionError(flagMsg + 'The "nested" and "own" flags cannot be combined.', void 0, ssfi);
  if (obj == null) throw new AssertionError(flagMsg + "Target cannot be null or undefined.", void 0, ssfi);
  var isDeep = flag2(this, "deep"), negate = flag2(this, "negate"), pathInfo = isNested ? getPathInfo(obj, name2) : null, value2 = isNested ? pathInfo.value : obj[name2], isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2, descriptor = "";
  isDeep && (descriptor += "deep "), isOwn && (descriptor += "own "), isNested && (descriptor += "nested "), descriptor += "property ";
  var hasProperty2;
  isOwn ? hasProperty2 = Object.prototype.hasOwnProperty.call(obj, name2) : isNested ? hasProperty2 = pathInfo.exists : hasProperty2 = hasProperty(obj, name2), (!negate || arguments.length === 1) && this.assert(hasProperty2, "expected #{this} to have " + descriptor + inspect22(name2), "expected #{this} to not have " + descriptor + inspect22(name2)), arguments.length > 1 && this.assert(hasProperty2 && isEql(val, value2), "expected #{this} to have " + descriptor + inspect22(name2) + " of #{exp}, but got #{act}", "expected #{this} to not have " + descriptor + inspect22(name2) + " of #{act}", val, value2), flag2(this, "object", value2);
}
__name(assertProperty, "assertProperty");
Assertion.addMethod("property", assertProperty);
function assertOwnProperty(name2, value2, msg) {
  flag2(this, "own", true), assertProperty.apply(this, arguments);
}
__name(assertOwnProperty, "assertOwnProperty");
Assertion.addMethod("ownProperty", assertOwnProperty);
Assertion.addMethod("haveOwnProperty", assertOwnProperty);
function assertOwnPropertyDescriptor(name2, descriptor, msg) {
  typeof descriptor == "string" && (msg = descriptor, descriptor = null), msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name2), eql = flag2(this, "eql");
  actualDescriptor && descriptor ? this.assert(eql(descriptor, actualDescriptor), "expected the own property descriptor for " + inspect22(name2) + " on #{this} to match " + inspect22(descriptor) + ", got " + inspect22(actualDescriptor), "expected the own property descriptor for " + inspect22(name2) + " on #{this} to not match " + inspect22(descriptor), descriptor, actualDescriptor, true) : this.assert(actualDescriptor, "expected #{this} to have an own property descriptor for " + inspect22(name2), "expected #{this} to not have an own property descriptor for " + inspect22(name2)), flag2(this, "object", actualDescriptor);
}
__name(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
function assertLengthChain() {
  flag2(this, "doLength", true);
}
__name(assertLengthChain, "assertLengthChain");
function assertLength(n3, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), descriptor = "length", itemsCount;
  switch (objType) {
    case "map":
    case "set":
      descriptor = "size", itemsCount = obj.size;
      break;
    default:
      new Assertion(obj, flagMsg, ssfi, true).to.have.property("length"), itemsCount = obj.length;
  }
  this.assert(itemsCount == n3, "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " of #{act}", n3, itemsCount);
}
__name(assertLength, "assertLength");
Assertion.addChainableMethod("length", assertLength, assertLengthChain);
Assertion.addChainableMethod("lengthOf", assertLength, assertLengthChain);
function assertMatch(re3, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object");
  this.assert(re3.exec(obj), "expected #{this} to match " + re3, "expected #{this} not to match " + re3);
}
__name(assertMatch, "assertMatch");
Assertion.addMethod("match", assertMatch);
Assertion.addMethod("matches", assertMatch);
Assertion.addMethod("string", function(str, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).is.a("string"), this.assert(~obj.indexOf(str), "expected #{this} to contain " + inspect22(str), "expected #{this} to not contain " + inspect22(str));
});
function assertKeys(keys2) {
  var obj = flag2(this, "object"), objType = type(obj), keysType = type(keys2), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), str, deepStr = "", actual, ok = true, flagMsg = flag2(this, "message");
  flagMsg = flagMsg ? flagMsg + ": " : "";
  var mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (objType === "Map" || objType === "Set") deepStr = isDeep ? "deeply " : "", actual = [], obj.forEach(function(val, key2) {
    actual.push(key2);
  }), keysType !== "Array" && (keys2 = Array.prototype.slice.call(arguments));
  else {
    switch (actual = getOwnEnumerableProperties(obj), keysType) {
      case "Array":
        if (arguments.length > 1) throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        break;
      case "Object":
        if (arguments.length > 1) throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        keys2 = Object.keys(keys2);
        break;
      default:
        keys2 = Array.prototype.slice.call(arguments);
    }
    keys2 = keys2.map(function(val) {
      return typeof val == "symbol" ? val : String(val);
    });
  }
  if (!keys2.length) throw new AssertionError(flagMsg + "keys required", void 0, ssfi);
  var len = keys2.length, any = flag2(this, "any"), all = flag2(this, "all"), expected = keys2, isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
  if (!any && !all && (all = true), any && (ok = expected.some(function(expectedKey) {
    return actual.some(function(actualKey) {
      return isEql(expectedKey, actualKey);
    });
  })), all && (ok = expected.every(function(expectedKey) {
    return actual.some(function(actualKey) {
      return isEql(expectedKey, actualKey);
    });
  }), flag2(this, "contains") || (ok = ok && keys2.length == actual.length)), len > 1) {
    keys2 = keys2.map(function(key2) {
      return inspect22(key2);
    });
    var last = keys2.pop();
    all && (str = keys2.join(", ") + ", and " + last), any && (str = keys2.join(", ") + ", or " + last);
  } else str = inspect22(keys2[0]);
  str = (len > 1 ? "keys " : "key ") + str, str = (flag2(this, "contains") ? "contain " : "have ") + str, this.assert(ok, "expected #{this} to " + deepStr + str, "expected #{this} to not " + deepStr + str, expected.slice(0).sort(compareByInspect), actual.sort(compareByInspect), true);
}
__name(assertKeys, "assertKeys");
Assertion.addMethod("keys", assertKeys);
Assertion.addMethod("key", assertKeys);
function assertThrows(errorLike, errMsgMatcher, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), negate = flag2(this, "negate") || false;
  new Assertion(obj, flagMsg, ssfi, true).is.a("function"), (isRegExp2(errorLike) || typeof errorLike == "string") && (errMsgMatcher = errorLike, errorLike = null);
  let caughtErr, errorWasThrown = false;
  try {
    obj();
  } catch (err) {
    errorWasThrown = true, caughtErr = err;
  }
  var everyArgIsUndefined = errorLike === void 0 && errMsgMatcher === void 0, everyArgIsDefined = !!(errorLike && errMsgMatcher), errorLikeFail = false, errMsgMatcherFail = false;
  if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
    var errorLikeString = "an error";
    errorLike instanceof Error ? errorLikeString = "#{exp}" : errorLike && (errorLikeString = check_error_exports.getConstructorName(errorLike));
    let actual = caughtErr;
    if (caughtErr instanceof Error) actual = caughtErr.toString();
    else if (typeof caughtErr == "string") actual = caughtErr;
    else if (caughtErr && (typeof caughtErr == "object" || typeof caughtErr == "function")) try {
      actual = check_error_exports.getConstructorName(caughtErr);
    } catch {
    }
    this.assert(errorWasThrown, "expected #{this} to throw " + errorLikeString, "expected #{this} to not throw an error but #{act} was thrown", errorLike && errorLike.toString(), actual);
  }
  if (errorLike && caughtErr) {
    if (errorLike instanceof Error) {
      var isCompatibleInstance = check_error_exports.compatibleInstance(caughtErr, errorLike);
      isCompatibleInstance === negate && (everyArgIsDefined && negate ? errorLikeFail = true : this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr && !negate ? " but #{act} was thrown" : ""), errorLike.toString(), caughtErr.toString()));
    }
    var isCompatibleConstructor = check_error_exports.compatibleConstructor(caughtErr, errorLike);
    isCompatibleConstructor === negate && (everyArgIsDefined && negate ? errorLikeFail = true : this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""), errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)));
  }
  if (caughtErr && errMsgMatcher !== void 0 && errMsgMatcher !== null) {
    var placeholder = "including";
    isRegExp2(errMsgMatcher) && (placeholder = "matching");
    var isCompatibleMessage = check_error_exports.compatibleMessage(caughtErr, errMsgMatcher);
    isCompatibleMessage === negate && (everyArgIsDefined && negate ? errMsgMatcherFail = true : this.assert(negate, "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}", "expected #{this} to throw error not " + placeholder + " #{exp}", errMsgMatcher, check_error_exports.getMessage(caughtErr)));
  }
  errorLikeFail && errMsgMatcherFail && this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""), errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)), flag2(this, "object", caughtErr);
}
__name(assertThrows, "assertThrows");
Assertion.addMethod("throw", assertThrows);
Assertion.addMethod("throws", assertThrows);
Assertion.addMethod("Throw", assertThrows);
function respondTo(method, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), itself = flag2(this, "itself"), context = typeof obj == "function" && !itself ? obj.prototype[method] : obj[method];
  this.assert(typeof context == "function", "expected #{this} to respond to " + inspect22(method), "expected #{this} to not respond to " + inspect22(method));
}
__name(respondTo, "respondTo");
Assertion.addMethod("respondTo", respondTo);
Assertion.addMethod("respondsTo", respondTo);
Assertion.addProperty("itself", function() {
  flag2(this, "itself", true);
});
function satisfy(matcher, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), result2 = matcher(obj);
  this.assert(result2, "expected #{this} to satisfy " + objDisplay(matcher), "expected #{this} to not satisfy" + objDisplay(matcher), !flag2(this, "negate"), result2);
}
__name(satisfy, "satisfy");
Assertion.addMethod("satisfy", satisfy);
Assertion.addMethod("satisfies", satisfy);
function closeTo(expected, delta, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  if (new Assertion(obj, flagMsg, ssfi, true).is.a("number"), typeof expected != "number" || typeof delta != "number") {
    flagMsg = flagMsg ? flagMsg + ": " : "";
    var deltaMessage = delta === void 0 ? ", and a delta is required" : "";
    throw new AssertionError(flagMsg + "the arguments to closeTo or approximately must be numbers" + deltaMessage, void 0, ssfi);
  }
  this.assert(Math.abs(obj - expected) <= delta, "expected #{this} to be close to " + expected + " +/- " + delta, "expected #{this} not to be close to " + expected + " +/- " + delta);
}
__name(closeTo, "closeTo");
Assertion.addMethod("closeTo", closeTo);
Assertion.addMethod("approximately", closeTo);
function isSubsetOf(_subset, _superset, cmp, contains, ordered) {
  let superset = Array.from(_superset), subset = Array.from(_subset);
  if (!contains) {
    if (subset.length !== superset.length) return false;
    superset = superset.slice();
  }
  return subset.every(function(elem, idx) {
    if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
    if (!cmp) {
      var matchIdx = superset.indexOf(elem);
      return matchIdx === -1 ? false : (contains || superset.splice(matchIdx, 1), true);
    }
    return superset.some(function(elem2, matchIdx2) {
      return cmp(elem, elem2) ? (contains || superset.splice(matchIdx2, 1), true) : false;
    });
  });
}
__name(isSubsetOf, "isSubsetOf");
Assertion.addMethod("members", function(subset, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).to.be.iterable, new Assertion(subset, flagMsg, ssfi, true).to.be.iterable;
  var contains = flag2(this, "contains"), ordered = flag2(this, "ordered"), subject, failMsg, failNegateMsg;
  contains ? (subject = ordered ? "an ordered superset" : "a superset", failMsg = "expected #{this} to be " + subject + " of #{exp}", failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}") : (subject = ordered ? "ordered members" : "members", failMsg = "expected #{this} to have the same " + subject + " as #{exp}", failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}");
  var cmp = flag2(this, "deep") ? flag2(this, "eql") : void 0;
  this.assert(isSubsetOf(subset, obj, cmp, contains, ordered), failMsg, failNegateMsg, subset, obj, true);
});
Assertion.addProperty("iterable", function(msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object");
  this.assert(obj != null && obj[Symbol.iterator], "expected #{this} to be an iterable", "expected #{this} to not be an iterable", obj);
});
function oneOf(list, msg) {
  msg && flag2(this, "message", msg);
  var expected = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), contains = flag2(this, "contains"), isDeep = flag2(this, "deep"), eql = flag2(this, "eql");
  new Assertion(list, flagMsg, ssfi, true).to.be.an("array"), contains ? this.assert(list.some(function(possibility) {
    return expected.indexOf(possibility) > -1;
  }), "expected #{this} to contain one of #{exp}", "expected #{this} to not contain one of #{exp}", list, expected) : isDeep ? this.assert(list.some(function(possibility) {
    return eql(expected, possibility);
  }), "expected #{this} to deeply equal one of #{exp}", "expected #{this} to deeply equal one of #{exp}", list, expected) : this.assert(list.indexOf(expected) > -1, "expected #{this} to be one of #{exp}", "expected #{this} to not be one of #{exp}", list, expected);
}
__name(oneOf, "oneOf");
Assertion.addMethod("oneOf", oneOf);
function assertChanges(subject, prop, msg) {
  msg && flag2(this, "message", msg);
  var fn3 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn3, flagMsg, ssfi, true).is.a("function");
  var initial;
  prop ? (new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop), initial = subject[prop]) : (new Assertion(subject, flagMsg, ssfi, true).is.a("function"), initial = subject()), fn3();
  var final = prop == null ? subject() : subject[prop], msgObj = prop == null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj), flag2(this, "initialDeltaValue", initial), flag2(this, "finalDeltaValue", final), flag2(this, "deltaBehavior", "change"), flag2(this, "realDelta", final !== initial), this.assert(initial !== final, "expected " + msgObj + " to change", "expected " + msgObj + " to not change");
}
__name(assertChanges, "assertChanges");
Assertion.addMethod("change", assertChanges);
Assertion.addMethod("changes", assertChanges);
function assertIncreases(subject, prop, msg) {
  msg && flag2(this, "message", msg);
  var fn3 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn3, flagMsg, ssfi, true).is.a("function");
  var initial;
  prop ? (new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop), initial = subject[prop]) : (new Assertion(subject, flagMsg, ssfi, true).is.a("function"), initial = subject()), new Assertion(initial, flagMsg, ssfi, true).is.a("number"), fn3();
  var final = prop == null ? subject() : subject[prop], msgObj = prop == null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj), flag2(this, "initialDeltaValue", initial), flag2(this, "finalDeltaValue", final), flag2(this, "deltaBehavior", "increase"), flag2(this, "realDelta", final - initial), this.assert(final - initial > 0, "expected " + msgObj + " to increase", "expected " + msgObj + " to not increase");
}
__name(assertIncreases, "assertIncreases");
Assertion.addMethod("increase", assertIncreases);
Assertion.addMethod("increases", assertIncreases);
function assertDecreases(subject, prop, msg) {
  msg && flag2(this, "message", msg);
  var fn3 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn3, flagMsg, ssfi, true).is.a("function");
  var initial;
  prop ? (new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop), initial = subject[prop]) : (new Assertion(subject, flagMsg, ssfi, true).is.a("function"), initial = subject()), new Assertion(initial, flagMsg, ssfi, true).is.a("number"), fn3();
  var final = prop == null ? subject() : subject[prop], msgObj = prop == null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj), flag2(this, "initialDeltaValue", initial), flag2(this, "finalDeltaValue", final), flag2(this, "deltaBehavior", "decrease"), flag2(this, "realDelta", initial - final), this.assert(final - initial < 0, "expected " + msgObj + " to decrease", "expected " + msgObj + " to not decrease");
}
__name(assertDecreases, "assertDecreases");
Assertion.addMethod("decrease", assertDecreases);
Assertion.addMethod("decreases", assertDecreases);
function assertDelta(delta, msg) {
  msg && flag2(this, "message", msg);
  var msgObj = flag2(this, "deltaMsgObj"), initial = flag2(this, "initialDeltaValue"), final = flag2(this, "finalDeltaValue"), behavior2 = flag2(this, "deltaBehavior"), realDelta = flag2(this, "realDelta"), expression;
  behavior2 === "change" ? expression = Math.abs(final - initial) === Math.abs(delta) : expression = realDelta === Math.abs(delta), this.assert(expression, "expected " + msgObj + " to " + behavior2 + " by " + delta, "expected " + msgObj + " to not " + behavior2 + " by " + delta);
}
__name(assertDelta, "assertDelta");
Assertion.addMethod("by", assertDelta);
Assertion.addProperty("extensible", function() {
  var obj = flag2(this, "object"), isExtensible = obj === Object(obj) && Object.isExtensible(obj);
  this.assert(isExtensible, "expected #{this} to be extensible", "expected #{this} to not be extensible");
});
Assertion.addProperty("sealed", function() {
  var obj = flag2(this, "object"), isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
  this.assert(isSealed, "expected #{this} to be sealed", "expected #{this} to not be sealed");
});
Assertion.addProperty("frozen", function() {
  var obj = flag2(this, "object"), isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
  this.assert(isFrozen, "expected #{this} to be frozen", "expected #{this} to not be frozen");
});
Assertion.addProperty("finite", function(msg) {
  var obj = flag2(this, "object");
  this.assert(typeof obj == "number" && isFinite(obj), "expected #{this} to be a finite number", "expected #{this} to not be a finite number");
});
function expect(val, message) {
  return new Assertion(val, message);
}
__name(expect, "expect");
expect.fail = function(actual, expected, message, operator) {
  throw arguments.length < 2 && (message = actual, actual = void 0), message = message || "expect.fail()", new AssertionError(message, { actual, expected, operator }, expect.fail);
};
var should_exports = {};
__export22(should_exports, { Should: () => Should, should: () => should });
function loadShould() {
  function shouldGetter() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new Assertion(this.valueOf(), null, shouldGetter) : new Assertion(this, null, shouldGetter);
  }
  __name(shouldGetter, "shouldGetter");
  function shouldSetter(value2) {
    Object.defineProperty(this, "should", { value: value2, enumerable: true, configurable: true, writable: true });
  }
  __name(shouldSetter, "shouldSetter"), Object.defineProperty(Object.prototype, "should", { set: shouldSetter, get: shouldGetter, configurable: true });
  var should2 = {};
  return should2.fail = function(actual, expected, message, operator) {
    throw arguments.length < 2 && (message = actual, actual = void 0), message = message || "should.fail()", new AssertionError(message, { actual, expected, operator }, should2.fail);
  }, should2.equal = function(actual, expected, message) {
    new Assertion(actual, message).to.equal(expected);
  }, should2.Throw = function(fn3, errt, errs, msg) {
    new Assertion(fn3, msg).to.Throw(errt, errs);
  }, should2.exist = function(val, msg) {
    new Assertion(val, msg).to.exist;
  }, should2.not = {}, should2.not.equal = function(actual, expected, msg) {
    new Assertion(actual, msg).to.not.equal(expected);
  }, should2.not.Throw = function(fn3, errt, errs, msg) {
    new Assertion(fn3, msg).to.not.Throw(errt, errs);
  }, should2.not.exist = function(val, msg) {
    new Assertion(val, msg).to.not.exist;
  }, should2.throw = should2.Throw, should2.not.throw = should2.not.Throw, should2;
}
__name(loadShould, "loadShould");
var should = loadShould;
var Should = loadShould;
function assert(express, errmsg) {
  var test222 = new Assertion(null, null, assert, true);
  test222.assert(express, errmsg, "[ negation message unavailable ]");
}
__name(assert, "assert");
assert.fail = function(actual, expected, message, operator) {
  throw arguments.length < 2 && (message = actual, actual = void 0), message = message || "assert.fail()", new AssertionError(message, { actual, expected, operator }, assert.fail);
};
assert.isOk = function(val, msg) {
  new Assertion(val, msg, assert.isOk, true).is.ok;
};
assert.isNotOk = function(val, msg) {
  new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
};
assert.equal = function(act, exp, msg) {
  var test222 = new Assertion(act, msg, assert.equal, true);
  test222.assert(exp == flag(test222, "object"), "expected #{this} to equal #{exp}", "expected #{this} to not equal #{act}", exp, act, true);
};
assert.notEqual = function(act, exp, msg) {
  var test222 = new Assertion(act, msg, assert.notEqual, true);
  test222.assert(exp != flag(test222, "object"), "expected #{this} to not equal #{exp}", "expected #{this} to equal #{act}", exp, act, true);
};
assert.strictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
};
assert.notStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
};
assert.deepEqual = assert.deepStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
};
assert.notDeepEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
};
assert.isAbove = function(val, abv, msg) {
  new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
};
assert.isAtLeast = function(val, atlst, msg) {
  new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
};
assert.isBelow = function(val, blw, msg) {
  new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
};
assert.isAtMost = function(val, atmst, msg) {
  new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
};
assert.isTrue = function(val, msg) {
  new Assertion(val, msg, assert.isTrue, true).is.true;
};
assert.isNotTrue = function(val, msg) {
  new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
};
assert.isFalse = function(val, msg) {
  new Assertion(val, msg, assert.isFalse, true).is.false;
};
assert.isNotFalse = function(val, msg) {
  new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
};
assert.isNull = function(val, msg) {
  new Assertion(val, msg, assert.isNull, true).to.equal(null);
};
assert.isNotNull = function(val, msg) {
  new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
};
assert.isNaN = function(val, msg) {
  new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
};
assert.isNotNaN = function(value2, message) {
  new Assertion(value2, message, assert.isNotNaN, true).not.to.be.NaN;
};
assert.exists = function(val, msg) {
  new Assertion(val, msg, assert.exists, true).to.exist;
};
assert.notExists = function(val, msg) {
  new Assertion(val, msg, assert.notExists, true).to.not.exist;
};
assert.isUndefined = function(val, msg) {
  new Assertion(val, msg, assert.isUndefined, true).to.equal(void 0);
};
assert.isDefined = function(val, msg) {
  new Assertion(val, msg, assert.isDefined, true).to.not.equal(void 0);
};
assert.isCallable = function(value2, message) {
  new Assertion(value2, message, assert.isCallable, true).is.callable;
};
assert.isNotCallable = function(value2, message) {
  new Assertion(value2, message, assert.isNotCallable, true).is.not.callable;
};
assert.isObject = function(val, msg) {
  new Assertion(val, msg, assert.isObject, true).to.be.a("object");
};
assert.isNotObject = function(val, msg) {
  new Assertion(val, msg, assert.isNotObject, true).to.not.be.a("object");
};
assert.isArray = function(val, msg) {
  new Assertion(val, msg, assert.isArray, true).to.be.an("array");
};
assert.isNotArray = function(val, msg) {
  new Assertion(val, msg, assert.isNotArray, true).to.not.be.an("array");
};
assert.isString = function(val, msg) {
  new Assertion(val, msg, assert.isString, true).to.be.a("string");
};
assert.isNotString = function(val, msg) {
  new Assertion(val, msg, assert.isNotString, true).to.not.be.a("string");
};
assert.isNumber = function(val, msg) {
  new Assertion(val, msg, assert.isNumber, true).to.be.a("number");
};
assert.isNotNumber = function(val, msg) {
  new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a("number");
};
assert.isFinite = function(val, msg) {
  new Assertion(val, msg, assert.isFinite, true).to.be.finite;
};
assert.isBoolean = function(val, msg) {
  new Assertion(val, msg, assert.isBoolean, true).to.be.a("boolean");
};
assert.isNotBoolean = function(val, msg) {
  new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a("boolean");
};
assert.typeOf = function(val, type32, msg) {
  new Assertion(val, msg, assert.typeOf, true).to.be.a(type32);
};
assert.notTypeOf = function(value2, type32, message) {
  new Assertion(value2, message, assert.notTypeOf, true).to.not.be.a(type32);
};
assert.instanceOf = function(val, type32, msg) {
  new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type32);
};
assert.notInstanceOf = function(val, type32, msg) {
  new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(type32);
};
assert.include = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.include, true).include(inc);
};
assert.notInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
};
assert.deepInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
};
assert.notDeepInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
};
assert.nestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
};
assert.notNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(inc);
};
assert.deepNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(inc);
};
assert.notDeepNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notDeepNestedInclude, true).not.deep.nested.include(inc);
};
assert.ownInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
};
assert.notOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
};
assert.deepOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc);
};
assert.notDeepOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(inc);
};
assert.match = function(exp, re3, msg) {
  new Assertion(exp, msg, assert.match, true).to.match(re3);
};
assert.notMatch = function(exp, re3, msg) {
  new Assertion(exp, msg, assert.notMatch, true).to.not.match(re3);
};
assert.property = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.property, true).to.have.property(prop);
};
assert.notProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
};
assert.propertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
};
assert.notPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(prop, val);
};
assert.deepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(prop, val);
};
assert.notDeepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
};
assert.ownProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
};
assert.notOwnProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(prop);
};
assert.ownPropertyVal = function(obj, prop, value2, msg) {
  new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(prop, value2);
};
assert.notOwnPropertyVal = function(obj, prop, value2, msg) {
  new Assertion(obj, msg, assert.notOwnPropertyVal, true).to.not.have.own.property(prop, value2);
};
assert.deepOwnPropertyVal = function(obj, prop, value2, msg) {
  new Assertion(obj, msg, assert.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value2);
};
assert.notDeepOwnPropertyVal = function(obj, prop, value2, msg) {
  new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value2);
};
assert.nestedProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(prop);
};
assert.notNestedProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notNestedProperty, true).to.not.have.nested.property(prop);
};
assert.nestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.nestedPropertyVal, true).to.have.nested.property(prop, val);
};
assert.notNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
};
assert.deepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
};
assert.notDeepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
};
assert.lengthOf = function(exp, len, msg) {
  new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
};
assert.hasAnyKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys2);
};
assert.hasAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys2);
};
assert.containsAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(keys2);
};
assert.doesNotHaveAnyKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys2);
};
assert.doesNotHaveAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(keys2);
};
assert.hasAnyDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(keys2);
};
assert.hasAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(keys2);
};
assert.containsAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.containsAllDeepKeys, true).to.contain.all.deep.keys(keys2);
};
assert.doesNotHaveAnyDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys2);
};
assert.doesNotHaveAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys2);
};
assert.throws = function(fn3, errorLike, errMsgMatcher, msg) {
  (typeof errorLike == "string" || errorLike instanceof RegExp) && (errMsgMatcher = errorLike, errorLike = null);
  var assertErr = new Assertion(fn3, msg, assert.throws, true).to.throw(errorLike, errMsgMatcher);
  return flag(assertErr, "object");
};
assert.doesNotThrow = function(fn3, errorLike, errMsgMatcher, message) {
  (typeof errorLike == "string" || errorLike instanceof RegExp) && (errMsgMatcher = errorLike, errorLike = null), new Assertion(fn3, message, assert.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
};
assert.operator = function(val, operator, val2, msg) {
  var ok;
  switch (operator) {
    case "==":
      ok = val == val2;
      break;
    case "===":
      ok = val === val2;
      break;
    case ">":
      ok = val > val2;
      break;
    case ">=":
      ok = val >= val2;
      break;
    case "<":
      ok = val < val2;
      break;
    case "<=":
      ok = val <= val2;
      break;
    case "!=":
      ok = val != val2;
      break;
    case "!==":
      ok = val !== val2;
      break;
    default:
      throw msg = msg && msg + ": ", new AssertionError(msg + 'Invalid operator "' + operator + '"', void 0, assert.operator);
  }
  var test222 = new Assertion(ok, msg, assert.operator, true);
  test222.assert(flag(test222, "object") === true, "expected " + inspect22(val) + " to be " + operator + " " + inspect22(val2), "expected " + inspect22(val) + " to not be " + operator + " " + inspect22(val2));
};
assert.closeTo = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
};
assert.approximately = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert.approximately, true).to.be.approximately(exp, delta);
};
assert.sameMembers = function(set1, set2, msg) {
  new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set2);
};
assert.notSameMembers = function(set1, set2, msg) {
  new Assertion(set1, msg, assert.notSameMembers, true).to.not.have.same.members(set2);
};
assert.sameDeepMembers = function(set1, set2, msg) {
  new Assertion(set1, msg, assert.sameDeepMembers, true).to.have.same.deep.members(set2);
};
assert.notSameDeepMembers = function(set1, set2, msg) {
  new Assertion(set1, msg, assert.notSameDeepMembers, true).to.not.have.same.deep.members(set2);
};
assert.sameOrderedMembers = function(set1, set2, msg) {
  new Assertion(set1, msg, assert.sameOrderedMembers, true).to.have.same.ordered.members(set2);
};
assert.notSameOrderedMembers = function(set1, set2, msg) {
  new Assertion(set1, msg, assert.notSameOrderedMembers, true).to.not.have.same.ordered.members(set2);
};
assert.sameDeepOrderedMembers = function(set1, set2, msg) {
  new Assertion(set1, msg, assert.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set2);
};
assert.notSameDeepOrderedMembers = function(set1, set2, msg) {
  new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set2);
};
assert.includeMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeMembers, true).to.include.members(subset);
};
assert.notIncludeMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.notIncludeMembers, true).to.not.include.members(subset);
};
assert.includeDeepMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeDeepMembers, true).to.include.deep.members(subset);
};
assert.notIncludeDeepMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
};
assert.includeOrderedMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeOrderedMembers, true).to.include.ordered.members(subset);
};
assert.notIncludeOrderedMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
};
assert.includeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
};
assert.notIncludeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
};
assert.oneOf = function(inList, list, msg) {
  new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
};
assert.isIterable = function(obj, msg) {
  if (obj == null || !obj[Symbol.iterator]) throw msg = msg ? `${msg} expected ${inspect22(obj)} to be an iterable` : `expected ${inspect22(obj)} to be an iterable`, new AssertionError(msg, void 0, assert.isIterable);
};
assert.changes = function(fn3, obj, prop, msg) {
  arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.changes, true).to.change(obj, prop);
};
assert.changesBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
};
assert.doesNotChange = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.doesNotChange, true).to.not.change(obj, prop);
};
assert.changesButNotBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
};
assert.increases = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.increases, true).to.increase(obj, prop);
};
assert.increasesBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
};
assert.doesNotIncrease = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.doesNotIncrease, true).to.not.increase(obj, prop);
};
assert.increasesButNotBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
};
assert.decreases = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.decreases, true).to.decrease(obj, prop);
};
assert.decreasesBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
};
assert.doesNotDecrease = function(fn3, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn3, msg, assert.doesNotDecrease, true).to.not.decrease(obj, prop);
};
assert.doesNotDecreaseBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  return new Assertion(fn3, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
};
assert.decreasesButNotBy = function(fn3, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn3, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
};
assert.ifError = function(val) {
  if (val) throw val;
};
assert.isExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
};
assert.isNotExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
};
assert.isSealed = function(obj, msg) {
  new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
};
assert.isNotSealed = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
};
assert.isFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
};
assert.isNotFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
};
assert.isEmpty = function(val, msg) {
  new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
};
assert.isNotEmpty = function(val, msg) {
  new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
};
__name(function alias(name2, as2) {
  return assert[as2] = assert[name2], alias;
}, "alias")("isOk", "ok")("isNotOk", "notOk")("throws", "throw")("throws", "Throw")("isExtensible", "extensible")("isNotExtensible", "notExtensible")("isSealed", "sealed")("isNotSealed", "notSealed")("isFrozen", "frozen")("isNotFrozen", "notFrozen")("isEmpty", "empty")("isNotEmpty", "notEmpty")("isCallable", "isFunction")("isNotCallable", "isNotFunction");
var used = [];
function use(fn3) {
  let exports = { AssertionError, util: utils_exports, config, expect, assert, Assertion, ...should_exports };
  return ~used.indexOf(fn3) || (fn3(exports, utils_exports), used.push(fn3)), exports;
}
__name(use, "use");
var matchers_exports = {};
__export2(matchers_exports, { toBeChecked: () => toBeChecked, toBeDisabled: () => toBeDisabled, toBeEmpty: () => toBeEmpty, toBeEmptyDOMElement: () => toBeEmptyDOMElement, toBeEnabled: () => toBeEnabled, toBeInTheDOM: () => toBeInTheDOM, toBeInTheDocument: () => toBeInTheDocument, toBeInvalid: () => toBeInvalid, toBePartiallyChecked: () => toBePartiallyChecked, toBeRequired: () => toBeRequired, toBeValid: () => toBeValid, toBeVisible: () => toBeVisible, toContainElement: () => toContainElement, toContainHTML: () => toContainHTML, toHaveAccessibleDescription: () => toHaveAccessibleDescription, toHaveAccessibleErrorMessage: () => toHaveAccessibleErrorMessage, toHaveAccessibleName: () => toHaveAccessibleName, toHaveAttribute: () => toHaveAttribute, toHaveClass: () => toHaveClass, toHaveDescription: () => toHaveDescription, toHaveDisplayValue: () => toHaveDisplayValue, toHaveErrorMessage: () => toHaveErrorMessage, toHaveFocus: () => toHaveFocus, toHaveFormValues: () => toHaveFormValues, toHaveRole: () => toHaveRole, toHaveStyle: () => toHaveStyle, toHaveTextContent: () => toHaveTextContent, toHaveValue: () => toHaveValue });
var import_redent = __toESM(require_redent(), 1);
function $parcel$defineInteropFlag(a22) {
  Object.defineProperty(a22, "__esModule", { value: true, configurable: true });
}
function $parcel$export(e2, n3, v6, s4) {
  Object.defineProperty(e2, n3, { get: v6, set: s4, enumerable: true, configurable: true });
}
var $009ddb00d3ec72b8$exports = {};
$parcel$defineInteropFlag($009ddb00d3ec72b8$exports);
$parcel$export($009ddb00d3ec72b8$exports, "default", () => $009ddb00d3ec72b8$export$2e2bcd8739ae039);
var $009ddb00d3ec72b8$export$2e2bcd8739ae039 = class extends Error {
  constructor(filename, msg, lineno, column, css) {
    super(filename + ":" + lineno + ":" + column + ": " + msg), this.reason = msg, this.filename = filename, this.line = lineno, this.column = column, this.source = css;
  }
};
var $0865a9fb4cc365fe$exports = {};
$parcel$defineInteropFlag($0865a9fb4cc365fe$exports);
$parcel$export($0865a9fb4cc365fe$exports, "default", () => $0865a9fb4cc365fe$export$2e2bcd8739ae039);
var $0865a9fb4cc365fe$export$2e2bcd8739ae039 = class {
  constructor(start, end, source2) {
    this.start = start, this.end = end, this.source = source2;
  }
};
var $b2e137848b48cf4f$exports = {};
$parcel$export($b2e137848b48cf4f$exports, "CssTypes", () => $b2e137848b48cf4f$export$9be5dd6e61d5d73a);
var $b2e137848b48cf4f$export$9be5dd6e61d5d73a;
(function(CssTypes) {
  CssTypes.stylesheet = "stylesheet", CssTypes.rule = "rule", CssTypes.declaration = "declaration", CssTypes.comment = "comment", CssTypes.container = "container", CssTypes.charset = "charset", CssTypes.document = "document", CssTypes.customMedia = "custom-media", CssTypes.fontFace = "font-face", CssTypes.host = "host", CssTypes.import = "import", CssTypes.keyframes = "keyframes", CssTypes.keyframe = "keyframe", CssTypes.layer = "layer", CssTypes.media = "media", CssTypes.namespace = "namespace", CssTypes.page = "page", CssTypes.startingStyle = "starting-style", CssTypes.supports = "supports";
})($b2e137848b48cf4f$export$9be5dd6e61d5d73a || ($b2e137848b48cf4f$export$9be5dd6e61d5d73a = {}));
var $d708735ed1303b43$var$commentre = /\/\*[^]*?(?:\*\/|$)/g;
var $d708735ed1303b43$export$98e6a39c04603d36 = (css, options2) => {
  options2 = options2 || {};
  let lineno = 1, column = 1;
  function updatePosition(str) {
    let lines = str.match(/\n/g);
    lines && (lineno += lines.length);
    let i4 = str.lastIndexOf(`
`);
    column = ~i4 ? str.length - i4 : column + str.length;
  }
  function position() {
    let start = { line: lineno, column };
    return function(node) {
      return node.position = new $0865a9fb4cc365fe$export$2e2bcd8739ae039(start, { line: lineno, column }, (options2 == null ? void 0 : options2.source) || ""), whitespace(), node;
    };
  }
  let errorsList = [];
  function error(msg) {
    let err = new $009ddb00d3ec72b8$export$2e2bcd8739ae039((options2 == null ? void 0 : options2.source) || "", msg, lineno, column, css);
    if (options2 == null ? void 0 : options2.silent) errorsList.push(err);
    else throw err;
  }
  function stylesheet() {
    let rulesList = rules();
    return { type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.stylesheet, stylesheet: { source: options2 == null ? void 0 : options2.source, rules: rulesList, parsingErrors: errorsList } };
  }
  function open() {
    return match(/^{\s*/);
  }
  function close() {
    return match(/^}/);
  }
  function rules() {
    let node, rules2 = [];
    for (whitespace(), comments(rules2); css.length && css.charAt(0) !== "}" && (node = atrule() || rule()); ) node && (rules2.push(node), comments(rules2));
    return rules2;
  }
  function match(re3) {
    let m22 = re3.exec(css);
    if (!m22) return;
    let str = m22[0];
    return updatePosition(str), css = css.slice(str.length), m22;
  }
  function whitespace() {
    match(/^\s*/);
  }
  function comments(rules2) {
    let c3;
    for (rules2 = rules2 || []; c3 = comment(); ) c3 && rules2.push(c3);
    return rules2;
  }
  function comment() {
    let pos = position();
    if (css.charAt(0) !== "/" || css.charAt(1) !== "*") return;
    let m22 = match(/^\/\*[^]*?\*\//);
    return m22 ? pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.comment, comment: m22[0].slice(2, -2) }) : error("End of comment missing");
  }
  function findClosingParenthese(str, start, depth) {
    let ptr = start + 1, found = false, closeParentheses = str.indexOf(")", ptr);
    for (; !found && closeParentheses !== -1; ) {
      let nextParentheses = str.indexOf("(", ptr);
      nextParentheses !== -1 && nextParentheses < closeParentheses ? (ptr = findClosingParenthese(str, nextParentheses + 1) + 1, closeParentheses = str.indexOf(")", ptr)) : found = true;
    }
    return found && closeParentheses !== -1 ? closeParentheses : -1;
  }
  function selector() {
    let m22 = match(/^([^{]+)/);
    if (!m22) return;
    let res = $d708735ed1303b43$var$trim(m22[0]).replace($d708735ed1303b43$var$commentre, "");
    if (res.indexOf(",") === -1) return [res];
    let ptr = 0, startParentheses = res.indexOf("(", ptr);
    for (; startParentheses !== -1; ) {
      let closeParentheses = findClosingParenthese(res, startParentheses);
      if (closeParentheses === -1) break;
      ptr = closeParentheses + 1, res = res.substring(0, startParentheses) + res.substring(startParentheses, closeParentheses).replace(/,/g, "") + res.substring(closeParentheses), startParentheses = res.indexOf("(", ptr);
    }
    return res = res.replace(/("|')(?:\\\1|.)*?\1/g, (m32) => m32.replace(/,/g, "")), res.split(",").map((s4) => $d708735ed1303b43$var$trim(s4.replace(/\u200C/g, ",")));
  }
  function declaration() {
    let pos = position(), propMatch = match(/^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
    if (!propMatch) return;
    let propValue = $d708735ed1303b43$var$trim(propMatch[0]);
    if (!match(/^:\s*/)) return error("property missing ':'");
    let val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/), ret = pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.declaration, property: propValue.replace($d708735ed1303b43$var$commentre, ""), value: val ? $d708735ed1303b43$var$trim(val[0]).replace($d708735ed1303b43$var$commentre, "") : "" });
    return match(/^[;\s]*/), ret;
  }
  function declarations() {
    let decls = [];
    if (!open()) return error("missing '{'");
    comments(decls);
    let decl;
    for (; decl = declaration(); ) decl && (decls.push(decl), comments(decls));
    return close() ? decls : error("missing '}'");
  }
  function keyframe() {
    let m22, vals = [], pos = position();
    for (; m22 = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/); ) vals.push(m22[1]), match(/^,\s*/);
    if (vals.length) return pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.keyframe, values: vals, declarations: declarations() || [] });
  }
  function atkeyframes() {
    let pos = position(), m1 = match(/^@([-\w]+)?keyframes\s*/);
    if (!m1) return;
    let vendor = m1[1], m22 = match(/^([-\w]+)\s*/);
    if (!m22) return error("@keyframes missing name");
    let name2 = m22[1];
    if (!open()) return error("@keyframes missing '{'");
    let frame, frames = comments();
    for (; frame = keyframe(); ) frames.push(frame), frames = frames.concat(comments());
    return close() ? pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.keyframes, name: name2, vendor, keyframes: frames }) : error("@keyframes missing '}'");
  }
  function atsupports() {
    let pos = position(), m22 = match(/^@supports *([^{]+)/);
    if (!m22) return;
    let supports = $d708735ed1303b43$var$trim(m22[1]);
    if (!open()) return error("@supports missing '{'");
    let style = comments().concat(rules());
    return close() ? pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.supports, supports, rules: style }) : error("@supports missing '}'");
  }
  function athost() {
    let pos = position();
    if (!match(/^@host\s*/)) return;
    if (!open()) return error("@host missing '{'");
    let style = comments().concat(rules());
    return close() ? pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.host, rules: style }) : error("@host missing '}'");
  }
  function atcontainer() {
    let pos = position(), m22 = match(/^@container *([^{]+)/);
    if (!m22) return;
    let container = $d708735ed1303b43$var$trim(m22[1]);
    if (!open()) return error("@container missing '{'");
    let style = comments().concat(rules());
    return close() ? pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.container, container, rules: style }) : error("@container missing '}'");
  }
  function atlayer() {
    let pos = position(), m22 = match(/^@layer *([^{;@]+)/);
    if (!m22) return;
    let layer = $d708735ed1303b43$var$trim(m22[1]);
    if (!open()) return match(/^[;\s]*/), pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.layer, layer });
    let style = comments().concat(rules());
    return close() ? pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.layer, layer, rules: style }) : error("@layer missing '}'");
  }
  function atmedia() {
    let pos = position(), m22 = match(/^@media *([^{]+)/);
    if (!m22) return;
    let media = $d708735ed1303b43$var$trim(m22[1]);
    if (!open()) return error("@media missing '{'");
    let style = comments().concat(rules());
    return close() ? pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.media, media, rules: style }) : error("@media missing '}'");
  }
  function atcustommedia() {
    let pos = position(), m22 = match(/^@custom-media\s+(--\S+)\s*([^{;\s][^{;]*);/);
    if (m22) return pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.customMedia, name: $d708735ed1303b43$var$trim(m22[1]), media: $d708735ed1303b43$var$trim(m22[2]) });
  }
  function atpage() {
    let pos = position();
    if (!match(/^@page */)) return;
    let sel = selector() || [];
    if (!open()) return error("@page missing '{'");
    let decls = comments(), decl;
    for (; decl = declaration(); ) decls.push(decl), decls = decls.concat(comments());
    return close() ? pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.page, selectors: sel, declarations: decls }) : error("@page missing '}'");
  }
  function atdocument() {
    let pos = position(), m22 = match(/^@([-\w]+)?document *([^{]+)/);
    if (!m22) return;
    let vendor = $d708735ed1303b43$var$trim(m22[1]), doc = $d708735ed1303b43$var$trim(m22[2]);
    if (!open()) return error("@document missing '{'");
    let style = comments().concat(rules());
    return close() ? pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.document, document: doc, vendor, rules: style }) : error("@document missing '}'");
  }
  function atfontface() {
    let pos = position();
    if (!match(/^@font-face\s*/)) return;
    if (!open()) return error("@font-face missing '{'");
    let decls = comments(), decl;
    for (; decl = declaration(); ) decls.push(decl), decls = decls.concat(comments());
    return close() ? pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.fontFace, declarations: decls }) : error("@font-face missing '}'");
  }
  function atstartingstyle() {
    let pos = position();
    if (!match(/^@starting-style\s*/)) return;
    if (!open()) return error("@starting-style missing '{'");
    let style = comments().concat(rules());
    return close() ? pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.startingStyle, rules: style }) : error("@starting-style missing '}'");
  }
  let atimport = _compileAtrule("import"), atcharset = _compileAtrule("charset"), atnamespace = _compileAtrule("namespace");
  function _compileAtrule(name2) {
    let re3 = new RegExp("^@" + name2 + `\\s*((?::?[^;'"]|"(?:\\\\"|[^"])*?"|'(?:\\\\'|[^'])*?')+)(?:;|$)`);
    return function() {
      let pos = position(), m22 = match(re3);
      if (!m22) return;
      let ret = { type: name2 };
      return ret[name2] = m22[1].trim(), pos(ret);
    };
  }
  function atrule() {
    if (css[0] === "@") return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface() || atcontainer() || atstartingstyle() || atlayer();
  }
  function rule() {
    let pos = position(), sel = selector();
    return sel ? (comments(), pos({ type: $b2e137848b48cf4f$export$9be5dd6e61d5d73a.rule, selectors: sel, declarations: declarations() || [] })) : error("selector missing");
  }
  return $d708735ed1303b43$var$addParent(stylesheet());
};
function $d708735ed1303b43$var$trim(str) {
  return str ? str.trim() : "";
}
function $d708735ed1303b43$var$addParent(obj, parent) {
  let isNode = obj && typeof obj.type == "string", childParent = isNode ? obj : parent;
  for (let k22 in obj) {
    let value2 = obj[k22];
    Array.isArray(value2) ? value2.forEach((v6) => {
      $d708735ed1303b43$var$addParent(v6, childParent);
    }) : value2 && typeof value2 == "object" && $d708735ed1303b43$var$addParent(value2, childParent);
  }
  return isNode && Object.defineProperty(obj, "parent", { configurable: true, writable: true, enumerable: false, value: parent || null }), obj;
}
var $d708735ed1303b43$export$2e2bcd8739ae039 = $d708735ed1303b43$export$98e6a39c04603d36;
var $149c1bd638913645$export$98e6a39c04603d36 = $d708735ed1303b43$export$2e2bcd8739ae039;
var toStr = Object.prototype.toString;
function isCallable(fn3) {
  return typeof fn3 == "function" || toStr.call(fn3) === "[object Function]";
}
function toInteger(value2) {
  var number = Number(value2);
  return isNaN(number) ? 0 : number === 0 || !isFinite(number) ? number : (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(value2) {
  var len = toInteger(value2);
  return Math.min(Math.max(len, 0), maxSafeInteger);
}
function arrayFrom(arrayLike, mapFn) {
  var C32 = Array, items = Object(arrayLike);
  if (arrayLike == null) throw new TypeError("Array.from requires an array-like object - not null or undefined");
  if (typeof mapFn < "u" && !isCallable(mapFn)) throw new TypeError("Array.from: when provided, the second argument must be a function");
  for (var len = toLength(items.length), A4 = isCallable(C32) ? Object(new C32(len)) : new Array(len), k22 = 0, kValue; k22 < len; ) kValue = items[k22], mapFn ? A4[k22] = mapFn(kValue, k22) : A4[k22] = kValue, k22 += 1;
  return A4.length = len, A4;
}
function _typeof(o3) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && typeof Symbol == "function" && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof(o3);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i4 = 0; i4 < props.length; i4++) {
    var descriptor = props[i4];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Object.defineProperty(Constructor, "prototype", { writable: false }), Constructor;
}
function _defineProperty(obj, key2, value2) {
  return key2 = _toPropertyKey(key2), key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
function _toPropertyKey(arg) {
  var key2 = _toPrimitive(arg, "string");
  return _typeof(key2) === "symbol" ? key2 : String(key2);
}
function _toPrimitive(input2, hint) {
  if (_typeof(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var SetLike = function() {
  function SetLike3() {
    var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck(this, SetLike3), _defineProperty(this, "items", void 0), this.items = items;
  }
  return _createClass(SetLike3, [{ key: "add", value: function(value2) {
    return this.has(value2) === false && this.items.push(value2), this;
  } }, { key: "clear", value: function() {
    this.items = [];
  } }, { key: "delete", value: function(value2) {
    var previousLength = this.items.length;
    return this.items = this.items.filter(function(item) {
      return item !== value2;
    }), previousLength !== this.items.length;
  } }, { key: "forEach", value: function(callbackfn) {
    var _this = this;
    this.items.forEach(function(item) {
      callbackfn(item, item, _this);
    });
  } }, { key: "has", value: function(value2) {
    return this.items.indexOf(value2) !== -1;
  } }, { key: "size", get: function() {
    return this.items.length;
  } }]), SetLike3;
}();
var SetLike_default = typeof Set > "u" ? Set : SetLike;
function getLocalName(element) {
  var _element$localName;
  return (_element$localName = element.localName) !== null && _element$localName !== void 0 ? _element$localName : element.tagName.toLowerCase();
}
var localNameToRoleMappings = { article: "article", aside: "complementary", button: "button", datalist: "listbox", dd: "definition", details: "group", dialog: "dialog", dt: "term", fieldset: "group", figure: "figure", form: "form", footer: "contentinfo", h1: "heading", h2: "heading", h3: "heading", h4: "heading", h5: "heading", h6: "heading", header: "banner", hr: "separator", html: "document", legend: "legend", li: "listitem", math: "math", main: "main", menu: "list", nav: "navigation", ol: "list", optgroup: "group", option: "option", output: "status", progress: "progressbar", section: "region", summary: "button", table: "table", tbody: "rowgroup", textarea: "textbox", tfoot: "rowgroup", td: "cell", th: "columnheader", thead: "rowgroup", tr: "row", ul: "list" };
var prohibitedAttributes = { caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]), insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), none: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]) };
function hasGlobalAriaAttributes(element, role) {
  return ["aria-atomic", "aria-busy", "aria-controls", "aria-current", "aria-description", "aria-describedby", "aria-details", "aria-dropeffect", "aria-flowto", "aria-grabbed", "aria-hidden", "aria-keyshortcuts", "aria-label", "aria-labelledby", "aria-live", "aria-owns", "aria-relevant", "aria-roledescription"].some(function(attributeName) {
    var _prohibitedAttributes;
    return element.hasAttribute(attributeName) && !((_prohibitedAttributes = prohibitedAttributes[role]) !== null && _prohibitedAttributes !== void 0 && _prohibitedAttributes.has(attributeName));
  });
}
function ignorePresentationalRole(element, implicitRole) {
  return hasGlobalAriaAttributes(element, implicitRole);
}
function getRole(element) {
  var explicitRole = getExplicitRole(element);
  if (explicitRole === null || presentationRoles.indexOf(explicitRole) !== -1) {
    var implicitRole = getImplicitRole(element);
    if (presentationRoles.indexOf(explicitRole || "") === -1 || ignorePresentationalRole(element, implicitRole || "")) return implicitRole;
  }
  return explicitRole;
}
function getImplicitRole(element) {
  var mappedByTag = localNameToRoleMappings[getLocalName(element)];
  if (mappedByTag !== void 0) return mappedByTag;
  switch (getLocalName(element)) {
    case "a":
    case "area":
    case "link":
      if (element.hasAttribute("href")) return "link";
      break;
    case "img":
      return element.getAttribute("alt") === "" && !ignorePresentationalRole(element, "img") ? "presentation" : "img";
    case "input": {
      var _ref = element, type5 = _ref.type;
      switch (type5) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return type5;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return element.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return element.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return element.hasAttribute("multiple") || element.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
function getExplicitRole(element) {
  var role = element.getAttribute("role");
  if (role !== null) {
    var explicitRole = role.trim().split(" ")[0];
    if (explicitRole.length > 0) return explicitRole;
  }
  return null;
}
var presentationRoles = ["presentation", "none"];
function isElement(node) {
  return node !== null && node.nodeType === node.ELEMENT_NODE;
}
function isHTMLTableCaptionElement(node) {
  return isElement(node) && getLocalName(node) === "caption";
}
function isHTMLInputElement(node) {
  return isElement(node) && getLocalName(node) === "input";
}
function isHTMLOptGroupElement(node) {
  return isElement(node) && getLocalName(node) === "optgroup";
}
function isHTMLSelectElement(node) {
  return isElement(node) && getLocalName(node) === "select";
}
function isHTMLTableElement(node) {
  return isElement(node) && getLocalName(node) === "table";
}
function isHTMLTextAreaElement(node) {
  return isElement(node) && getLocalName(node) === "textarea";
}
function safeWindow(node) {
  var _ref = node.ownerDocument === null ? node : node.ownerDocument, defaultView = _ref.defaultView;
  if (defaultView === null) throw new TypeError("no window available");
  return defaultView;
}
function isHTMLFieldSetElement(node) {
  return isElement(node) && getLocalName(node) === "fieldset";
}
function isHTMLLegendElement(node) {
  return isElement(node) && getLocalName(node) === "legend";
}
function isHTMLSlotElement(node) {
  return isElement(node) && getLocalName(node) === "slot";
}
function isSVGElement(node) {
  return isElement(node) && node.ownerSVGElement !== void 0;
}
function isSVGSVGElement(node) {
  return isElement(node) && getLocalName(node) === "svg";
}
function isSVGTitleElement(node) {
  return isSVGElement(node) && getLocalName(node) === "title";
}
function queryIdRefs(node, attributeName) {
  if (isElement(node) && node.hasAttribute(attributeName)) {
    var ids = node.getAttribute(attributeName).split(" "), root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    return ids.map(function(id) {
      return root2.getElementById(id);
    }).filter(function(element) {
      return element !== null;
    });
  }
  return [];
}
function hasAnyConcreteRoles(node, roles3) {
  return isElement(node) ? roles3.indexOf(getRole(node)) !== -1 : false;
}
function asFlatString(s4) {
  return s4.trim().replace(/\s\s+/g, " ");
}
function isHidden(node, getComputedStyleImplementation) {
  if (!isElement(node)) return false;
  if (node.hasAttribute("hidden") || node.getAttribute("aria-hidden") === "true") return true;
  var style = getComputedStyleImplementation(node);
  return style.getPropertyValue("display") === "none" || style.getPropertyValue("visibility") === "hidden";
}
function isControl(node) {
  return hasAnyConcreteRoles(node, ["button", "combobox", "listbox", "textbox"]) || hasAbstractRole(node, "range");
}
function hasAbstractRole(node, role) {
  if (!isElement(node)) return false;
  switch (role) {
    case "range":
      return hasAnyConcreteRoles(node, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(role, "'. This is likely a bug :("));
  }
}
function querySelectorAllSubtree(element, selectors) {
  var elements = arrayFrom(element.querySelectorAll(selectors));
  return queryIdRefs(element, "aria-owns").forEach(function(root2) {
    elements.push.apply(elements, arrayFrom(root2.querySelectorAll(selectors)));
  }), elements;
}
function querySelectedOptions(listbox) {
  return isHTMLSelectElement(listbox) ? listbox.selectedOptions || querySelectorAllSubtree(listbox, "[selected]") : querySelectorAllSubtree(listbox, '[aria-selected="true"]');
}
function isMarkedPresentational(node) {
  return hasAnyConcreteRoles(node, presentationRoles);
}
function isNativeHostLanguageTextAlternativeElement(node) {
  return isHTMLTableCaptionElement(node);
}
function allowsNameFromContent(node) {
  return hasAnyConcreteRoles(node, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
function isDescendantOfNativeHostLanguageTextAlternativeElement(node) {
  return false;
}
function getValueOfTextbox(element) {
  return isHTMLInputElement(element) || isHTMLTextAreaElement(element) ? element.value : element.textContent || "";
}
function getTextualContent(declaration) {
  var content = declaration.getPropertyValue("content");
  return /^["'].*["']$/.test(content) ? content.slice(1, -1) : "";
}
function isLabelableElement(element) {
  var localName = getLocalName(element);
  return localName === "button" || localName === "input" && element.getAttribute("type") !== "hidden" || localName === "meter" || localName === "output" || localName === "progress" || localName === "select" || localName === "textarea";
}
function findLabelableElement(element) {
  if (isLabelableElement(element)) return element;
  var labelableElement = null;
  return element.childNodes.forEach(function(childNode) {
    if (labelableElement === null && isElement(childNode)) {
      var descendantLabelableElement = findLabelableElement(childNode);
      descendantLabelableElement !== null && (labelableElement = descendantLabelableElement);
    }
  }), labelableElement;
}
function getControlOfLabel(label) {
  if (label.control !== void 0) return label.control;
  var htmlFor = label.getAttribute("for");
  return htmlFor !== null ? label.ownerDocument.getElementById(htmlFor) : findLabelableElement(label);
}
function getLabels(element) {
  var labelsProperty = element.labels;
  if (labelsProperty === null) return labelsProperty;
  if (labelsProperty !== void 0) return arrayFrom(labelsProperty);
  if (!isLabelableElement(element)) return null;
  var document2 = element.ownerDocument;
  return arrayFrom(document2.querySelectorAll("label")).filter(function(label) {
    return getControlOfLabel(label) === element;
  });
}
function getSlotContents(slot) {
  var assignedNodes = slot.assignedNodes();
  return assignedNodes.length === 0 ? arrayFrom(slot.childNodes) : assignedNodes;
}
function computeTextAlternative(root2) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, consultedNodes = new SetLike_default(), window2 = safeWindow(root2), _options$compute = options2.compute, compute = _options$compute === void 0 ? "name" : _options$compute, _options$computedStyl = options2.computedStyleSupportsPseudoElements, computedStyleSupportsPseudoElements = _options$computedStyl === void 0 ? options2.getComputedStyle !== void 0 : _options$computedStyl, _options$getComputedS = options2.getComputedStyle, getComputedStyle = _options$getComputedS === void 0 ? window2.getComputedStyle.bind(window2) : _options$getComputedS, _options$hidden = options2.hidden, hidden = _options$hidden === void 0 ? false : _options$hidden;
  function computeMiscTextAlternative(node, context) {
    var accumulatedText = "";
    if (isElement(node) && computedStyleSupportsPseudoElements) {
      var pseudoBefore = getComputedStyle(node, "::before"), beforeContent = getTextualContent(pseudoBefore);
      accumulatedText = "".concat(beforeContent, " ").concat(accumulatedText);
    }
    var childNodes = isHTMLSlotElement(node) ? getSlotContents(node) : arrayFrom(node.childNodes).concat(queryIdRefs(node, "aria-owns"));
    if (childNodes.forEach(function(child) {
      var result2 = computeTextAlternative3(child, { isEmbeddedInLabel: context.isEmbeddedInLabel, isReferenced: false, recursion: true }), display2 = isElement(child) ? getComputedStyle(child).getPropertyValue("display") : "inline", separator = display2 !== "inline" ? " " : "";
      accumulatedText += "".concat(separator).concat(result2).concat(separator);
    }), isElement(node) && computedStyleSupportsPseudoElements) {
      var pseudoAfter = getComputedStyle(node, "::after"), afterContent = getTextualContent(pseudoAfter);
      accumulatedText = "".concat(accumulatedText, " ").concat(afterContent);
    }
    return accumulatedText.trim();
  }
  function useAttribute(element, attributeName) {
    var attribute = element.getAttributeNode(attributeName);
    return attribute !== null && !consultedNodes.has(attribute) && attribute.value.trim() !== "" ? (consultedNodes.add(attribute), attribute.value) : null;
  }
  function computeTooltipAttributeValue(node) {
    return isElement(node) ? useAttribute(node, "title") : null;
  }
  function computeElementTextAlternative(node) {
    if (!isElement(node)) return null;
    if (isHTMLFieldSetElement(node)) {
      consultedNodes.add(node);
      for (var children = arrayFrom(node.childNodes), i4 = 0; i4 < children.length; i4 += 1) {
        var child = children[i4];
        if (isHTMLLegendElement(child)) return computeTextAlternative3(child, { isEmbeddedInLabel: false, isReferenced: false, recursion: false });
      }
    } else if (isHTMLTableElement(node)) {
      consultedNodes.add(node);
      for (var _children = arrayFrom(node.childNodes), _i = 0; _i < _children.length; _i += 1) {
        var _child = _children[_i];
        if (isHTMLTableCaptionElement(_child)) return computeTextAlternative3(_child, { isEmbeddedInLabel: false, isReferenced: false, recursion: false });
      }
    } else if (isSVGSVGElement(node)) {
      consultedNodes.add(node);
      for (var _children2 = arrayFrom(node.childNodes), _i2 = 0; _i2 < _children2.length; _i2 += 1) {
        var _child2 = _children2[_i2];
        if (isSVGTitleElement(_child2)) return _child2.textContent;
      }
      return null;
    } else if (getLocalName(node) === "img" || getLocalName(node) === "area") {
      var nameFromAlt = useAttribute(node, "alt");
      if (nameFromAlt !== null) return nameFromAlt;
    } else if (isHTMLOptGroupElement(node)) {
      var nameFromLabel = useAttribute(node, "label");
      if (nameFromLabel !== null) return nameFromLabel;
    }
    if (isHTMLInputElement(node) && (node.type === "button" || node.type === "submit" || node.type === "reset")) {
      var nameFromValue = useAttribute(node, "value");
      if (nameFromValue !== null) return nameFromValue;
      if (node.type === "submit") return "Submit";
      if (node.type === "reset") return "Reset";
    }
    var labels = getLabels(node);
    if (labels !== null && labels.length !== 0) return consultedNodes.add(node), arrayFrom(labels).map(function(element) {
      return computeTextAlternative3(element, { isEmbeddedInLabel: true, isReferenced: false, recursion: true });
    }).filter(function(label) {
      return label.length > 0;
    }).join(" ");
    if (isHTMLInputElement(node) && node.type === "image") {
      var _nameFromAlt = useAttribute(node, "alt");
      if (_nameFromAlt !== null) return _nameFromAlt;
      var nameFromTitle = useAttribute(node, "title");
      return nameFromTitle !== null ? nameFromTitle : "Submit Query";
    }
    if (hasAnyConcreteRoles(node, ["button"])) {
      var nameFromSubTree = computeMiscTextAlternative(node, { isEmbeddedInLabel: false, isReferenced: false });
      if (nameFromSubTree !== "") return nameFromSubTree;
    }
    return null;
  }
  function computeTextAlternative3(current, context) {
    if (consultedNodes.has(current)) return "";
    if (!hidden && isHidden(current, getComputedStyle) && !context.isReferenced) return consultedNodes.add(current), "";
    var labelAttributeNode = isElement(current) ? current.getAttributeNode("aria-labelledby") : null, labelElements = labelAttributeNode !== null && !consultedNodes.has(labelAttributeNode) ? queryIdRefs(current, "aria-labelledby") : [];
    if (compute === "name" && !context.isReferenced && labelElements.length > 0) return consultedNodes.add(labelAttributeNode), labelElements.map(function(element) {
      return computeTextAlternative3(element, { isEmbeddedInLabel: context.isEmbeddedInLabel, isReferenced: true, recursion: false });
    }).join(" ");
    var skipToStep2E = context.recursion && isControl(current) && compute === "name";
    if (!skipToStep2E) {
      var ariaLabel = (isElement(current) && current.getAttribute("aria-label") || "").trim();
      if (ariaLabel !== "" && compute === "name") return consultedNodes.add(current), ariaLabel;
      if (!isMarkedPresentational(current)) {
        var elementTextAlternative = computeElementTextAlternative(current);
        if (elementTextAlternative !== null) return consultedNodes.add(current), elementTextAlternative;
      }
    }
    if (hasAnyConcreteRoles(current, ["menu"])) return consultedNodes.add(current), "";
    if (skipToStep2E || context.isEmbeddedInLabel || context.isReferenced) {
      if (hasAnyConcreteRoles(current, ["combobox", "listbox"])) {
        consultedNodes.add(current);
        var selectedOptions = querySelectedOptions(current);
        return selectedOptions.length === 0 ? isHTMLInputElement(current) ? current.value : "" : arrayFrom(selectedOptions).map(function(selectedOption) {
          return computeTextAlternative3(selectedOption, { isEmbeddedInLabel: context.isEmbeddedInLabel, isReferenced: false, recursion: true });
        }).join(" ");
      }
      if (hasAbstractRole(current, "range")) return consultedNodes.add(current), current.hasAttribute("aria-valuetext") ? current.getAttribute("aria-valuetext") : current.hasAttribute("aria-valuenow") ? current.getAttribute("aria-valuenow") : current.getAttribute("value") || "";
      if (hasAnyConcreteRoles(current, ["textbox"])) return consultedNodes.add(current), getValueOfTextbox(current);
    }
    if (allowsNameFromContent(current) || isElement(current) && context.isReferenced || isNativeHostLanguageTextAlternativeElement(current) || isDescendantOfNativeHostLanguageTextAlternativeElement()) {
      var accumulatedText2F = computeMiscTextAlternative(current, { isEmbeddedInLabel: context.isEmbeddedInLabel, isReferenced: false });
      if (accumulatedText2F !== "") return consultedNodes.add(current), accumulatedText2F;
    }
    if (current.nodeType === current.TEXT_NODE) return consultedNodes.add(current), current.textContent || "";
    if (context.recursion) return consultedNodes.add(current), computeMiscTextAlternative(current, { isEmbeddedInLabel: context.isEmbeddedInLabel, isReferenced: false });
    var tooltipAttributeValue = computeTooltipAttributeValue(current);
    return tooltipAttributeValue !== null ? (consultedNodes.add(current), tooltipAttributeValue) : (consultedNodes.add(current), "");
  }
  return asFlatString(computeTextAlternative3(root2, { isEmbeddedInLabel: false, isReferenced: compute === "description", recursion: false }));
}
function _typeof2(o3) {
  "@babel/helpers - typeof";
  return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && typeof Symbol == "function" && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof2(o3);
}
function ownKeys(e2, r4) {
  var t4 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e2);
    r4 && (o3 = o3.filter(function(r22) {
      return Object.getOwnPropertyDescriptor(e2, r22).enumerable;
    })), t4.push.apply(t4, o3);
  }
  return t4;
}
function _objectSpread(e2) {
  for (var r4 = 1; r4 < arguments.length; r4++) {
    var t4 = arguments[r4] != null ? arguments[r4] : {};
    r4 % 2 ? ownKeys(Object(t4), true).forEach(function(r22) {
      _defineProperty2(e2, r22, t4[r22]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t4)) : ownKeys(Object(t4)).forEach(function(r22) {
      Object.defineProperty(e2, r22, Object.getOwnPropertyDescriptor(t4, r22));
    });
  }
  return e2;
}
function _defineProperty2(obj, key2, value2) {
  return key2 = _toPropertyKey2(key2), key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
function _toPropertyKey2(arg) {
  var key2 = _toPrimitive2(arg, "string");
  return _typeof2(key2) === "symbol" ? key2 : String(key2);
}
function _toPrimitive2(input2, hint) {
  if (_typeof2(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof2(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function computeAccessibleDescription(root2) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, description = queryIdRefs(root2, "aria-describedby").map(function(element) {
    return computeTextAlternative(element, _objectSpread(_objectSpread({}, options2), {}, { compute: "description" }));
  }).join(" ");
  if (description === "") {
    var ariaDescription = root2.getAttribute("aria-description");
    description = ariaDescription === null ? "" : ariaDescription;
  }
  if (description === "") {
    var title = root2.getAttribute("title");
    description = title === null ? "" : title;
  }
  return description;
}
function prohibitsNaming(node) {
  return hasAnyConcreteRoles(node, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "none", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
function computeAccessibleName(root2) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return prohibitsNaming(root2) ? "" : computeTextAlternative(root2, options2);
}
var import_aria_query = __toESM(require_lib(), 1);
var import_chalk = __toESM(require_source(), 1);
var import_isEqualWith = __toESM(require_isEqualWith(), 1);
var import_css = __toESM(require_css_escape(), 1);
var GenericTypeError = class extends Error {
  constructor(expectedString, received, matcherFn, context) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, matcherFn);
    let withType = "";
    try {
      withType = context.utils.printWithType("Received", received, context.utils.printReceived);
    } catch {
    }
    this.message = [context.utils.matcherHint(`${context.isNot ? ".not" : ""}.${matcherFn.name}`, "received", ""), "", `${context.utils.RECEIVED_COLOR("received")} value must ${expectedString}.`, withType].join(`
`);
  }
};
var HtmlElementTypeError = class extends GenericTypeError {
  constructor(...args2) {
    super("be an HTMLElement or an SVGElement", ...args2);
  }
};
var NodeTypeError = class extends GenericTypeError {
  constructor(...args2) {
    super("be a Node", ...args2);
  }
};
function checkHasWindow(htmlElement, ErrorClass, ...args2) {
  if (!htmlElement || !htmlElement.ownerDocument || !htmlElement.ownerDocument.defaultView) throw new ErrorClass(htmlElement, ...args2);
}
function checkNode(node, ...args2) {
  checkHasWindow(node, NodeTypeError, ...args2);
  let window2 = node.ownerDocument.defaultView;
  if (!(node instanceof window2.Node)) throw new NodeTypeError(node, ...args2);
}
function checkHtmlElement(htmlElement, ...args2) {
  checkHasWindow(htmlElement, HtmlElementTypeError, ...args2);
  let window2 = htmlElement.ownerDocument.defaultView;
  if (!(htmlElement instanceof window2.HTMLElement) && !(htmlElement instanceof window2.SVGElement)) throw new HtmlElementTypeError(htmlElement, ...args2);
}
var InvalidCSSError = class extends Error {
  constructor(received, matcherFn, context) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, matcherFn), this.message = [received.message, "", context.utils.RECEIVED_COLOR("Failing css:"), context.utils.RECEIVED_COLOR(`${received.css}`)].join(`
`);
  }
};
function parseCSS(css, ...args2) {
  let ast = $149c1bd638913645$export$98e6a39c04603d36(`selector { ${css} }`, { silent: true }).stylesheet;
  if (ast.parsingErrors && ast.parsingErrors.length > 0) {
    let { reason, line } = ast.parsingErrors[0];
    throw new InvalidCSSError({ css, message: `Syntax error parsing expected css: ${reason} on line: ${line}` }, ...args2);
  }
  return ast.rules[0].declarations.filter((d22) => d22.type === "declaration").reduce((obj, { property, value: value2 }) => Object.assign(obj, { [property]: value2 }), {});
}
function display(context, value2) {
  return typeof value2 == "string" ? value2 : context.utils.stringify(value2);
}
function getMessage3(context, matcher, expectedLabel, expectedValue, receivedLabel, receivedValue) {
  return [`${matcher}
`, `${expectedLabel}:
${context.utils.EXPECTED_COLOR((0, import_redent.default)(display(context, expectedValue), 2))}`, `${receivedLabel}:
${context.utils.RECEIVED_COLOR((0, import_redent.default)(display(context, receivedValue), 2))}`].join(`
`);
}
function matches(textToMatch, matcher) {
  return matcher instanceof RegExp ? matcher.test(textToMatch) : textToMatch.includes(String(matcher));
}
function deprecate(name2, replacementText) {
  console.warn(`Warning: ${name2} has been deprecated and will be removed in future updates.`, replacementText);
}
function normalize(text) {
  return text.replace(/\s+/g, " ").trim();
}
function getTag(element) {
  return element.tagName && element.tagName.toLowerCase();
}
function getSelectValue({ multiple, options: options2 }) {
  let selectedOptions = [...options2].filter((option) => option.selected);
  if (multiple) return [...selectedOptions].map((opt) => opt.value);
  if (selectedOptions.length !== 0) return selectedOptions[0].value;
}
function getInputValue(inputElement) {
  switch (inputElement.type) {
    case "number":
      return inputElement.value === "" ? null : Number(inputElement.value);
    case "checkbox":
      return inputElement.checked;
    default:
      return inputElement.value;
  }
}
var rolesSupportingValues = ["meter", "progressbar", "slider", "spinbutton"];
function getAccessibleValue(element) {
  if (rolesSupportingValues.includes(element.getAttribute("role"))) return Number(element.getAttribute("aria-valuenow"));
}
function getSingleElementValue(element) {
  if (element) switch (element.tagName.toLowerCase()) {
    case "input":
      return getInputValue(element);
    case "select":
      return getSelectValue(element);
    default:
      return element.value ?? getAccessibleValue(element);
  }
}
function toSentence(array, { wordConnector = ", ", lastWordConnector = " and " } = {}) {
  return [array.slice(0, -1).join(wordConnector), array[array.length - 1]].join(array.length > 1 ? lastWordConnector : "");
}
function compareArraysAsSet(arr1, arr2) {
  if (Array.isArray(arr1) && Array.isArray(arr2)) return [...new Set(arr1)].every((v6) => new Set(arr2).has(v6));
}
function toBeInTheDOM(element, container) {
  return deprecate("toBeInTheDOM", "Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container."), element && checkHtmlElement(element, toBeInTheDOM, this), container && checkHtmlElement(container, toBeInTheDOM, this), { pass: container ? container.contains(element) : !!element, message: () => [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toBeInTheDOM`, "element", ""), "", "Received:", `  ${this.utils.printReceived(element && element.cloneNode(false))}`].join(`
`) };
}
function toBeInTheDocument(element) {
  (element !== null || !this.isNot) && checkHtmlElement(element, toBeInTheDocument, this);
  let pass = element === null ? false : element.ownerDocument === element.getRootNode({ composed: true }), errorFound = () => `expected document not to contain element, found ${this.utils.stringify(element.cloneNode(true))} instead`, errorNotFound = () => "element could not be found in the document";
  return { pass, message: () => [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toBeInTheDocument`, "element", ""), "", this.utils.RECEIVED_COLOR(this.isNot ? errorFound() : errorNotFound())].join(`
`) };
}
function toBeEmpty(element) {
  return deprecate("toBeEmpty", "Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM."), checkHtmlElement(element, toBeEmpty, this), { pass: element.innerHTML === "", message: () => [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toBeEmpty`, "element", ""), "", "Received:", `  ${this.utils.printReceived(element.innerHTML)}`].join(`
`) };
}
function toBeEmptyDOMElement(element) {
  return checkHtmlElement(element, toBeEmptyDOMElement, this), { pass: isEmptyElement(element), message: () => [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toBeEmptyDOMElement`, "element", ""), "", "Received:", `  ${this.utils.printReceived(element.innerHTML)}`].join(`
`) };
}
function isEmptyElement(element) {
  return [...element.childNodes].filter((node) => node.nodeType !== 8).length === 0;
}
function toContainElement(container, element) {
  return checkHtmlElement(container, toContainElement, this), element !== null && checkHtmlElement(element, toContainElement, this), { pass: container.contains(element), message: () => [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toContainElement`, "element", "element"), "", this.utils.RECEIVED_COLOR(`${this.utils.stringify(container.cloneNode(false))} ${this.isNot ? "contains:" : "does not contain:"} ${this.utils.stringify(element && element.cloneNode(false))}
        `)].join(`
`) };
}
function getNormalizedHtml(container, htmlText) {
  let div = container.ownerDocument.createElement("div");
  return div.innerHTML = htmlText, div.innerHTML;
}
function toContainHTML(container, htmlText) {
  if (checkHtmlElement(container, toContainHTML, this), typeof htmlText != "string") throw new Error(`.toContainHTML() expects a string value, got ${htmlText}`);
  return { pass: container.outerHTML.includes(getNormalizedHtml(container, htmlText)), message: () => [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toContainHTML`, "element", ""), "Expected:", `  ${this.utils.EXPECTED_COLOR(htmlText)}`, "Received:", `  ${this.utils.printReceived(container.cloneNode(true))}`].join(`
`) };
}
function toHaveTextContent(node, checkWith, options2 = { normalizeWhitespace: true }) {
  checkNode(node, toHaveTextContent, this);
  let textContent = options2.normalizeWhitespace ? normalize(node.textContent) : node.textContent.replace(/\u00a0/g, " "), checkingWithEmptyString = textContent !== "" && checkWith === "";
  return { pass: !checkingWithEmptyString && matches(textContent, checkWith), message: () => {
    let to3 = this.isNot ? "not to" : "to";
    return getMessage3(this, this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toHaveTextContent`, "element", ""), checkingWithEmptyString ? "Checking with empty string will always match, use .toBeEmptyDOMElement() instead" : `Expected element ${to3} have text content`, checkWith, "Received", textContent);
  } };
}
function toHaveAccessibleDescription(htmlElement, expectedAccessibleDescription) {
  checkHtmlElement(htmlElement, toHaveAccessibleDescription, this);
  let actualAccessibleDescription = computeAccessibleDescription(htmlElement), missingExpectedValue = arguments.length === 1, pass = false;
  return missingExpectedValue ? pass = actualAccessibleDescription !== "" : pass = expectedAccessibleDescription instanceof RegExp ? expectedAccessibleDescription.test(actualAccessibleDescription) : this.equals(actualAccessibleDescription, expectedAccessibleDescription), { pass, message: () => {
    let to3 = this.isNot ? "not to" : "to";
    return getMessage3(this, this.utils.matcherHint(`${this.isNot ? ".not" : ""}.${toHaveAccessibleDescription.name}`, "element", ""), `Expected element ${to3} have accessible description`, expectedAccessibleDescription, "Received", actualAccessibleDescription);
  } };
}
var ariaInvalidName = "aria-invalid";
var validStates = ["false"];
function toHaveAccessibleErrorMessage(htmlElement, expectedAccessibleErrorMessage) {
  var _a2;
  checkHtmlElement(htmlElement, toHaveAccessibleErrorMessage, this);
  let to3 = this.isNot ? "not to" : "to", method = this.isNot ? ".not.toHaveAccessibleErrorMessage" : ".toHaveAccessibleErrorMessage", errormessageId = htmlElement.getAttribute("aria-errormessage");
  if (!!errormessageId && /\s+/.test(errormessageId)) return { pass: false, message: () => getMessage3(this, this.utils.matcherHint(method, "element"), "Expected element's `aria-errormessage` attribute to be empty or a single, valid ID", "", "Received", `aria-errormessage="${errormessageId}"`) };
  let ariaInvalidVal = htmlElement.getAttribute(ariaInvalidName);
  if (!htmlElement.hasAttribute(ariaInvalidName) || validStates.includes(ariaInvalidVal)) return { pass: false, message: () => getMessage3(this, this.utils.matcherHint(method, "element"), "Expected element to be marked as invalid with attribute", `${ariaInvalidName}="${String(true)}"`, "Received", htmlElement.hasAttribute("aria-invalid") ? `${ariaInvalidName}="${htmlElement.getAttribute(ariaInvalidName)}` : null) };
  let error = normalize(((_a2 = htmlElement.ownerDocument.getElementById(errormessageId)) == null ? void 0 : _a2.textContent) ?? "");
  return { pass: expectedAccessibleErrorMessage === void 0 ? !!error : expectedAccessibleErrorMessage instanceof RegExp ? expectedAccessibleErrorMessage.test(error) : this.equals(error, expectedAccessibleErrorMessage), message: () => getMessage3(this, this.utils.matcherHint(method, "element"), `Expected element ${to3} have accessible error message`, expectedAccessibleErrorMessage ?? "", "Received", error) };
}
var elementRoleList = buildElementRoleList(import_aria_query.elementRoles);
function toHaveRole(htmlElement, expectedRole) {
  checkHtmlElement(htmlElement, toHaveRole, this);
  let actualRoles = getExplicitOrImplicitRoles(htmlElement);
  return { pass: actualRoles.some((el) => el === expectedRole), message: () => {
    let to3 = this.isNot ? "not to" : "to";
    return getMessage3(this, this.utils.matcherHint(`${this.isNot ? ".not" : ""}.${toHaveRole.name}`, "element", ""), `Expected element ${to3} have role`, expectedRole, "Received", actualRoles.join(", "));
  } };
}
function getExplicitOrImplicitRoles(htmlElement) {
  return htmlElement.hasAttribute("role") ? htmlElement.getAttribute("role").split(" ").filter(Boolean) : getImplicitAriaRoles(htmlElement);
}
function getImplicitAriaRoles(currentNode) {
  for (let { match, roles: roles3 } of elementRoleList) if (match(currentNode)) return [...roles3];
  return [];
}
function buildElementRoleList(elementRolesMap) {
  function makeElementSelector({ name: name2, attributes }) {
    return `${name2}${attributes.map(({ name: attributeName, value: value2, constraints = [] }) => constraints.indexOf("undefined") !== -1 ? `:not([${attributeName}])` : value2 ? `[${attributeName}="${value2}"]` : `[${attributeName}]`).join("")}`;
  }
  function getSelectorSpecificity({ attributes = [] }) {
    return attributes.length;
  }
  function bySelectorSpecificity({ specificity: leftSpecificity }, { specificity: rightSpecificity }) {
    return rightSpecificity - leftSpecificity;
  }
  function match(element) {
    let { attributes = [] } = element, typeTextIndex = attributes.findIndex((attribute) => attribute.value && attribute.name === "type" && attribute.value === "text");
    typeTextIndex >= 0 && (attributes = [...attributes.slice(0, typeTextIndex), ...attributes.slice(typeTextIndex + 1)]);
    let selector = makeElementSelector({ ...element, attributes });
    return (node) => typeTextIndex >= 0 && node.type !== "text" ? false : node.matches(selector);
  }
  let result2 = [];
  for (let [element, roles3] of elementRolesMap.entries()) result2 = [...result2, { match: match(element), roles: Array.from(roles3), specificity: getSelectorSpecificity(element) }];
  return result2.sort(bySelectorSpecificity);
}
function toHaveAccessibleName(htmlElement, expectedAccessibleName) {
  checkHtmlElement(htmlElement, toHaveAccessibleName, this);
  let actualAccessibleName = computeAccessibleName(htmlElement), missingExpectedValue = arguments.length === 1, pass = false;
  return missingExpectedValue ? pass = actualAccessibleName !== "" : pass = expectedAccessibleName instanceof RegExp ? expectedAccessibleName.test(actualAccessibleName) : this.equals(actualAccessibleName, expectedAccessibleName), { pass, message: () => {
    let to3 = this.isNot ? "not to" : "to";
    return getMessage3(this, this.utils.matcherHint(`${this.isNot ? ".not" : ""}.${toHaveAccessibleName.name}`, "element", ""), `Expected element ${to3} have accessible name`, expectedAccessibleName, "Received", actualAccessibleName);
  } };
}
function printAttribute(stringify22, name2, value2) {
  return value2 === void 0 ? name2 : `${name2}=${stringify22(value2)}`;
}
function getAttributeComment(stringify22, name2, value2) {
  return value2 === void 0 ? `element.hasAttribute(${stringify22(name2)})` : `element.getAttribute(${stringify22(name2)}) === ${stringify22(value2)}`;
}
function toHaveAttribute(htmlElement, name2, expectedValue) {
  checkHtmlElement(htmlElement, toHaveAttribute, this);
  let isExpectedValuePresent = expectedValue !== void 0, hasAttribute = htmlElement.hasAttribute(name2), receivedValue = htmlElement.getAttribute(name2);
  return { pass: isExpectedValuePresent ? hasAttribute && this.equals(receivedValue, expectedValue) : hasAttribute, message: () => {
    let to3 = this.isNot ? "not to" : "to", receivedAttribute = hasAttribute ? printAttribute(this.utils.stringify, name2, receivedValue) : null, matcher = this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toHaveAttribute`, "element", this.utils.printExpected(name2), { secondArgument: isExpectedValuePresent ? this.utils.printExpected(expectedValue) : void 0, comment: getAttributeComment(this.utils.stringify, name2, expectedValue) });
    return getMessage3(this, matcher, `Expected the element ${to3} have attribute`, printAttribute(this.utils.stringify, name2, expectedValue), "Received", receivedAttribute);
  } };
}
function getExpectedClassNamesAndOptions(params) {
  let lastParam = params.pop(), expectedClassNames, options2;
  return typeof lastParam == "object" && !(lastParam instanceof RegExp) ? (expectedClassNames = params, options2 = lastParam) : (expectedClassNames = params.concat(lastParam), options2 = { exact: false }), { expectedClassNames, options: options2 };
}
function splitClassNames(str) {
  return str ? str.split(/\s+/).filter((s4) => s4.length > 0) : [];
}
function isSubset$1(subset, superset) {
  return subset.every((strOrRegexp) => typeof strOrRegexp == "string" ? superset.includes(strOrRegexp) : superset.some((className) => strOrRegexp.test(className)));
}
function toHaveClass(htmlElement, ...params) {
  checkHtmlElement(htmlElement, toHaveClass, this);
  let { expectedClassNames, options: options2 } = getExpectedClassNamesAndOptions(params), received = splitClassNames(htmlElement.getAttribute("class")), expected = expectedClassNames.reduce((acc, className) => acc.concat(typeof className == "string" || !className ? splitClassNames(className) : className), []), hasRegExp = expected.some((className) => className instanceof RegExp);
  if (options2.exact && hasRegExp) throw new Error("Exact option does not support RegExp expected class names");
  return options2.exact ? { pass: isSubset$1(expected, received) && expected.length === received.length, message: () => {
    let to3 = this.isNot ? "not to" : "to";
    return getMessage3(this, this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toHaveClass`, "element", this.utils.printExpected(expected.join(" "))), `Expected the element ${to3} have EXACTLY defined classes`, expected.join(" "), "Received", received.join(" "));
  } } : expected.length > 0 ? { pass: isSubset$1(expected, received), message: () => {
    let to3 = this.isNot ? "not to" : "to";
    return getMessage3(this, this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toHaveClass`, "element", this.utils.printExpected(expected.join(" "))), `Expected the element ${to3} have class`, expected.join(" "), "Received", received.join(" "));
  } } : { pass: this.isNot ? received.length > 0 : false, message: () => this.isNot ? getMessage3(this, this.utils.matcherHint(".not.toHaveClass", "element", ""), "Expected the element to have classes", "(none)", "Received", received.join(" ")) : [this.utils.matcherHint(".toHaveClass", "element"), "At least one expected class must be provided."].join(`
`) };
}
function getStyleDeclaration(document2, css) {
  let styles3 = {}, copy3 = document2.createElement("div");
  return Object.keys(css).forEach((property) => {
    copy3.style[property] = css[property], styles3[property] = copy3.style[property];
  }), styles3;
}
function isSubset(styles3, computedStyle) {
  return !!Object.keys(styles3).length && Object.entries(styles3).every(([prop, value2]) => {
    let isCustomProperty = prop.startsWith("--"), spellingVariants = [prop];
    return isCustomProperty || spellingVariants.push(prop.toLowerCase()), spellingVariants.some((name2) => computedStyle[name2] === value2 || computedStyle.getPropertyValue(name2) === value2);
  });
}
function printoutStyles(styles3) {
  return Object.keys(styles3).sort().map((prop) => `${prop}: ${styles3[prop]};`).join(`
`);
}
function expectedDiff(diffFn, expected, computedStyles) {
  let received = Array.from(computedStyles).filter((prop) => expected[prop] !== void 0).reduce((obj, prop) => Object.assign(obj, { [prop]: computedStyles.getPropertyValue(prop) }), {});
  return diffFn(printoutStyles(expected), printoutStyles(received)).replace(`${import_chalk.default.red("+ Received")}
`, "");
}
function toHaveStyle(htmlElement, css) {
  checkHtmlElement(htmlElement, toHaveStyle, this);
  let parsedCSS = typeof css == "object" ? css : parseCSS(css, toHaveStyle, this), { getComputedStyle } = htmlElement.ownerDocument.defaultView, expected = getStyleDeclaration(htmlElement.ownerDocument, parsedCSS), received = getComputedStyle(htmlElement);
  return { pass: isSubset(expected, received), message: () => {
    let matcher = `${this.isNot ? ".not" : ""}.toHaveStyle`;
    return [this.utils.matcherHint(matcher, "element", ""), expectedDiff(this.utils.diff, expected, received)].join(`

`);
  } };
}
function toHaveFocus(element) {
  return checkHtmlElement(element, toHaveFocus, this), { pass: element.ownerDocument.activeElement === element, message: () => [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toHaveFocus`, "element", ""), "", ...this.isNot ? ["Received element is focused:", `  ${this.utils.printReceived(element)}`] : ["Expected element with focus:", `  ${this.utils.printExpected(element)}`, "Received element with focus:", `  ${this.utils.printReceived(element.ownerDocument.activeElement)}`]].join(`
`) };
}
function getMultiElementValue(elements) {
  let types = [...new Set(elements.map((element) => element.type))];
  if (types.length !== 1) throw new Error("Multiple form elements with the same name must be of the same type");
  switch (types[0]) {
    case "radio": {
      let theChosenOne = elements.find((radio) => radio.checked);
      return theChosenOne ? theChosenOne.value : void 0;
    }
    case "checkbox":
      return elements.filter((checkbox) => checkbox.checked).map((checkbox) => checkbox.value);
    default:
      return elements.map((element) => element.value);
  }
}
function getFormValue(container, name2) {
  let elements = [...container.querySelectorAll(`[name="${(0, import_css.default)(name2)}"]`)];
  if (elements.length !== 0) switch (elements.length) {
    case 1:
      return getSingleElementValue(elements[0]);
    default:
      return getMultiElementValue(elements);
  }
}
function getPureName(name2) {
  return /\[\]$/.test(name2) ? name2.slice(0, -2) : name2;
}
function getAllFormValues(container) {
  return Array.from(container.elements).map((element) => element.name).reduce((obj, name2) => ({ ...obj, [getPureName(name2)]: getFormValue(container, name2) }), {});
}
function toHaveFormValues(formElement, expectedValues) {
  if (checkHtmlElement(formElement, toHaveFormValues, this), !formElement.elements) throw new Error("toHaveFormValues must be called on a form or a fieldset");
  let formValues = getAllFormValues(formElement);
  return { pass: Object.entries(expectedValues).every(([name2, expectedValue]) => (0, import_isEqualWith.default)(formValues[name2], expectedValue, compareArraysAsSet)), message: () => {
    let to3 = this.isNot ? "not to" : "to", matcher = `${this.isNot ? ".not" : ""}.toHaveFormValues`, commonKeyValues = Object.keys(formValues).filter((key2) => expectedValues.hasOwnProperty(key2)).reduce((obj, key2) => ({ ...obj, [key2]: formValues[key2] }), {});
    return [this.utils.matcherHint(matcher, "element", ""), `Expected the element ${to3} have form values`, this.utils.diff(expectedValues, commonKeyValues)].join(`

`);
  } };
}
function isStyleVisible(element) {
  let { getComputedStyle } = element.ownerDocument.defaultView, { display: display2, visibility, opacity } = getComputedStyle(element);
  return display2 !== "none" && visibility !== "hidden" && visibility !== "collapse" && opacity !== "0" && opacity !== 0;
}
function isAttributeVisible(element, previousElement) {
  let detailsVisibility;
  return previousElement ? detailsVisibility = element.nodeName === "DETAILS" && previousElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true : detailsVisibility = element.nodeName === "DETAILS" ? element.hasAttribute("open") : true, !element.hasAttribute("hidden") && detailsVisibility;
}
function isElementVisible(element, previousElement) {
  return isStyleVisible(element) && isAttributeVisible(element, previousElement) && (!element.parentElement || isElementVisible(element.parentElement, element));
}
function toBeVisible(element) {
  checkHtmlElement(element, toBeVisible, this);
  let isInDocument = element.ownerDocument === element.getRootNode({ composed: true }), isVisible2 = isInDocument && isElementVisible(element);
  return { pass: isVisible2, message: () => {
    let is2 = isVisible2 ? "is" : "is not";
    return [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toBeVisible`, "element", ""), "", `Received element ${is2} visible${isInDocument ? "" : " (element is not in the document)"}:`, `  ${this.utils.printReceived(element.cloneNode(false))}`].join(`
`);
  } };
}
var FORM_TAGS$2 = ["fieldset", "input", "select", "optgroup", "option", "button", "textarea"];
function isFirstLegendChildOfFieldset(element, parent) {
  return getTag(element) === "legend" && getTag(parent) === "fieldset" && element.isSameNode(Array.from(parent.children).find((child) => getTag(child) === "legend"));
}
function isElementDisabledByParent(element, parent) {
  return isElementDisabled(parent) && !isFirstLegendChildOfFieldset(element, parent);
}
function isCustomElement(tag) {
  return tag.includes("-");
}
function canElementBeDisabled(element) {
  let tag = getTag(element);
  return FORM_TAGS$2.includes(tag) || isCustomElement(tag);
}
function isElementDisabled(element) {
  return canElementBeDisabled(element) && element.hasAttribute("disabled");
}
function isAncestorDisabled(element) {
  let parent = element.parentElement;
  return !!parent && (isElementDisabledByParent(element, parent) || isAncestorDisabled(parent));
}
function isElementOrAncestorDisabled(element) {
  return canElementBeDisabled(element) && (isElementDisabled(element) || isAncestorDisabled(element));
}
function toBeDisabled(element) {
  checkHtmlElement(element, toBeDisabled, this);
  let isDisabled3 = isElementOrAncestorDisabled(element);
  return { pass: isDisabled3, message: () => {
    let is2 = isDisabled3 ? "is" : "is not";
    return [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toBeDisabled`, "element", ""), "", `Received element ${is2} disabled:`, `  ${this.utils.printReceived(element.cloneNode(false))}`].join(`
`);
  } };
}
function toBeEnabled(element) {
  checkHtmlElement(element, toBeEnabled, this);
  let isEnabled = !isElementOrAncestorDisabled(element);
  return { pass: isEnabled, message: () => {
    let is2 = isEnabled ? "is" : "is not";
    return [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toBeEnabled`, "element", ""), "", `Received element ${is2} enabled:`, `  ${this.utils.printReceived(element.cloneNode(false))}`].join(`
`);
  } };
}
var FORM_TAGS$1 = ["select", "textarea"];
var ARIA_FORM_TAGS = ["input", "select", "textarea"];
var UNSUPPORTED_INPUT_TYPES = ["color", "hidden", "range", "submit", "image", "reset"];
var SUPPORTED_ARIA_ROLES = ["checkbox", "combobox", "gridcell", "listbox", "radiogroup", "spinbutton", "textbox", "tree"];
function isRequiredOnFormTagsExceptInput(element) {
  return FORM_TAGS$1.includes(getTag(element)) && element.hasAttribute("required");
}
function isRequiredOnSupportedInput(element) {
  return getTag(element) === "input" && element.hasAttribute("required") && (element.hasAttribute("type") && !UNSUPPORTED_INPUT_TYPES.includes(element.getAttribute("type")) || !element.hasAttribute("type"));
}
function isElementRequiredByARIA(element) {
  return element.hasAttribute("aria-required") && element.getAttribute("aria-required") === "true" && (ARIA_FORM_TAGS.includes(getTag(element)) || element.hasAttribute("role") && SUPPORTED_ARIA_ROLES.includes(element.getAttribute("role")));
}
function toBeRequired(element) {
  checkHtmlElement(element, toBeRequired, this);
  let isRequired = isRequiredOnFormTagsExceptInput(element) || isRequiredOnSupportedInput(element) || isElementRequiredByARIA(element);
  return { pass: isRequired, message: () => {
    let is2 = isRequired ? "is" : "is not";
    return [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toBeRequired`, "element", ""), "", `Received element ${is2} required:`, `  ${this.utils.printReceived(element.cloneNode(false))}`].join(`
`);
  } };
}
var FORM_TAGS = ["form", "input", "select", "textarea"];
function isElementHavingAriaInvalid(element) {
  return element.hasAttribute("aria-invalid") && element.getAttribute("aria-invalid") !== "false";
}
function isSupportsValidityMethod(element) {
  return FORM_TAGS.includes(getTag(element));
}
function isElementInvalid(element) {
  let isHaveAriaInvalid = isElementHavingAriaInvalid(element);
  return isSupportsValidityMethod(element) ? isHaveAriaInvalid || !element.checkValidity() : isHaveAriaInvalid;
}
function toBeInvalid(element) {
  checkHtmlElement(element, toBeInvalid, this);
  let isInvalid = isElementInvalid(element);
  return { pass: isInvalid, message: () => {
    let is2 = isInvalid ? "is" : "is not";
    return [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toBeInvalid`, "element", ""), "", `Received element ${is2} currently invalid:`, `  ${this.utils.printReceived(element.cloneNode(false))}`].join(`
`);
  } };
}
function toBeValid(element) {
  checkHtmlElement(element, toBeValid, this);
  let isValid = !isElementInvalid(element);
  return { pass: isValid, message: () => {
    let is2 = isValid ? "is" : "is not";
    return [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toBeValid`, "element", ""), "", `Received element ${is2} currently valid:`, `  ${this.utils.printReceived(element.cloneNode(false))}`].join(`
`);
  } };
}
function toHaveValue(htmlElement, expectedValue) {
  if (checkHtmlElement(htmlElement, toHaveValue, this), htmlElement.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(htmlElement.type)) throw new Error("input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead");
  let receivedValue = getSingleElementValue(htmlElement), expectsValue = expectedValue !== void 0, expectedTypedValue = expectedValue, receivedTypedValue = receivedValue;
  return expectedValue == receivedValue && expectedValue !== receivedValue && (expectedTypedValue = `${expectedValue} (${typeof expectedValue})`, receivedTypedValue = `${receivedValue} (${typeof receivedValue})`), { pass: expectsValue ? (0, import_isEqualWith.default)(receivedValue, expectedValue, compareArraysAsSet) : !!receivedValue, message: () => {
    let to3 = this.isNot ? "not to" : "to", matcher = this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toHaveValue`, "element", expectedValue);
    return getMessage3(this, matcher, `Expected the element ${to3} have value`, expectsValue ? expectedTypedValue : "(any)", "Received", receivedTypedValue);
  } };
}
function toHaveDisplayValue(htmlElement, expectedValue) {
  checkHtmlElement(htmlElement, toHaveDisplayValue, this);
  let tagName = htmlElement.tagName.toLowerCase();
  if (!["select", "input", "textarea"].includes(tagName)) throw new Error(".toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead.");
  if (tagName === "input" && ["radio", "checkbox"].includes(htmlElement.type)) throw new Error(`.toHaveDisplayValue() currently does not support input[type="${htmlElement.type}"], try with another matcher instead.`);
  let values = getValues(tagName, htmlElement), expectedValues = getExpectedValues(expectedValue), numberOfMatchesWithValues = expectedValues.filter((expected) => values.some((value2) => expected instanceof RegExp ? expected.test(value2) : this.equals(value2, String(expected)))).length, matchedWithAllValues = numberOfMatchesWithValues === values.length, matchedWithAllExpectedValues = numberOfMatchesWithValues === expectedValues.length;
  return { pass: matchedWithAllValues && matchedWithAllExpectedValues, message: () => getMessage3(this, this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toHaveDisplayValue`, "element", ""), `Expected element ${this.isNot ? "not " : ""}to have display value`, expectedValue, "Received", values) };
}
function getValues(tagName, htmlElement) {
  return tagName === "select" ? Array.from(htmlElement).filter((option) => option.selected).map((option) => option.textContent) : [htmlElement.value];
}
function getExpectedValues(expectedValue) {
  return expectedValue instanceof Array ? expectedValue : [expectedValue];
}
function toBeChecked(element) {
  checkHtmlElement(element, toBeChecked, this);
  let isValidInput = () => element.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(element.type), isValidAriaElement = () => roleSupportsChecked(element.getAttribute("role")) && ["true", "false"].includes(element.getAttribute("aria-checked"));
  if (!isValidInput() && !isValidAriaElement()) return { pass: false, message: () => `only inputs with type="checkbox" or type="radio" or elements with ${supportedRolesSentence()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead` };
  let isChecked = () => isValidInput() ? element.checked : element.getAttribute("aria-checked") === "true";
  return { pass: isChecked(), message: () => {
    let is2 = isChecked() ? "is" : "is not";
    return [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toBeChecked`, "element", ""), "", `Received element ${is2} checked:`, `  ${this.utils.printReceived(element.cloneNode(false))}`].join(`
`);
  } };
}
function supportedRolesSentence() {
  return toSentence(supportedRoles().map((role) => `role="${role}"`), { lastWordConnector: " or " });
}
function supportedRoles() {
  return import_aria_query.roles.keys().filter(roleSupportsChecked);
}
function roleSupportsChecked(role) {
  var _a2;
  return ((_a2 = import_aria_query.roles.get(role)) == null ? void 0 : _a2.props["aria-checked"]) !== void 0;
}
function toBePartiallyChecked(element) {
  checkHtmlElement(element, toBePartiallyChecked, this);
  let isValidInput = () => element.tagName.toLowerCase() === "input" && element.type === "checkbox", isValidAriaElement = () => element.getAttribute("role") === "checkbox";
  if (!isValidInput() && !isValidAriaElement()) return { pass: false, message: () => 'only inputs with type="checkbox" or elements with role="checkbox" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead' };
  let isPartiallyChecked = () => {
    let isAriaMixed = element.getAttribute("aria-checked") === "mixed";
    return isValidInput() && element.indeterminate || isAriaMixed;
  };
  return { pass: isPartiallyChecked(), message: () => {
    let is2 = isPartiallyChecked() ? "is" : "is not";
    return [this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toBePartiallyChecked`, "element", ""), "", `Received element ${is2} partially checked:`, `  ${this.utils.printReceived(element.cloneNode(false))}`].join(`
`);
  } };
}
function toHaveDescription(htmlElement, checkWith) {
  deprecate("toHaveDescription", "Please use toHaveAccessibleDescription."), checkHtmlElement(htmlElement, toHaveDescription, this);
  let expectsDescription = checkWith !== void 0, descriptionIDs = (htmlElement.getAttribute("aria-describedby") || "").split(/\s+/).filter(Boolean), description = "";
  if (descriptionIDs.length > 0) {
    let document2 = htmlElement.ownerDocument, descriptionEls = descriptionIDs.map((descriptionID) => document2.getElementById(descriptionID)).filter(Boolean);
    description = normalize(descriptionEls.map((el) => el.textContent).join(" "));
  }
  return { pass: expectsDescription ? checkWith instanceof RegExp ? checkWith.test(description) : this.equals(description, checkWith) : !!description, message: () => {
    let to3 = this.isNot ? "not to" : "to";
    return getMessage3(this, this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toHaveDescription`, "element", ""), `Expected the element ${to3} have description`, this.utils.printExpected(checkWith), "Received", this.utils.printReceived(description));
  } };
}
function toHaveErrorMessage(htmlElement, checkWith) {
  if (deprecate("toHaveErrorMessage", "Please use toHaveAccessibleErrorMessage."), checkHtmlElement(htmlElement, toHaveErrorMessage, this), !htmlElement.hasAttribute("aria-invalid") || htmlElement.getAttribute("aria-invalid") === "false") {
    let not = this.isNot ? ".not" : "";
    return { pass: false, message: () => getMessage3(this, this.utils.matcherHint(`${not}.toHaveErrorMessage`, "element", ""), "Expected the element to have invalid state indicated by", 'aria-invalid="true"', "Received", htmlElement.hasAttribute("aria-invalid") ? `aria-invalid="${htmlElement.getAttribute("aria-invalid")}"` : this.utils.printReceived("")) };
  }
  let expectsErrorMessage = checkWith !== void 0, errormessageIDs = (htmlElement.getAttribute("aria-errormessage") || "").split(/\s+/).filter(Boolean), errormessage = "";
  if (errormessageIDs.length > 0) {
    let document2 = htmlElement.ownerDocument, errormessageEls = errormessageIDs.map((errormessageID) => document2.getElementById(errormessageID)).filter(Boolean);
    errormessage = normalize(errormessageEls.map((el) => el.textContent).join(" "));
  }
  return { pass: expectsErrorMessage ? checkWith instanceof RegExp ? checkWith.test(errormessage) : this.equals(errormessage, checkWith) : !!errormessage, message: () => {
    let to3 = this.isNot ? "not to" : "to";
    return getMessage3(this, this.utils.matcherHint(`${this.isNot ? ".not" : ""}.toHaveErrorMessage`, "element", ""), `Expected the element ${to3} have error message`, this.utils.printExpected(checkWith), "Received", this.utils.printReceived(errormessage));
  } };
}
__toESM(require_redent(), 1);
__toESM(require_lib(), 1);
__toESM(require_source(), 1);
__toESM(require_isEqualWith(), 1);
__toESM(require_css_escape(), 1);
function assertTypes(value2, name2, types) {
  let receivedType = typeof value2;
  if (!types.includes(receivedType)) throw new TypeError(`${name2} value must be ${types.join(" or ")}, received "${receivedType}"`);
}
function isObject2(item) {
  return item != null && typeof item == "object" && !Array.isArray(item);
}
function isFinalObj2(obj) {
  return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
}
function getType4(value2) {
  return Object.prototype.toString.apply(value2).slice(8, -1);
}
function collectOwnProperties2(obj, collector) {
  let collect = typeof collector == "function" ? collector : (key2) => collector.add(key2);
  Object.getOwnPropertyNames(obj).forEach(collect), Object.getOwnPropertySymbols(obj).forEach(collect);
}
function getOwnProperties2(obj) {
  let ownProps = /* @__PURE__ */ new Set();
  return isFinalObj2(obj) ? [] : (collectOwnProperties2(obj, ownProps), Array.from(ownProps));
}
var defaultCloneOptions2 = { forceWritable: false };
function deepClone2(val, options2 = defaultCloneOptions2) {
  return clone2(val, /* @__PURE__ */ new WeakMap(), options2);
}
function clone2(val, seen, options2 = defaultCloneOptions2) {
  let k22, out;
  if (seen.has(val)) return seen.get(val);
  if (Array.isArray(val)) {
    for (out = Array(k22 = val.length), seen.set(val, out); k22--; ) out[k22] = clone2(val[k22], seen, options2);
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = Object.create(Object.getPrototypeOf(val)), seen.set(val, out);
    let props = getOwnProperties2(val);
    for (let k222 of props) {
      let descriptor = Object.getOwnPropertyDescriptor(val, k222);
      if (!descriptor) continue;
      let cloned = clone2(val[k222], seen, options2);
      options2.forceWritable ? Object.defineProperty(out, k222, { enumerable: descriptor.enumerable, configurable: true, writable: true, value: cloned }) : "get" in descriptor ? Object.defineProperty(out, k222, { ...descriptor, get() {
        return cloned;
      } }) : Object.defineProperty(out, k222, { ...descriptor, value: cloned });
    }
    return out;
  }
  return val;
}
var ansiColors22 = { bold: ["1", "22"], dim: ["2", "22"], italic: ["3", "23"], underline: ["4", "24"], inverse: ["7", "27"], hidden: ["8", "28"], strike: ["9", "29"], black: ["30", "39"], red: ["31", "39"], green: ["32", "39"], yellow: ["33", "39"], blue: ["34", "39"], magenta: ["35", "39"], cyan: ["36", "39"], white: ["37", "39"], brightblack: ["30;1", "39"], brightred: ["31;1", "39"], brightgreen: ["32;1", "39"], brightyellow: ["33;1", "39"], brightblue: ["34;1", "39"], brightmagenta: ["35;1", "39"], brightcyan: ["36;1", "39"], brightwhite: ["37;1", "39"], grey: ["90", "39"] };
var styles22 = { special: "cyan", number: "yellow", bigint: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", symbol: "green", date: "magenta", regexp: "red" };
var truncator22 = "";
function colorise22(value2, styleType) {
  let color = ansiColors22[styles22[styleType]] || ansiColors22[styleType] || "";
  return color ? `\x1B[${color[0]}m${String(value2)}\x1B[${color[1]}m` : String(value2);
}
function normaliseOptions22({ showHidden = false, depth = 2, colors = false, customInspect = true, showProxy = false, maxArrayLength = 1 / 0, breakLength = 1 / 0, seen = [], truncate: truncate3 = 1 / 0, stylize = String } = {}, inspect5) {
  let options2 = { showHidden: !!showHidden, depth: Number(depth), colors: !!colors, customInspect: !!customInspect, showProxy: !!showProxy, maxArrayLength: Number(maxArrayLength), breakLength: Number(breakLength), truncate: Number(truncate3), seen, inspect: inspect5, stylize };
  return options2.colors && (options2.stylize = colorise22), options2;
}
function isHighSurrogate2(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
function truncate22(string, length, tail = truncator22) {
  string = String(string);
  let tailLength = tail.length, stringLength = string.length;
  if (tailLength > length && stringLength > tailLength) return tail;
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    return end > 0 && isHighSurrogate2(string[end - 1]) && (end = end - 1), `${string.slice(0, end)}${tail}`;
  }
  return string;
}
function inspectList22(list, options2, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options2.inspect;
  let size = list.length;
  if (size === 0) return "";
  let originalLength = options2.truncate, output = "", peek = "", truncated = "";
  for (let i4 = 0; i4 < size; i4 += 1) {
    let last = i4 + 1 === list.length, secondToLast = i4 + 2 === list.length;
    truncated = `${truncator22}(${list.length - i4})`;
    let value2 = list[i4];
    options2.truncate = originalLength - output.length - (last ? 0 : separator.length);
    let string = peek || inspectItem(value2, options2) + (last ? "" : separator), nextLength = output.length + string.length, truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength || !last && !secondToLast && truncatedLength > originalLength || (peek = last ? "" : inspectItem(list[i4 + 1], options2) + (secondToLast ? "" : separator), !last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength)) break;
    if (output += string, !last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator22}(${list.length - i4 - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
function quoteComplexKey22(key2) {
  return key2.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? key2 : JSON.stringify(key2).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
function inspectProperty22([key2, value2], options2) {
  return options2.truncate -= 2, typeof key2 == "string" ? key2 = quoteComplexKey22(key2) : typeof key2 != "number" && (key2 = `[${options2.inspect(key2, options2)}]`), options2.truncate -= key2.length, value2 = options2.inspect(value2, options2), `${key2}: ${value2}`;
}
function inspectArray22(array, options2) {
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length) return "[]";
  options2.truncate -= 4;
  let listContents = inspectList22(array, options2);
  options2.truncate -= listContents.length;
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList22(nonIndexProperties.map((key2) => [key2, array[key2]]), options2, inspectProperty22)), `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
var getArrayName22 = (array) => typeof Buffer == "function" && array instanceof Buffer ? "Buffer" : array[Symbol.toStringTag] ? array[Symbol.toStringTag] : array.constructor.name;
function inspectTypedArray22(array, options2) {
  let name2 = getArrayName22(array);
  options2.truncate -= name2.length + 4;
  let nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length) return `${name2}[]`;
  let output = "";
  for (let i4 = 0; i4 < array.length; i4++) {
    let string = `${options2.stylize(truncate22(array[i4], options2.truncate), "number")}${i4 === array.length - 1 ? "" : ", "}`;
    if (options2.truncate -= string.length, array[i4] !== array.length && options2.truncate <= 3) {
      output += `${truncator22}(${array.length - array[i4] + 1})`;
      break;
    }
    output += string;
  }
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList22(nonIndexProperties.map((key2) => [key2, array[key2]]), options2, inspectProperty22)), `${name2}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
function inspectDate22(dateObject, options2) {
  let stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null) return "Invalid Date";
  let split = stringRepresentation.split("T"), date = split[0];
  return options2.stylize(`${date}T${truncate22(split[1], options2.truncate - date.length - 1)}`, "date");
}
function inspectFunction22(func, options2) {
  let functionType = func[Symbol.toStringTag] || "Function", name2 = func.name;
  return name2 ? options2.stylize(`[${functionType} ${truncate22(name2, options2.truncate - 11)}]`, "special") : options2.stylize(`[${functionType}]`, "special");
}
function inspectMapEntry22([key2, value2], options2) {
  return options2.truncate -= 4, key2 = options2.inspect(key2, options2), options2.truncate -= key2.length, value2 = options2.inspect(value2, options2), `${key2} => ${value2}`;
}
function mapToEntries22(map) {
  let entries = [];
  return map.forEach((value2, key2) => {
    entries.push([key2, value2]);
  }), entries;
}
function inspectMap22(map, options2) {
  return map.size - 1 <= 0 ? "Map{}" : (options2.truncate -= 7, `Map{ ${inspectList22(mapToEntries22(map), options2, inspectMapEntry22)} }`);
}
var isNaN3 = Number.isNaN || ((i4) => i4 !== i4);
function inspectNumber22(number, options2) {
  return isNaN3(number) ? options2.stylize("NaN", "number") : number === 1 / 0 ? options2.stylize("Infinity", "number") : number === -1 / 0 ? options2.stylize("-Infinity", "number") : number === 0 ? options2.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number") : options2.stylize(truncate22(String(number), options2.truncate), "number");
}
function inspectBigInt22(number, options2) {
  let nums = truncate22(number.toString(), options2.truncate - 1);
  return nums !== truncator22 && (nums += "n"), options2.stylize(nums, "bigint");
}
function inspectRegExp22(value2, options2) {
  let flags = value2.toString().split("/")[2], sourceLength = options2.truncate - (2 + flags.length), source2 = value2.source;
  return options2.stylize(`/${truncate22(source2, sourceLength)}/${flags}`, "regexp");
}
function arrayFromSet22(set2) {
  let values = [];
  return set2.forEach((value2) => {
    values.push(value2);
  }), values;
}
function inspectSet22(set2, options2) {
  return set2.size === 0 ? "Set{}" : (options2.truncate -= 7, `Set{ ${inspectList22(arrayFromSet22(set2), options2)} }`);
}
var stringEscapeChars22 = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var escapeCharacters22 = { "\b": "\\b", "	": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", "'": "\\'", "\\": "\\\\" };
var hex22 = 16;
var unicodeLength22 = 4;
function escape3(char) {
  return escapeCharacters22[char] || `\\u${`0000${char.charCodeAt(0).toString(hex22)}`.slice(-unicodeLength22)}`;
}
function inspectString22(string, options2) {
  return stringEscapeChars22.test(string) && (string = string.replace(stringEscapeChars22, escape3)), options2.stylize(`'${truncate22(string, options2.truncate - 2)}'`, "string");
}
function inspectSymbol22(value2) {
  return "description" in Symbol.prototype ? value2.description ? `Symbol(${value2.description})` : "Symbol()" : value2.toString();
}
var getPromiseValue22 = () => "Promise{}";
try {
  let { getPromiseDetails, kPending, kRejected } = process.binding("util");
  Array.isArray(getPromiseDetails(Promise.resolve())) && (getPromiseValue22 = (value2, options2) => {
    let [state, innerValue] = getPromiseDetails(value2);
    return state === kPending ? "Promise{<pending>}" : `Promise${state === kRejected ? "!" : ""}{${options2.inspect(innerValue, options2)}}`;
  });
} catch {
}
var promise_default22 = getPromiseValue22;
function inspectObject32(object, options2) {
  let properties = Object.getOwnPropertyNames(object), symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
  if (properties.length === 0 && symbols.length === 0) return "{}";
  if (options2.truncate -= 4, options2.seen = options2.seen || [], options2.seen.indexOf(object) >= 0) return "[Circular]";
  options2.seen.push(object);
  let propertyContents = inspectList22(properties.map((key2) => [key2, object[key2]]), options2, inspectProperty22), symbolContents = inspectList22(symbols.map((key2) => [key2, object[key2]]), options2, inspectProperty22);
  options2.seen.pop();
  let sep = "";
  return propertyContents && symbolContents && (sep = ", "), `{ ${propertyContents}${sep}${symbolContents} }`;
}
var toStringTag22 = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass22(value2, options2) {
  let name2 = "";
  return toStringTag22 && toStringTag22 in value2 && (name2 = value2[toStringTag22]), name2 = name2 || value2.constructor.name, (!name2 || name2 === "_class") && (name2 = "<Anonymous Class>"), options2.truncate -= name2.length, `${name2}${inspectObject32(value2, options2)}`;
}
function inspectArguments22(args2, options2) {
  return args2.length === 0 ? "Arguments[]" : (options2.truncate -= 13, `Arguments[ ${inspectList22(args2, options2)} ]`);
}
var errorKeys22 = ["stack", "line", "column", "name", "message", "fileName", "lineNumber", "columnNumber", "number", "description"];
function inspectObject4(error, options2) {
  let properties = Object.getOwnPropertyNames(error).filter((key2) => errorKeys22.indexOf(key2) === -1), name2 = error.name;
  options2.truncate -= name2.length;
  let message = "";
  typeof error.message == "string" ? message = truncate22(error.message, options2.truncate) : properties.unshift("message"), message = message ? `: ${message}` : "", options2.truncate -= message.length + 5;
  let propertyContents = inspectList22(properties.map((key2) => [key2, error[key2]]), options2, inspectProperty22);
  return `${name2}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
function inspectAttribute22([key2, value2], options2) {
  return options2.truncate -= 3, value2 ? `${options2.stylize(String(key2), "yellow")}=${options2.stylize(`"${value2}"`, "string")}` : `${options2.stylize(String(key2), "yellow")}`;
}
function inspectHTMLCollection22(collection, options2) {
  return inspectList22(collection, options2, inspectHTML22, `
`);
}
function inspectHTML22(element, options2) {
  let properties = element.getAttributeNames(), name2 = element.tagName.toLowerCase(), head = options2.stylize(`<${name2}`, "special"), headClose = options2.stylize(">", "special"), tail = options2.stylize(`</${name2}>`, "special");
  options2.truncate -= name2.length * 2 + 5;
  let propertyContents = "";
  properties.length > 0 && (propertyContents += " ", propertyContents += inspectList22(properties.map((key2) => [key2, element.getAttribute(key2)]), options2, inspectAttribute22, " ")), options2.truncate -= propertyContents.length;
  let truncate3 = options2.truncate, children = inspectHTMLCollection22(element.children, options2);
  return children && children.length > truncate3 && (children = `${truncator22}(${element.children.length})`), `${head}${propertyContents}${headClose}${children}${tail}`;
}
var symbolsSupported22 = typeof Symbol == "function" && typeof Symbol.for == "function";
var chaiInspect22 = symbolsSupported22 ? Symbol.for("chai/inspect") : "@@chai/inspect";
var nodeInspect22 = false;
try {
  let nodeUtil = __require3("util");
  nodeInspect22 = nodeUtil.inspect ? nodeUtil.inspect.custom : false;
} catch {
  nodeInspect22 = false;
}
var constructorMap22 = /* @__PURE__ */ new WeakMap();
var stringTagMap22 = {};
var baseTypesMap22 = { undefined: (value2, options2) => options2.stylize("undefined", "undefined"), null: (value2, options2) => options2.stylize("null", "null"), boolean: (value2, options2) => options2.stylize(String(value2), "boolean"), Boolean: (value2, options2) => options2.stylize(String(value2), "boolean"), number: inspectNumber22, Number: inspectNumber22, bigint: inspectBigInt22, BigInt: inspectBigInt22, string: inspectString22, String: inspectString22, function: inspectFunction22, Function: inspectFunction22, symbol: inspectSymbol22, Symbol: inspectSymbol22, Array: inspectArray22, Date: inspectDate22, Map: inspectMap22, Set: inspectSet22, RegExp: inspectRegExp22, Promise: promise_default22, WeakSet: (value2, options2) => options2.stylize("WeakSet{}", "special"), WeakMap: (value2, options2) => options2.stylize("WeakMap{}", "special"), Arguments: inspectArguments22, Int8Array: inspectTypedArray22, Uint8Array: inspectTypedArray22, Uint8ClampedArray: inspectTypedArray22, Int16Array: inspectTypedArray22, Uint16Array: inspectTypedArray22, Int32Array: inspectTypedArray22, Uint32Array: inspectTypedArray22, Float32Array: inspectTypedArray22, Float64Array: inspectTypedArray22, Generator: () => "", DataView: () => "", ArrayBuffer: () => "", Error: inspectObject4, HTMLCollection: inspectHTMLCollection22, NodeList: inspectHTMLCollection22 };
var inspectCustom22 = (value2, options2, type5) => chaiInspect22 in value2 && typeof value2[chaiInspect22] == "function" ? value2[chaiInspect22](options2) : nodeInspect22 && nodeInspect22 in value2 && typeof value2[nodeInspect22] == "function" ? value2[nodeInspect22](options2.depth, options2) : "inspect" in value2 && typeof value2.inspect == "function" ? value2.inspect(options2.depth, options2) : "constructor" in value2 && constructorMap22.has(value2.constructor) ? constructorMap22.get(value2.constructor)(value2, options2) : stringTagMap22[type5] ? stringTagMap22[type5](value2, options2) : "";
var toString22 = Object.prototype.toString;
function inspect32(value2, opts = {}) {
  let options2 = normaliseOptions22(opts, inspect32), { customInspect } = options2, type5 = value2 === null ? "null" : typeof value2;
  if (type5 === "object" && (type5 = toString22.call(value2).slice(8, -1)), type5 in baseTypesMap22) return baseTypesMap22[type5](value2, options2);
  if (customInspect && value2) {
    let output = inspectCustom22(value2, options2, type5);
    if (output) return typeof output == "string" ? output : inspect32(output, options2);
  }
  let proto = value2 ? Object.getPrototypeOf(value2) : false;
  return proto === Object.prototype || proto === null ? inspectObject32(value2, options2) : value2 && typeof HTMLElement == "function" && value2 instanceof HTMLElement ? inspectHTML22(value2, options2) : "constructor" in value2 ? value2.constructor !== Object ? inspectClass22(value2, options2) : inspectObject32(value2, options2) : value2 === Object(value2) ? inspectObject32(value2, options2) : options2.stylize(String(value2), type5);
}
var f7 = { reset: [0, 0], bold: [1, 22, "\x1B[22m\x1B[1m"], dim: [2, 22, "\x1B[22m\x1B[2m"], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29], black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] };
var h4 = Object.entries(f7);
function a4(n3) {
  return String(n3);
}
a4.open = "";
a4.close = "";
function C5(n3 = false) {
  let e2 = typeof process < "u" ? process : void 0, i4 = (e2 == null ? void 0 : e2.env) || {}, g3 = (e2 == null ? void 0 : e2.argv) || [];
  return !("NO_COLOR" in i4 || g3.includes("--no-color")) && ("FORCE_COLOR" in i4 || g3.includes("--color") || (e2 == null ? void 0 : e2.platform) === "win32" || n3 && i4.TERM !== "dumb" || "CI" in i4) || typeof window < "u" && !!window.chrome;
}
function p5(n3 = false) {
  let e2 = C5(n3), i4 = (r4, t4, c3, o3) => {
    let l3 = "", s4 = 0;
    do
      l3 += r4.substring(s4, o3) + c3, s4 = o3 + t4.length, o3 = r4.indexOf(t4, s4);
    while (~o3);
    return l3 + r4.substring(s4);
  }, g3 = (r4, t4, c3 = r4) => {
    let o3 = (l3) => {
      let s4 = String(l3), b6 = s4.indexOf(t4, r4.length);
      return ~b6 ? r4 + i4(s4, t4, c3, b6) + t4 : r4 + s4 + t4;
    };
    return o3.open = r4, o3.close = t4, o3;
  }, u22 = { isColorSupported: e2 }, d22 = (r4) => `\x1B[${r4}m`;
  for (let [r4, t4] of h4) u22[r4] = e2 ? g3(d22(t4[0]), d22(t4[1]), t4[2]) : a4;
  return u22;
}
var f23 = p5(false);
function getKeysOfEnumerableProperties2(object, compareKeys) {
  let rawKeys = Object.keys(object), keys2 = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
  if (Object.getOwnPropertySymbols) for (let symbol of Object.getOwnPropertySymbols(object)) Object.getOwnPropertyDescriptor(object, symbol).enumerable && keys2.push(symbol);
  return keys2;
}
function printIteratorEntries2(iterator, config3, indentation, depth, refs2, printer22, separator = ": ") {
  let result2 = "", width = 0, current = iterator.next();
  if (!current.done) {
    result2 += config3.spacingOuter;
    let indentationNext = indentation + config3.indent;
    for (; !current.done; ) {
      if (result2 += indentationNext, width++ === config3.maxWidth) {
        result2 += "";
        break;
      }
      let name2 = printer22(current.value[0], config3, indentationNext, depth, refs2), value2 = printer22(current.value[1], config3, indentationNext, depth, refs2);
      result2 += name2 + separator + value2, current = iterator.next(), current.done ? config3.min || (result2 += ",") : result2 += `,${config3.spacingInner}`;
    }
    result2 += config3.spacingOuter + indentation;
  }
  return result2;
}
function printIteratorValues2(iterator, config3, indentation, depth, refs2, printer22) {
  let result2 = "", width = 0, current = iterator.next();
  if (!current.done) {
    result2 += config3.spacingOuter;
    let indentationNext = indentation + config3.indent;
    for (; !current.done; ) {
      if (result2 += indentationNext, width++ === config3.maxWidth) {
        result2 += "";
        break;
      }
      result2 += printer22(current.value, config3, indentationNext, depth, refs2), current = iterator.next(), current.done ? config3.min || (result2 += ",") : result2 += `,${config3.spacingInner}`;
    }
    result2 += config3.spacingOuter + indentation;
  }
  return result2;
}
function printListItems2(list, config3, indentation, depth, refs2, printer22) {
  let result2 = "";
  list = list instanceof ArrayBuffer ? new DataView(list) : list;
  let isDataView = (l3) => l3 instanceof DataView, length = isDataView(list) ? list.byteLength : list.length;
  if (length > 0) {
    result2 += config3.spacingOuter;
    let indentationNext = indentation + config3.indent;
    for (let i4 = 0; i4 < length; i4++) {
      if (result2 += indentationNext, i4 === config3.maxWidth) {
        result2 += "";
        break;
      }
      (isDataView(list) || i4 in list) && (result2 += printer22(isDataView(list) ? list.getInt8(i4) : list[i4], config3, indentationNext, depth, refs2)), i4 < length - 1 ? result2 += `,${config3.spacingInner}` : config3.min || (result2 += ",");
    }
    result2 += config3.spacingOuter + indentation;
  }
  return result2;
}
function printObjectProperties2(val, config3, indentation, depth, refs2, printer22) {
  let result2 = "", keys2 = getKeysOfEnumerableProperties2(val, config3.compareKeys);
  if (keys2.length > 0) {
    result2 += config3.spacingOuter;
    let indentationNext = indentation + config3.indent;
    for (let i4 = 0; i4 < keys2.length; i4++) {
      let key2 = keys2[i4], name2 = printer22(key2, config3, indentationNext, depth, refs2), value2 = printer22(val[key2], config3, indentationNext, depth, refs2);
      result2 += `${indentationNext + name2}: ${value2}`, i4 < keys2.length - 1 ? result2 += `,${config3.spacingInner}` : config3.min || (result2 += ",");
    }
    result2 += config3.spacingOuter + indentation;
  }
  return result2;
}
var asymmetricMatcher2 = typeof Symbol == "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621;
var SPACE$22 = " ";
var serialize$52 = (val, config3, indentation, depth, refs2, printer22) => {
  let stringedValue = val.toString();
  if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") return ++depth > config3.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$22}[${printListItems2(val.sample, config3, indentation, depth, refs2, printer22)}]`;
  if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") return ++depth > config3.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$22}{${printObjectProperties2(val.sample, config3, indentation, depth, refs2, printer22)}}`;
  if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching" || stringedValue === "StringContaining" || stringedValue === "StringNotContaining") return stringedValue + SPACE$22 + printer22(val.sample, config3, indentation, depth, refs2);
  if (typeof val.toAsymmetricMatcher != "function") throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
  return val.toAsymmetricMatcher();
};
var test$52 = (val) => val && val.$$typeof === asymmetricMatcher2;
var plugin$52 = { serialize: serialize$52, test: test$52 };
var SPACE$12 = " ";
var OBJECT_NAMES2 = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]);
var ARRAY_REGEXP2 = /^(?:HTML\w*Collection|NodeList)$/;
function testName2(name2) {
  return OBJECT_NAMES2.has(name2) || ARRAY_REGEXP2.test(name2);
}
var test$42 = (val) => val && val.constructor && !!val.constructor.name && testName2(val.constructor.name);
function isNamedNodeMap2(collection) {
  return collection.constructor.name === "NamedNodeMap";
}
var serialize$42 = (collection, config3, indentation, depth, refs2, printer22) => {
  let name2 = collection.constructor.name;
  return ++depth > config3.maxDepth ? `[${name2}]` : (config3.min ? "" : name2 + SPACE$12) + (OBJECT_NAMES2.has(name2) ? `{${printObjectProperties2(isNamedNodeMap2(collection) ? [...collection].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}) : { ...collection }, config3, indentation, depth, refs2, printer22)}}` : `[${printListItems2([...collection], config3, indentation, depth, refs2, printer22)}]`);
};
var plugin$42 = { serialize: serialize$42, test: test$42 };
function escapeHTML2(str) {
  return str.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
function printProps2(keys2, props, config3, indentation, depth, refs2, printer22) {
  let indentationNext = indentation + config3.indent, colors = config3.colors;
  return keys2.map((key2) => {
    let value2 = props[key2], printed = printer22(value2, config3, indentationNext, depth, refs2);
    return typeof value2 != "string" && (printed.includes(`
`) && (printed = config3.spacingOuter + indentationNext + printed + config3.spacingOuter + indentation), printed = `{${printed}}`), `${config3.spacingInner + indentation + colors.prop.open + key2 + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;
  }).join("");
}
function printChildren2(children, config3, indentation, depth, refs2, printer22) {
  return children.map((child) => config3.spacingOuter + indentation + (typeof child == "string" ? printText2(child, config3) : printer22(child, config3, indentation, depth, refs2))).join("");
}
function printText2(text, config3) {
  let contentColor = config3.colors.content;
  return contentColor.open + escapeHTML2(text) + contentColor.close;
}
function printComment2(comment, config3) {
  let commentColor = config3.colors.comment;
  return `${commentColor.open}<!--${escapeHTML2(comment)}-->${commentColor.close}`;
}
function printElement2(type5, printedProps, printedChildren, config3, indentation) {
  let tagColor = config3.colors.tag;
  return `${tagColor.open}<${type5}${printedProps && tagColor.close + printedProps + config3.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config3.spacingOuter}${indentation}${tagColor.open}</${type5}` : `${printedProps && !config3.min ? "" : " "}/`}>${tagColor.close}`;
}
function printElementAsLeaf2(type5, config3) {
  let tagColor = config3.colors.tag;
  return `${tagColor.open}<${type5}${tagColor.close} ${tagColor.open} />${tagColor.close}`;
}
var ELEMENT_NODE2 = 1;
var TEXT_NODE2 = 3;
var COMMENT_NODE2 = 8;
var FRAGMENT_NODE2 = 11;
var ELEMENT_REGEXP2 = /^(?:(?:HTML|SVG)\w*)?Element$/;
function testHasAttribute2(val) {
  try {
    return typeof val.hasAttribute == "function" && val.hasAttribute("is");
  } catch {
    return false;
  }
}
function testNode2(val) {
  let constructorName = val.constructor.name, { nodeType, tagName } = val, isCustomElement3 = typeof tagName == "string" && tagName.includes("-") || testHasAttribute2(val);
  return nodeType === ELEMENT_NODE2 && (ELEMENT_REGEXP2.test(constructorName) || isCustomElement3) || nodeType === TEXT_NODE2 && constructorName === "Text" || nodeType === COMMENT_NODE2 && constructorName === "Comment" || nodeType === FRAGMENT_NODE2 && constructorName === "DocumentFragment";
}
var test$32 = (val) => {
  var _a2;
  return ((_a2 = val == null ? void 0 : val.constructor) == null ? void 0 : _a2.name) && testNode2(val);
};
function nodeIsText2(node) {
  return node.nodeType === TEXT_NODE2;
}
function nodeIsComment2(node) {
  return node.nodeType === COMMENT_NODE2;
}
function nodeIsFragment2(node) {
  return node.nodeType === FRAGMENT_NODE2;
}
var serialize$32 = (node, config3, indentation, depth, refs2, printer22) => {
  if (nodeIsText2(node)) return printText2(node.data, config3);
  if (nodeIsComment2(node)) return printComment2(node.data, config3);
  let type5 = nodeIsFragment2(node) ? "DocumentFragment" : node.tagName.toLowerCase();
  return ++depth > config3.maxDepth ? printElementAsLeaf2(type5, config3) : printElement2(type5, printProps2(nodeIsFragment2(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment2(node) ? {} : [...node.attributes].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}), config3, indentation + config3.indent, depth, refs2, printer22), printChildren2(Array.prototype.slice.call(node.childNodes || node.children), config3, indentation + config3.indent, depth, refs2, printer22), config3, indentation);
};
var plugin$32 = { serialize: serialize$32, test: test$32 };
var IS_ITERABLE_SENTINEL2 = "@@__IMMUTABLE_ITERABLE__@@";
var IS_LIST_SENTINEL2 = "@@__IMMUTABLE_LIST__@@";
var IS_KEYED_SENTINEL2 = "@@__IMMUTABLE_KEYED__@@";
var IS_MAP_SENTINEL2 = "@@__IMMUTABLE_MAP__@@";
var IS_ORDERED_SENTINEL2 = "@@__IMMUTABLE_ORDERED__@@";
var IS_RECORD_SENTINEL2 = "@@__IMMUTABLE_RECORD__@@";
var IS_SEQ_SENTINEL2 = "@@__IMMUTABLE_SEQ__@@";
var IS_SET_SENTINEL2 = "@@__IMMUTABLE_SET__@@";
var IS_STACK_SENTINEL2 = "@@__IMMUTABLE_STACK__@@";
var getImmutableName2 = (name2) => `Immutable.${name2}`;
var printAsLeaf2 = (name2) => `[${name2}]`;
var SPACE2 = " ";
var LAZY2 = "";
function printImmutableEntries2(val, config3, indentation, depth, refs2, printer22, type5) {
  return ++depth > config3.maxDepth ? printAsLeaf2(getImmutableName2(type5)) : `${getImmutableName2(type5) + SPACE2}{${printIteratorEntries2(val.entries(), config3, indentation, depth, refs2, printer22)}}`;
}
function getRecordEntries2(val) {
  let i4 = 0;
  return { next() {
    if (i4 < val._keys.length) {
      let key2 = val._keys[i4++];
      return { done: false, value: [key2, val.get(key2)] };
    }
    return { done: true, value: void 0 };
  } };
}
function printImmutableRecord2(val, config3, indentation, depth, refs2, printer22) {
  let name2 = getImmutableName2(val._name || "Record");
  return ++depth > config3.maxDepth ? printAsLeaf2(name2) : `${name2 + SPACE2}{${printIteratorEntries2(getRecordEntries2(val), config3, indentation, depth, refs2, printer22)}}`;
}
function printImmutableSeq2(val, config3, indentation, depth, refs2, printer22) {
  let name2 = getImmutableName2("Seq");
  return ++depth > config3.maxDepth ? printAsLeaf2(name2) : val[IS_KEYED_SENTINEL2] ? `${name2 + SPACE2}{${val._iter || val._object ? printIteratorEntries2(val.entries(), config3, indentation, depth, refs2, printer22) : LAZY2}}` : `${name2 + SPACE2}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues2(val.values(), config3, indentation, depth, refs2, printer22) : LAZY2}]`;
}
function printImmutableValues2(val, config3, indentation, depth, refs2, printer22, type5) {
  return ++depth > config3.maxDepth ? printAsLeaf2(getImmutableName2(type5)) : `${getImmutableName2(type5) + SPACE2}[${printIteratorValues2(val.values(), config3, indentation, depth, refs2, printer22)}]`;
}
var serialize$22 = (val, config3, indentation, depth, refs2, printer22) => val[IS_MAP_SENTINEL2] ? printImmutableEntries2(val, config3, indentation, depth, refs2, printer22, val[IS_ORDERED_SENTINEL2] ? "OrderedMap" : "Map") : val[IS_LIST_SENTINEL2] ? printImmutableValues2(val, config3, indentation, depth, refs2, printer22, "List") : val[IS_SET_SENTINEL2] ? printImmutableValues2(val, config3, indentation, depth, refs2, printer22, val[IS_ORDERED_SENTINEL2] ? "OrderedSet" : "Set") : val[IS_STACK_SENTINEL2] ? printImmutableValues2(val, config3, indentation, depth, refs2, printer22, "Stack") : val[IS_SEQ_SENTINEL2] ? printImmutableSeq2(val, config3, indentation, depth, refs2, printer22) : printImmutableRecord2(val, config3, indentation, depth, refs2, printer22);
var test$22 = (val) => val && (val[IS_ITERABLE_SENTINEL2] === true || val[IS_RECORD_SENTINEL2] === true);
var plugin$22 = { serialize: serialize$22, test: test$22 };
var reactIs2 = { exports: {} };
var reactIs_development2 = {};
var hasRequiredReactIs_development2;
function requireReactIs_development2() {
  return hasRequiredReactIs_development2 || (hasRequiredReactIs_development2 = 1, function() {
    var REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), enableScopeAPI = false, enableCacheElement = false, enableTransitionTracing = false, enableLegacyHidden = false, enableDebugTracing = false, REACT_MODULE_REFERENCE;
    REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
    function isValidElementType(type5) {
      return !!(typeof type5 == "string" || typeof type5 == "function" || type5 === REACT_FRAGMENT_TYPE || type5 === REACT_PROFILER_TYPE || enableDebugTracing || type5 === REACT_STRICT_MODE_TYPE || type5 === REACT_SUSPENSE_TYPE || type5 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type5 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type5 == "object" && type5 !== null && (type5.$$typeof === REACT_LAZY_TYPE || type5.$$typeof === REACT_MEMO_TYPE || type5.$$typeof === REACT_PROVIDER_TYPE || type5.$$typeof === REACT_CONTEXT_TYPE || type5.$$typeof === REACT_FORWARD_REF_TYPE || type5.$$typeof === REACT_MODULE_REFERENCE || type5.getModuleId !== void 0));
    }
    function typeOf(object) {
      if (typeof object == "object" && object !== null) {
        var $$typeof = object.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type5 = object.type;
            switch (type5) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
                return type5;
              default:
                var $$typeofType = type5 && type5.$$typeof;
                switch ($$typeofType) {
                  case REACT_SERVER_CONTEXT_TYPE:
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    var ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo = REACT_MEMO_TYPE, Portal = REACT_PORTAL_TYPE, Profiler = REACT_PROFILER_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, Suspense = REACT_SUSPENSE_TYPE, SuspenseList = REACT_SUSPENSE_LIST_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = false, hasWarnedAboutDeprecatedIsConcurrentMode = false;
    function isAsyncMode(object) {
      return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), false;
    }
    function isConcurrentMode(object) {
      return hasWarnedAboutDeprecatedIsConcurrentMode || (hasWarnedAboutDeprecatedIsConcurrentMode = true, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), false;
    }
    function isContextConsumer(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    }
    function isContextProvider(object) {
      return typeOf(object) === REACT_PROVIDER_TYPE;
    }
    function isElement5(object) {
      return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function isForwardRef(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }
    function isFragment(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    }
    function isLazy(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    }
    function isMemo(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    }
    function isPortal(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    }
    function isProfiler(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    }
    function isStrictMode(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }
    function isSuspense(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    }
    function isSuspenseList(object) {
      return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
    }
    reactIs_development2.ContextConsumer = ContextConsumer, reactIs_development2.ContextProvider = ContextProvider, reactIs_development2.Element = Element2, reactIs_development2.ForwardRef = ForwardRef, reactIs_development2.Fragment = Fragment, reactIs_development2.Lazy = Lazy, reactIs_development2.Memo = Memo, reactIs_development2.Portal = Portal, reactIs_development2.Profiler = Profiler, reactIs_development2.StrictMode = StrictMode, reactIs_development2.Suspense = Suspense, reactIs_development2.SuspenseList = SuspenseList, reactIs_development2.isAsyncMode = isAsyncMode, reactIs_development2.isConcurrentMode = isConcurrentMode, reactIs_development2.isContextConsumer = isContextConsumer, reactIs_development2.isContextProvider = isContextProvider, reactIs_development2.isElement = isElement5, reactIs_development2.isForwardRef = isForwardRef, reactIs_development2.isFragment = isFragment, reactIs_development2.isLazy = isLazy, reactIs_development2.isMemo = isMemo, reactIs_development2.isPortal = isPortal, reactIs_development2.isProfiler = isProfiler, reactIs_development2.isStrictMode = isStrictMode, reactIs_development2.isSuspense = isSuspense, reactIs_development2.isSuspenseList = isSuspenseList, reactIs_development2.isValidElementType = isValidElementType, reactIs_development2.typeOf = typeOf;
  }()), reactIs_development2;
}
reactIs2.exports = requireReactIs_development2();
var reactIsExports2 = reactIs2.exports;
function getChildren2(arg, children = []) {
  if (Array.isArray(arg)) for (let item of arg) getChildren2(item, children);
  else arg != null && arg !== false && arg !== "" && children.push(arg);
  return children;
}
function getType22(element) {
  let type5 = element.type;
  if (typeof type5 == "string") return type5;
  if (typeof type5 == "function") return type5.displayName || type5.name || "Unknown";
  if (reactIsExports2.isFragment(element)) return "React.Fragment";
  if (reactIsExports2.isSuspense(element)) return "React.Suspense";
  if (typeof type5 == "object" && type5 !== null) {
    if (reactIsExports2.isContextProvider(element)) return "Context.Provider";
    if (reactIsExports2.isContextConsumer(element)) return "Context.Consumer";
    if (reactIsExports2.isForwardRef(element)) {
      if (type5.displayName) return type5.displayName;
      let functionName = type5.render.displayName || type5.render.name || "";
      return functionName === "" ? "ForwardRef" : `ForwardRef(${functionName})`;
    }
    if (reactIsExports2.isMemo(element)) {
      let functionName = type5.displayName || type5.type.displayName || type5.type.name || "";
      return functionName === "" ? "Memo" : `Memo(${functionName})`;
    }
  }
  return "UNDEFINED";
}
function getPropKeys$12(element) {
  let { props } = element;
  return Object.keys(props).filter((key2) => key2 !== "children" && props[key2] !== void 0).sort();
}
var serialize$12 = (element, config3, indentation, depth, refs2, printer22) => ++depth > config3.maxDepth ? printElementAsLeaf2(getType22(element), config3) : printElement2(getType22(element), printProps2(getPropKeys$12(element), element.props, config3, indentation + config3.indent, depth, refs2, printer22), printChildren2(getChildren2(element.props.children), config3, indentation + config3.indent, depth, refs2, printer22), config3, indentation);
var test$12 = (val) => val != null && reactIsExports2.isElement(val);
var plugin$12 = { serialize: serialize$12, test: test$12 };
var testSymbol2 = typeof Symbol == "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function getPropKeys2(object) {
  let { props } = object;
  return props ? Object.keys(props).filter((key2) => props[key2] !== void 0).sort() : [];
}
var serialize2 = (object, config3, indentation, depth, refs2, printer22) => ++depth > config3.maxDepth ? printElementAsLeaf2(object.type, config3) : printElement2(object.type, object.props ? printProps2(getPropKeys2(object), object.props, config3, indentation + config3.indent, depth, refs2, printer22) : "", object.children ? printChildren2(object.children, config3, indentation + config3.indent, depth, refs2, printer22) : "", config3, indentation);
var test22 = (val) => val && val.$$typeof === testSymbol2;
var plugin2 = { serialize: serialize2, test: test22 };
var toString32 = Object.prototype.toString;
var toISOString2 = Date.prototype.toISOString;
var errorToString2 = Error.prototype.toString;
var regExpToString2 = RegExp.prototype.toString;
function getConstructorName22(val) {
  return typeof val.constructor == "function" && val.constructor.name || "Object";
}
function isWindow2(val) {
  return typeof window < "u" && val === window;
}
var SYMBOL_REGEXP2 = /^Symbol\((.*)\)(.*)$/;
var NEWLINE_REGEXP2 = /\n/g;
var PrettyFormatPluginError2 = class extends Error {
  constructor(message, stack) {
    super(message), this.stack = stack, this.name = this.constructor.name;
  }
};
function isToStringedArrayType2(toStringed) {
  return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
}
function printNumber2(val) {
  return Object.is(val, -0) ? "-0" : String(val);
}
function printBigInt2(val) {
  return `${val}n`;
}
function printFunction2(val, printFunctionName) {
  return printFunctionName ? `[Function ${val.name || "anonymous"}]` : "[Function]";
}
function printSymbol2(val) {
  return String(val).replace(SYMBOL_REGEXP2, "Symbol($1)");
}
function printError2(val) {
  return `[${errorToString2.call(val)}]`;
}
function printBasicValue2(val, printFunctionName, escapeRegex, escapeString) {
  if (val === true || val === false) return `${val}`;
  if (val === void 0) return "undefined";
  if (val === null) return "null";
  let typeOf = typeof val;
  if (typeOf === "number") return printNumber2(val);
  if (typeOf === "bigint") return printBigInt2(val);
  if (typeOf === "string") return escapeString ? `"${val.replaceAll(/"|\\/g, "\\$&")}"` : `"${val}"`;
  if (typeOf === "function") return printFunction2(val, printFunctionName);
  if (typeOf === "symbol") return printSymbol2(val);
  let toStringed = toString32.call(val);
  return toStringed === "[object WeakMap]" ? "WeakMap {}" : toStringed === "[object WeakSet]" ? "WeakSet {}" : toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]" ? printFunction2(val, printFunctionName) : toStringed === "[object Symbol]" ? printSymbol2(val) : toStringed === "[object Date]" ? Number.isNaN(+val) ? "Date { NaN }" : toISOString2.call(val) : toStringed === "[object Error]" ? printError2(val) : toStringed === "[object RegExp]" ? escapeRegex ? regExpToString2.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&") : regExpToString2.call(val) : val instanceof Error ? printError2(val) : null;
}
function printComplexValue2(val, config3, indentation, depth, refs2, hasCalledToJSON) {
  if (refs2.includes(val)) return "[Circular]";
  refs2 = [...refs2], refs2.push(val);
  let hitMaxDepth = ++depth > config3.maxDepth, min = config3.min;
  if (config3.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON == "function" && !hasCalledToJSON) return printer2(val.toJSON(), config3, indentation, depth, refs2, true);
  let toStringed = toString32.call(val);
  return toStringed === "[object Arguments]" ? hitMaxDepth ? "[Arguments]" : `${min ? "" : "Arguments "}[${printListItems2(val, config3, indentation, depth, refs2, printer2)}]` : isToStringedArrayType2(toStringed) ? hitMaxDepth ? `[${val.constructor.name}]` : `${min || !config3.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${printListItems2(val, config3, indentation, depth, refs2, printer2)}]` : toStringed === "[object Map]" ? hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries2(val.entries(), config3, indentation, depth, refs2, printer2, " => ")}}` : toStringed === "[object Set]" ? hitMaxDepth ? "[Set]" : `Set {${printIteratorValues2(val.values(), config3, indentation, depth, refs2, printer2)}}` : hitMaxDepth || isWindow2(val) ? `[${getConstructorName22(val)}]` : `${min || !config3.printBasicPrototype && getConstructorName22(val) === "Object" ? "" : `${getConstructorName22(val)} `}{${printObjectProperties2(val, config3, indentation, depth, refs2, printer2)}}`;
}
function isNewPlugin2(plugin22) {
  return plugin22.serialize != null;
}
function printPlugin2(plugin22, val, config3, indentation, depth, refs2) {
  let printed;
  try {
    printed = isNewPlugin2(plugin22) ? plugin22.serialize(val, config3, indentation, depth, refs2, printer2) : plugin22.print(val, (valChild) => printer2(valChild, config3, indentation, depth, refs2), (str) => {
      let indentationNext = indentation + config3.indent;
      return indentationNext + str.replaceAll(NEWLINE_REGEXP2, `
${indentationNext}`);
    }, { edgeSpacing: config3.spacingOuter, min: config3.min, spacing: config3.spacingInner }, config3.colors);
  } catch (error) {
    throw new PrettyFormatPluginError2(error.message, error.stack);
  }
  if (typeof printed != "string") throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
  return printed;
}
function findPlugin2(plugins22, val) {
  for (let plugin22 of plugins22) try {
    if (plugin22.test(val)) return plugin22;
  } catch (error) {
    throw new PrettyFormatPluginError2(error.message, error.stack);
  }
  return null;
}
function printer2(val, config3, indentation, depth, refs2, hasCalledToJSON) {
  let plugin22 = findPlugin2(config3.plugins, val);
  if (plugin22 !== null) return printPlugin2(plugin22, val, config3, indentation, depth, refs2);
  let basicResult = printBasicValue2(val, config3.printFunctionName, config3.escapeRegex, config3.escapeString);
  return basicResult !== null ? basicResult : printComplexValue2(val, config3, indentation, depth, refs2, hasCalledToJSON);
}
var DEFAULT_THEME2 = { comment: "gray", content: "reset", prop: "yellow", tag: "cyan", value: "green" };
var DEFAULT_THEME_KEYS2 = Object.keys(DEFAULT_THEME2);
var DEFAULT_OPTIONS2 = { callToJSON: true, compareKeys: void 0, escapeRegex: false, escapeString: true, highlight: false, indent: 2, maxDepth: Number.POSITIVE_INFINITY, maxWidth: Number.POSITIVE_INFINITY, min: false, plugins: [], printBasicPrototype: true, printFunctionName: true, theme: DEFAULT_THEME2 };
function validateOptions2(options2) {
  for (let key2 of Object.keys(options2)) if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS2, key2)) throw new Error(`pretty-format: Unknown option "${key2}".`);
  if (options2.min && options2.indent !== void 0 && options2.indent !== 0) throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
function getColorsHighlight2() {
  return DEFAULT_THEME_KEYS2.reduce((colors, key2) => {
    let value2 = DEFAULT_THEME2[key2], color = value2 && f23[value2];
    if (color && typeof color.close == "string" && typeof color.open == "string") colors[key2] = color;
    else throw new Error(`pretty-format: Option "theme" has a key "${key2}" whose value "${value2}" is undefined in ansi-styles.`);
    return colors;
  }, /* @__PURE__ */ Object.create(null));
}
function getColorsEmpty2() {
  return DEFAULT_THEME_KEYS2.reduce((colors, key2) => (colors[key2] = { close: "", open: "" }, colors), /* @__PURE__ */ Object.create(null));
}
function getPrintFunctionName2(options2) {
  return (options2 == null ? void 0 : options2.printFunctionName) ?? DEFAULT_OPTIONS2.printFunctionName;
}
function getEscapeRegex2(options2) {
  return (options2 == null ? void 0 : options2.escapeRegex) ?? DEFAULT_OPTIONS2.escapeRegex;
}
function getEscapeString2(options2) {
  return (options2 == null ? void 0 : options2.escapeString) ?? DEFAULT_OPTIONS2.escapeString;
}
function getConfig2(options2) {
  return { callToJSON: (options2 == null ? void 0 : options2.callToJSON) ?? DEFAULT_OPTIONS2.callToJSON, colors: (options2 == null ? void 0 : options2.highlight) ? getColorsHighlight2() : getColorsEmpty2(), compareKeys: typeof (options2 == null ? void 0 : options2.compareKeys) == "function" || (options2 == null ? void 0 : options2.compareKeys) === null ? options2.compareKeys : DEFAULT_OPTIONS2.compareKeys, escapeRegex: getEscapeRegex2(options2), escapeString: getEscapeString2(options2), indent: (options2 == null ? void 0 : options2.min) ? "" : createIndent2((options2 == null ? void 0 : options2.indent) ?? DEFAULT_OPTIONS2.indent), maxDepth: (options2 == null ? void 0 : options2.maxDepth) ?? DEFAULT_OPTIONS2.maxDepth, maxWidth: (options2 == null ? void 0 : options2.maxWidth) ?? DEFAULT_OPTIONS2.maxWidth, min: (options2 == null ? void 0 : options2.min) ?? DEFAULT_OPTIONS2.min, plugins: (options2 == null ? void 0 : options2.plugins) ?? DEFAULT_OPTIONS2.plugins, printBasicPrototype: (options2 == null ? void 0 : options2.printBasicPrototype) ?? true, printFunctionName: getPrintFunctionName2(options2), spacingInner: (options2 == null ? void 0 : options2.min) ? " " : `
`, spacingOuter: (options2 == null ? void 0 : options2.min) ? "" : `
` };
}
function createIndent2(indent) {
  return Array.from({ length: indent + 1 }).join(" ");
}
function format3(val, options2) {
  if (options2 && (validateOptions2(options2), options2.plugins)) {
    let plugin22 = findPlugin2(options2.plugins, val);
    if (plugin22 !== null) return printPlugin2(plugin22, val, getConfig2(options2), "", 0, []);
  }
  let basicResult = printBasicValue2(val, getPrintFunctionName2(options2), getEscapeRegex2(options2), getEscapeString2(options2));
  return basicResult !== null ? basicResult : printComplexValue2(val, getConfig2(options2), "", 0, []);
}
var plugins2 = { AsymmetricMatcher: plugin$52, DOMCollection: plugin$42, DOMElement: plugin$32, Immutable: plugin$22, ReactElement: plugin$12, ReactTestComponent: plugin2 };
var { AsymmetricMatcher: AsymmetricMatcher3, DOMCollection: DOMCollection3, DOMElement: DOMElement3, Immutable: Immutable3, ReactElement: ReactElement3, ReactTestComponent: ReactTestComponent3 } = plugins2;
var PLUGINS3 = [ReactTestComponent3, ReactElement3, DOMElement3, DOMCollection3, Immutable3, AsymmetricMatcher3];
function stringify2(object, maxDepth = 10, { maxLength, ...options2 } = {}) {
  let MAX_LENGTH = maxLength ?? 1e4, result2;
  try {
    result2 = format3(object, { maxDepth, escapeString: false, plugins: PLUGINS3, ...options2 });
  } catch {
    result2 = format3(object, { callToJSON: false, maxDepth, escapeString: false, plugins: PLUGINS3, ...options2 });
  }
  return result2.length >= MAX_LENGTH && maxDepth > 1 ? stringify2(object, Math.floor(maxDepth / 2)) : result2;
}
var formatRegExp2 = /%[sdjifoOc%]/g;
function format22(...args2) {
  if (typeof args2[0] != "string") {
    let objects = [];
    for (let i22 = 0; i22 < args2.length; i22++) objects.push(inspect4(args2[i22], { depth: 0, colors: false }));
    return objects.join(" ");
  }
  let len = args2.length, i4 = 1, template = args2[0], str = String(template).replace(formatRegExp2, (x22) => {
    if (x22 === "%%") return "%";
    if (i4 >= len) return x22;
    switch (x22) {
      case "%s": {
        let value2 = args2[i4++];
        return typeof value2 == "bigint" ? `${value2.toString()}n` : typeof value2 == "number" && value2 === 0 && 1 / value2 < 0 ? "-0" : typeof value2 == "object" && value2 !== null ? inspect4(value2, { depth: 0, colors: false }) : String(value2);
      }
      case "%d": {
        let value2 = args2[i4++];
        return typeof value2 == "bigint" ? `${value2.toString()}n` : Number(value2).toString();
      }
      case "%i": {
        let value2 = args2[i4++];
        return typeof value2 == "bigint" ? `${value2.toString()}n` : Number.parseInt(String(value2)).toString();
      }
      case "%f":
        return Number.parseFloat(String(args2[i4++])).toString();
      case "%o":
        return inspect4(args2[i4++], { showHidden: true, showProxy: true });
      case "%O":
        return inspect4(args2[i4++]);
      case "%c":
        return i4++, "";
      case "%j":
        try {
          return JSON.stringify(args2[i4++]);
        } catch (err) {
          let m22 = err.message;
          if (m22.includes("circular structure") || m22.includes("cyclic structures") || m22.includes("cyclic object")) return "[Circular]";
          throw err;
        }
      default:
        return x22;
    }
  });
  for (let x22 = args2[i4]; i4 < len; x22 = args2[++i4]) x22 === null || typeof x22 != "object" ? str += ` ${x22}` : str += ` ${inspect4(x22)}`;
  return str;
}
function inspect4(obj, options2 = {}) {
  return options2.truncate === 0 && (options2.truncate = Number.POSITIVE_INFINITY), inspect32(obj, options2);
}
var LineTerminatorSequence;
LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
RegExp(LineTerminatorSequence.source);
var reservedWords = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"] };
new Set(reservedWords.keyword);
new Set(reservedWords.strict);
function getType32(value2) {
  if (value2 === void 0) return "undefined";
  if (value2 === null) return "null";
  if (Array.isArray(value2)) return "array";
  if (typeof value2 == "boolean") return "boolean";
  if (typeof value2 == "function") return "function";
  if (typeof value2 == "number") return "number";
  if (typeof value2 == "string") return "string";
  if (typeof value2 == "bigint") return "bigint";
  if (typeof value2 == "object") {
    if (value2 != null) {
      if (value2.constructor === RegExp) return "regexp";
      if (value2.constructor === Map) return "map";
      if (value2.constructor === Set) return "set";
      if (value2.constructor === Date) return "date";
    }
    return "object";
  } else if (typeof value2 == "symbol") return "symbol";
  throw new Error(`value of unknown type: ${value2}`);
}
var DIFF_DELETE2 = -1;
var DIFF_INSERT2 = 1;
var DIFF_EQUAL2 = 0;
var Diff2 = class {
  constructor(op, text) {
    __publicField(this, 0);
    __publicField(this, 1);
    this[0] = op, this[1] = text;
  }
};
var diff_commonPrefix2 = function(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) return 0;
  let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerstart = 0;
  for (; pointermin < pointermid; ) text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid) ? (pointermin = pointermid, pointerstart = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  return pointermid;
};
var diff_commonSuffix2 = function(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) return 0;
  let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerend = 0;
  for (; pointermin < pointermid; ) text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend) ? (pointermin = pointermid, pointerend = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  return pointermid;
};
var diff_commonOverlap_2 = function(text1, text2) {
  let text1_length = text1.length, text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0) return 0;
  text1_length > text2_length ? text1 = text1.substring(text1_length - text2_length) : text1_length < text2_length && (text2 = text2.substring(0, text1_length));
  let text_length = Math.min(text1_length, text2_length);
  if (text1 === text2) return text_length;
  let best = 0, length = 1;
  for (; ; ) {
    let pattern = text1.substring(text_length - length), found = text2.indexOf(pattern);
    if (found === -1) return best;
    length += found, (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) && (best = length, length++);
  }
};
var diff_cleanupSemantic2 = function(diffs) {
  let changes = false, equalities = [], equalitiesLength = 0, lastEquality = null, pointer3 = 0, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0;
  for (; pointer3 < diffs.length; ) diffs[pointer3][0] === DIFF_EQUAL2 ? (equalities[equalitiesLength++] = pointer3, length_insertions1 = length_insertions2, length_deletions1 = length_deletions2, length_insertions2 = 0, length_deletions2 = 0, lastEquality = diffs[pointer3][1]) : (diffs[pointer3][0] === DIFF_INSERT2 ? length_insertions2 += diffs[pointer3][1].length : length_deletions2 += diffs[pointer3][1].length, lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, new Diff2(DIFF_DELETE2, lastEquality)), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT2, equalitiesLength--, equalitiesLength--, pointer3 = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0, lastEquality = null, changes = true)), pointer3++;
  for (changes && diff_cleanupMerge2(diffs), diff_cleanupSemanticLossless2(diffs), pointer3 = 1; pointer3 < diffs.length; ) {
    if (diffs[pointer3 - 1][0] === DIFF_DELETE2 && diffs[pointer3][0] === DIFF_INSERT2) {
      let deletion = diffs[pointer3 - 1][1], insertion = diffs[pointer3][1], overlap_length1 = diff_commonOverlap_2(deletion, insertion), overlap_length2 = diff_commonOverlap_2(insertion, deletion);
      overlap_length1 >= overlap_length2 ? (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) && (diffs.splice(pointer3, 0, new Diff2(DIFF_EQUAL2, insertion.substring(0, overlap_length1))), diffs[pointer3 - 1][1] = deletion.substring(0, deletion.length - overlap_length1), diffs[pointer3 + 1][1] = insertion.substring(overlap_length1), pointer3++) : (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) && (diffs.splice(pointer3, 0, new Diff2(DIFF_EQUAL2, deletion.substring(0, overlap_length2))), diffs[pointer3 - 1][0] = DIFF_INSERT2, diffs[pointer3 - 1][1] = insertion.substring(0, insertion.length - overlap_length2), diffs[pointer3 + 1][0] = DIFF_DELETE2, diffs[pointer3 + 1][1] = deletion.substring(overlap_length2), pointer3++), pointer3++;
    }
    pointer3++;
  }
};
var nonAlphaNumericRegex_2 = /[^a-z0-9]/i;
var whitespaceRegex_2 = /\s/;
var linebreakRegex_2 = /[\r\n]/;
var blanklineEndRegex_2 = /\n\r?\n$/;
var blanklineStartRegex_2 = /^\r?\n\r?\n/;
function diff_cleanupSemanticLossless2(diffs) {
  function diff_cleanupSemanticScore_2(one, two) {
    if (!one || !two) return 6;
    let char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_2), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_2), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_2), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_2), lineBreak1 = whitespace1 && char1.match(linebreakRegex_2), lineBreak2 = whitespace2 && char2.match(linebreakRegex_2), blankLine1 = lineBreak1 && one.match(blanklineEndRegex_2), blankLine2 = lineBreak2 && two.match(blanklineStartRegex_2);
    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
  }
  let pointer3 = 1;
  for (; pointer3 < diffs.length - 1; ) {
    if (diffs[pointer3 - 1][0] === DIFF_EQUAL2 && diffs[pointer3 + 1][0] === DIFF_EQUAL2) {
      let equality1 = diffs[pointer3 - 1][1], edit = diffs[pointer3][1], equality2 = diffs[pointer3 + 1][1], commonOffset = diff_commonSuffix2(equality1, edit);
      if (commonOffset) {
        let commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diff_cleanupSemanticScore_2(equality1, edit) + diff_cleanupSemanticScore_2(edit, equality2);
      for (; edit.charAt(0) === equality2.charAt(0); ) {
        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
        let score = diff_cleanupSemanticScore_2(equality1, edit) + diff_cleanupSemanticScore_2(edit, equality2);
        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
      }
      diffs[pointer3 - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer3 - 1][1] = bestEquality1 : (diffs.splice(pointer3 - 1, 1), pointer3--), diffs[pointer3][1] = bestEdit, bestEquality2 ? diffs[pointer3 + 1][1] = bestEquality2 : (diffs.splice(pointer3 + 1, 1), pointer3--));
    }
    pointer3++;
  }
}
function diff_cleanupMerge2(diffs) {
  diffs.push(new Diff2(DIFF_EQUAL2, ""));
  let pointer3 = 0, count_delete = 0, count_insert = 0, text_delete = "", text_insert = "", commonlength;
  for (; pointer3 < diffs.length; ) switch (diffs[pointer3][0]) {
    case DIFF_INSERT2:
      count_insert++, text_insert += diffs[pointer3][1], pointer3++;
      break;
    case DIFF_DELETE2:
      count_delete++, text_delete += diffs[pointer3][1], pointer3++;
      break;
    case DIFF_EQUAL2:
      count_delete + count_insert > 1 ? (count_delete !== 0 && count_insert !== 0 && (commonlength = diff_commonPrefix2(text_insert, text_delete), commonlength !== 0 && (pointer3 - count_delete - count_insert > 0 && diffs[pointer3 - count_delete - count_insert - 1][0] === DIFF_EQUAL2 ? diffs[pointer3 - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength) : (diffs.splice(0, 0, new Diff2(DIFF_EQUAL2, text_insert.substring(0, commonlength))), pointer3++), text_insert = text_insert.substring(commonlength), text_delete = text_delete.substring(commonlength)), commonlength = diff_commonSuffix2(text_insert, text_delete), commonlength !== 0 && (diffs[pointer3][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer3][1], text_insert = text_insert.substring(0, text_insert.length - commonlength), text_delete = text_delete.substring(0, text_delete.length - commonlength))), pointer3 -= count_delete + count_insert, diffs.splice(pointer3, count_delete + count_insert), text_delete.length && (diffs.splice(pointer3, 0, new Diff2(DIFF_DELETE2, text_delete)), pointer3++), text_insert.length && (diffs.splice(pointer3, 0, new Diff2(DIFF_INSERT2, text_insert)), pointer3++), pointer3++) : pointer3 !== 0 && diffs[pointer3 - 1][0] === DIFF_EQUAL2 ? (diffs[pointer3 - 1][1] += diffs[pointer3][1], diffs.splice(pointer3, 1)) : pointer3++, count_insert = 0, count_delete = 0, text_delete = "", text_insert = "";
      break;
  }
  diffs[diffs.length - 1][1] === "" && diffs.pop();
  let changes = false;
  for (pointer3 = 1; pointer3 < diffs.length - 1; ) diffs[pointer3 - 1][0] === DIFF_EQUAL2 && diffs[pointer3 + 1][0] === DIFF_EQUAL2 && (diffs[pointer3][1].substring(diffs[pointer3][1].length - diffs[pointer3 - 1][1].length) === diffs[pointer3 - 1][1] ? (diffs[pointer3][1] = diffs[pointer3 - 1][1] + diffs[pointer3][1].substring(0, diffs[pointer3][1].length - diffs[pointer3 - 1][1].length), diffs[pointer3 + 1][1] = diffs[pointer3 - 1][1] + diffs[pointer3 + 1][1], diffs.splice(pointer3 - 1, 1), changes = true) : diffs[pointer3][1].substring(0, diffs[pointer3 + 1][1].length) === diffs[pointer3 + 1][1] && (diffs[pointer3 - 1][1] += diffs[pointer3 + 1][1], diffs[pointer3][1] = diffs[pointer3][1].substring(diffs[pointer3 + 1][1].length) + diffs[pointer3 + 1][1], diffs.splice(pointer3 + 1, 1), changes = true)), pointer3++;
  changes && diff_cleanupMerge2(diffs);
}
var NO_DIFF_MESSAGE2 = "Compared values have no visual difference.";
var SIMILAR_MESSAGE2 = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.";
var build2 = {};
Object.defineProperty(build2, "__esModule", { value: true });
var _default = build2.default = diffSequence;
var pkg = "diff-sequences";
var NOT_YET_SET = 0;
var countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {
  let nCommon = 0;
  for (; aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex); ) aIndex += 1, bIndex += 1, nCommon += 1;
  return nCommon;
};
var countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {
  let nCommon = 0;
  for (; aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex); ) aIndex -= 1, bIndex -= 1, nCommon += 1;
  return nCommon;
};
var extendPathsF = (d22, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
  let iF = 0, kF = -d22, aFirst = aIndexesF[iF], aIndexPrev1 = aFirst;
  aIndexesF[iF] += countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
  let nF = d22 < iMaxF ? d22 : iMaxF;
  for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
    if (iF !== d22 && aIndexPrev1 < aIndexesF[iF]) aFirst = aIndexesF[iF];
    else if (aFirst = aIndexPrev1 + 1, aEnd <= aFirst) return iF - 1;
    aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
  }
  return iMaxF;
};
var extendPathsR = (d22, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
  let iR = 0, kR = d22, aFirst = aIndexesR[iR], aIndexPrev1 = aFirst;
  aIndexesR[iR] -= countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
  let nR = d22 < iMaxR ? d22 : iMaxR;
  for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
    if (iR !== d22 && aIndexesR[iR] < aIndexPrev1) aFirst = aIndexesR[iR];
    else if (aFirst = aIndexPrev1 - 1, aFirst < aStart) return iR - 1;
    aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aFirst - countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
  }
  return iMaxR;
};
var extendOverlappablePathsF = (d22, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
  let bF = bStart - aStart, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapF = -baDeltaLength - (d22 - 1), kMaxOverlapF = -baDeltaLength + (d22 - 1), aIndexPrev1 = NOT_YET_SET, nF = d22 < iMaxF ? d22 : iMaxF;
  for (let iF = 0, kF = -d22; iF <= nF; iF += 1, kF += 2) {
    let insert = iF === 0 || iF !== d22 && aIndexPrev1 < aIndexesF[iF], aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev + 1, bFirst = bF + aFirst - kF, nCommonF = countCommonItemsF(aFirst + 1, aEnd, bFirst + 1, bEnd, isCommon), aLast = aFirst + nCommonF;
    if (aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aLast, kMinOverlapF <= kF && kF <= kMaxOverlapF) {
      let iR = (d22 - 1 - (kF + baDeltaLength)) / 2;
      if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
        let bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1), nCommonR = countCommonItemsR(aStart, aLastPrev, bStart, bLastPrev, isCommon), aIndexPrevFirst = aLastPrev - nCommonR, bIndexPrevFirst = bLastPrev - nCommonR, aEndPreceding = aIndexPrevFirst + 1, bEndPreceding = bIndexPrevFirst + 1;
        division.nChangePreceding = d22 - 1, d22 - 1 === aEndPreceding + bEndPreceding - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aEndPreceding, division.bEndPreceding = bEndPreceding), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aEndPreceding, division.bCommonPreceding = bEndPreceding), division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aFirst + 1, division.bCommonFollowing = bFirst + 1);
        let aStartFollowing = aLast + 1, bStartFollowing = bFirst + nCommonF + 1;
        return division.nChangeFollowing = d22 - 1, d22 - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing), true;
      }
    }
  }
  return false;
};
var extendOverlappablePathsR = (d22, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
  let bR = bEnd - aEnd, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapR = baDeltaLength - d22, kMaxOverlapR = baDeltaLength + d22, aIndexPrev1 = NOT_YET_SET, nR = d22 < iMaxR ? d22 : iMaxR;
  for (let iR = 0, kR = d22; iR <= nR; iR += 1, kR -= 2) {
    let insert = iR === 0 || iR !== d22 && aIndexesR[iR] < aIndexPrev1, aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev - 1, bFirst = bR + aFirst - kR, nCommonR = countCommonItemsR(aStart, aFirst - 1, bStart, bFirst - 1, isCommon), aLast = aFirst - nCommonR;
    if (aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aLast, kMinOverlapR <= kR && kR <= kMaxOverlapR) {
      let iF = (d22 + (kR - baDeltaLength)) / 2;
      if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
        let bLast = bFirst - nCommonR;
        if (division.nChangePreceding = d22, d22 === aLast + bLast - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aLast, division.bEndPreceding = bLast), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aLast, division.bCommonPreceding = bLast), division.nChangeFollowing = d22 - 1, d22 === 1) division.nCommonFollowing = 0, division.aStartFollowing = aEnd, division.bStartFollowing = bEnd;
        else {
          let bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1), nCommonF = countCommonItemsF(aLastPrev, aEnd, bLastPrev, bEnd, isCommon);
          division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aLastPrev, division.bCommonFollowing = bLastPrev);
          let aStartFollowing = aLastPrev + nCommonF, bStartFollowing = bLastPrev + nCommonF;
          d22 - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing);
        }
        return true;
      }
    }
  }
  return false;
};
var divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
  let bF = bStart - aStart, bR = bEnd - aEnd, aLength = aEnd - aStart, bLength = bEnd - bStart, baDeltaLength = bLength - aLength, iMaxF = aLength, iMaxR = aLength;
  if (aIndexesF[0] = aStart - 1, aIndexesR[0] = aEnd, baDeltaLength % 2 === 0) {
    let dMin = (nChange || baDeltaLength) / 2, dMax = (aLength + bLength) / 2;
    for (let d22 = 1; d22 <= dMax; d22 += 1) if (iMaxF = extendPathsF(d22, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d22 < dMin) iMaxR = extendPathsR(d22, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
    else if (extendOverlappablePathsR(d22, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) return;
  } else {
    let dMin = ((nChange || baDeltaLength) + 1) / 2, dMax = (aLength + bLength + 1) / 2, d22 = 1;
    for (iMaxF = extendPathsF(d22, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d22 += 1; d22 <= dMax; d22 += 1) if (iMaxR = extendPathsR(d22 - 1, aStart, bStart, bR, isCommon, aIndexesR, iMaxR), d22 < dMin) iMaxF = extendPathsF(d22, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
    else if (extendOverlappablePathsF(d22, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) return;
  }
  throw new Error(`${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`);
};
var findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
  if (bEnd - bStart < aEnd - aStart) {
    if (transposed = !transposed, transposed && callbacks.length === 1) {
      let { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];
      callbacks[1] = { foundSubsequence: (nCommon, bCommon, aCommon) => {
        foundSubsequence2(nCommon, aCommon, bCommon);
      }, isCommon: (bIndex, aIndex) => isCommon2(aIndex, bIndex) };
    }
    let tStart = aStart, tEnd = aEnd;
    aStart = bStart, aEnd = bEnd, bStart = tStart, bEnd = tEnd;
  }
  let { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
  divide(nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division);
  let { nChangePreceding, aEndPreceding, bEndPreceding, nCommonPreceding, aCommonPreceding, bCommonPreceding, nCommonFollowing, aCommonFollowing, bCommonFollowing, nChangeFollowing, aStartFollowing, bStartFollowing } = division;
  aStart < aEndPreceding && bStart < bEndPreceding && findSubsequences(nChangePreceding, aStart, aEndPreceding, bStart, bEndPreceding, transposed, callbacks, aIndexesF, aIndexesR, division), nCommonPreceding !== 0 && foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding), nCommonFollowing !== 0 && foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing), aStartFollowing < aEnd && bStartFollowing < bEnd && findSubsequences(nChangeFollowing, aStartFollowing, aEnd, bStartFollowing, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);
};
var validateLength = (name2, arg) => {
  if (typeof arg != "number") throw new TypeError(`${pkg}: ${name2} typeof ${typeof arg} is not a number`);
  if (!Number.isSafeInteger(arg)) throw new RangeError(`${pkg}: ${name2} value ${arg} is not a safe integer`);
  if (arg < 0) throw new RangeError(`${pkg}: ${name2} value ${arg} is a negative integer`);
};
var validateCallback = (name2, arg) => {
  let type5 = typeof arg;
  if (type5 !== "function") throw new TypeError(`${pkg}: ${name2} typeof ${type5} is not a function`);
};
function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
  validateLength("aLength", aLength), validateLength("bLength", bLength), validateCallback("isCommon", isCommon), validateCallback("foundSubsequence", foundSubsequence);
  let nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
  if (nCommonF !== 0 && foundSubsequence(nCommonF, 0, 0), aLength !== nCommonF || bLength !== nCommonF) {
    let aStart = nCommonF, bStart = nCommonF, nCommonR = countCommonItemsR(aStart, aLength - 1, bStart, bLength - 1, isCommon), aEnd = aLength - nCommonR, bEnd = bLength - nCommonR, nCommonFR = nCommonF + nCommonR;
    aLength !== nCommonFR && bLength !== nCommonFR && findSubsequences(0, aStart, aEnd, bStart, bEnd, false, [{ foundSubsequence, isCommon }], [NOT_YET_SET], [NOT_YET_SET], { aCommonFollowing: NOT_YET_SET, aCommonPreceding: NOT_YET_SET, aEndPreceding: NOT_YET_SET, aStartFollowing: NOT_YET_SET, bCommonFollowing: NOT_YET_SET, bCommonPreceding: NOT_YET_SET, bEndPreceding: NOT_YET_SET, bStartFollowing: NOT_YET_SET, nChangeFollowing: NOT_YET_SET, nChangePreceding: NOT_YET_SET, nCommonFollowing: NOT_YET_SET, nCommonPreceding: NOT_YET_SET }), nCommonR !== 0 && foundSubsequence(nCommonR, aEnd, bEnd);
  }
}
function formatTrailingSpaces2(line, trailingSpaceFormatter) {
  return line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
}
function printDiffLine2(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
  return line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces2(line, trailingSpaceFormatter)}`) : indicator !== " " ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
}
function printDeleteLine2(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine2(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printInsertLine2(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine2(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printCommonLine2(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine2(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function createPatchMark2(aStart, aEnd, bStart, bEnd, { patchColor }) {
  return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
}
function joinAlignedDiffsNoExpand2(diffs, options2) {
  let iLength = diffs.length, nContextLines = options2.contextLines, nContextLines2 = nContextLines + nContextLines, jLength = iLength, hasExcessAtStartOrEnd = false, nExcessesBetweenChanges = 0, i4 = 0;
  for (; i4 !== iLength; ) {
    let iStart = i4;
    for (; i4 !== iLength && diffs[i4][0] === DIFF_EQUAL2; ) i4 += 1;
    if (iStart !== i4) if (iStart === 0) i4 > nContextLines && (jLength -= i4 - nContextLines, hasExcessAtStartOrEnd = true);
    else if (i4 === iLength) {
      let n3 = i4 - iStart;
      n3 > nContextLines && (jLength -= n3 - nContextLines, hasExcessAtStartOrEnd = true);
    } else {
      let n3 = i4 - iStart;
      n3 > nContextLines2 && (jLength -= n3 - nContextLines2, nExcessesBetweenChanges += 1);
    }
    for (; i4 !== iLength && diffs[i4][0] !== DIFF_EQUAL2; ) i4 += 1;
  }
  let hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
  nExcessesBetweenChanges !== 0 ? jLength += nExcessesBetweenChanges + 1 : hasExcessAtStartOrEnd && (jLength += 1);
  let jLast = jLength - 1, lines = [], jPatchMark = 0;
  hasPatch && lines.push("");
  let aStart = 0, bStart = 0, aEnd = 0, bEnd = 0, pushCommonLine = (line) => {
    let j2 = lines.length;
    lines.push(printCommonLine2(line, j2 === 0 || j2 === jLast, options2)), aEnd += 1, bEnd += 1;
  }, pushDeleteLine = (line) => {
    let j2 = lines.length;
    lines.push(printDeleteLine2(line, j2 === 0 || j2 === jLast, options2)), aEnd += 1;
  }, pushInsertLine = (line) => {
    let j2 = lines.length;
    lines.push(printInsertLine2(line, j2 === 0 || j2 === jLast, options2)), bEnd += 1;
  };
  for (i4 = 0; i4 !== iLength; ) {
    let iStart = i4;
    for (; i4 !== iLength && diffs[i4][0] === DIFF_EQUAL2; ) i4 += 1;
    if (iStart !== i4) if (iStart === 0) {
      i4 > nContextLines && (iStart = i4 - nContextLines, aStart = iStart, bStart = iStart, aEnd = aStart, bEnd = bStart);
      for (let iCommon = iStart; iCommon !== i4; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
    } else if (i4 === iLength) {
      let iEnd = i4 - iStart > nContextLines ? iStart + nContextLines : i4;
      for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
    } else {
      let nCommon = i4 - iStart;
      if (nCommon > nContextLines2) {
        let iEnd = iStart + nContextLines;
        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
        lines[jPatchMark] = createPatchMark2(aStart, aEnd, bStart, bEnd, options2), jPatchMark = lines.length, lines.push("");
        let nOmit = nCommon - nContextLines2;
        aStart = aEnd + nOmit, bStart = bEnd + nOmit, aEnd = aStart, bEnd = bStart;
        for (let iCommon = i4 - nContextLines; iCommon !== i4; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
      } else for (let iCommon = iStart; iCommon !== i4; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
    }
    for (; i4 !== iLength && diffs[i4][0] === DIFF_DELETE2; ) pushDeleteLine(diffs[i4][1]), i4 += 1;
    for (; i4 !== iLength && diffs[i4][0] === DIFF_INSERT2; ) pushInsertLine(diffs[i4][1]), i4 += 1;
  }
  return hasPatch && (lines[jPatchMark] = createPatchMark2(aStart, aEnd, bStart, bEnd, options2)), lines.join(`
`);
}
function joinAlignedDiffsExpand2(diffs, options2) {
  return diffs.map((diff22, i4, diffs2) => {
    let line = diff22[1], isFirstOrLast = i4 === 0 || i4 === diffs2.length - 1;
    switch (diff22[0]) {
      case DIFF_DELETE2:
        return printDeleteLine2(line, isFirstOrLast, options2);
      case DIFF_INSERT2:
        return printInsertLine2(line, isFirstOrLast, options2);
      default:
        return printCommonLine2(line, isFirstOrLast, options2);
    }
  }).join(`
`);
}
var noColor2 = (string) => string;
var DIFF_CONTEXT_DEFAULT2 = 5;
var DIFF_TRUNCATE_THRESHOLD_DEFAULT2 = 0;
function getDefaultOptions2() {
  return { aAnnotation: "Expected", aColor: f23.green, aIndicator: "-", bAnnotation: "Received", bColor: f23.red, bIndicator: "+", changeColor: f23.inverse, changeLineTrailingSpaceColor: noColor2, commonColor: f23.dim, commonIndicator: " ", commonLineTrailingSpaceColor: noColor2, compareKeys: void 0, contextLines: DIFF_CONTEXT_DEFAULT2, emptyFirstOrLastLinePlaceholder: "", expand: true, includeChangeCounts: false, omitAnnotationLines: false, patchColor: f23.yellow, truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT2, truncateAnnotation: "... Diff result is truncated", truncateAnnotationColor: noColor2 };
}
function getCompareKeys2(compareKeys) {
  return compareKeys && typeof compareKeys == "function" ? compareKeys : void 0;
}
function getContextLines2(contextLines) {
  return typeof contextLines == "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT2;
}
function normalizeDiffOptions2(options2 = {}) {
  return { ...getDefaultOptions2(), ...options2, compareKeys: getCompareKeys2(options2.compareKeys), contextLines: getContextLines2(options2.contextLines) };
}
function isEmptyString2(lines) {
  return lines.length === 1 && lines[0].length === 0;
}
function countChanges2(diffs) {
  let a22 = 0, b6 = 0;
  return diffs.forEach((diff22) => {
    switch (diff22[0]) {
      case DIFF_DELETE2:
        a22 += 1;
        break;
      case DIFF_INSERT2:
        b6 += 1;
        break;
    }
  }), { a: a22, b: b6 };
}
function printAnnotation2({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
  if (omitAnnotationLines) return "";
  let aRest = "", bRest = "";
  if (includeChangeCounts) {
    let aCount = String(changeCounts.a), bCount = String(changeCounts.b), baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length, aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff)), bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff)), baCountLengthDiff = bCount.length - aCount.length, aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff)), bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`, bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
  }
  let a22 = `${aIndicator} ${aAnnotation}${aRest}`, b6 = `${bIndicator} ${bAnnotation}${bRest}`;
  return `${aColor(a22)}
${bColor(b6)}

`;
}
function printDiffLines2(diffs, truncated, options2) {
  return printAnnotation2(options2, countChanges2(diffs)) + (options2.expand ? joinAlignedDiffsExpand2(diffs, options2) : joinAlignedDiffsNoExpand2(diffs, options2)) + (truncated ? options2.truncateAnnotationColor(`
${options2.truncateAnnotation}`) : "");
}
function diffLinesUnified3(aLines, bLines, options2) {
  let normalizedOptions = normalizeDiffOptions2(options2), [diffs, truncated] = diffLinesRaw2(isEmptyString2(aLines) ? [] : aLines, isEmptyString2(bLines) ? [] : bLines, normalizedOptions);
  return printDiffLines2(diffs, truncated, normalizedOptions);
}
function diffLinesUnified22(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options2) {
  if (isEmptyString2(aLinesDisplay) && isEmptyString2(aLinesCompare) && (aLinesDisplay = [], aLinesCompare = []), isEmptyString2(bLinesDisplay) && isEmptyString2(bLinesCompare) && (bLinesDisplay = [], bLinesCompare = []), aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) return diffLinesUnified3(aLinesDisplay, bLinesDisplay, options2);
  let [diffs, truncated] = diffLinesRaw2(aLinesCompare, bLinesCompare, options2), aIndex = 0, bIndex = 0;
  return diffs.forEach((diff22) => {
    switch (diff22[0]) {
      case DIFF_DELETE2:
        diff22[1] = aLinesDisplay[aIndex], aIndex += 1;
        break;
      case DIFF_INSERT2:
        diff22[1] = bLinesDisplay[bIndex], bIndex += 1;
        break;
      default:
        diff22[1] = bLinesDisplay[bIndex], aIndex += 1, bIndex += 1;
    }
  }), printDiffLines2(diffs, truncated, normalizeDiffOptions2(options2));
}
function diffLinesRaw2(aLines, bLines, options2) {
  let truncate3 = (options2 == null ? void 0 : options2.truncateThreshold) ?? false, truncateThreshold = Math.max(Math.floor((options2 == null ? void 0 : options2.truncateThreshold) ?? 0), 0), aLength = truncate3 ? Math.min(aLines.length, truncateThreshold) : aLines.length, bLength = truncate3 ? Math.min(bLines.length, truncateThreshold) : bLines.length, truncated = aLength !== aLines.length || bLength !== bLines.length, isCommon = (aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2], diffs = [], aIndex = 0, bIndex = 0;
  for (_default(aLength, bLength, isCommon, (nCommon, aCommon, bCommon) => {
    for (; aIndex !== aCommon; aIndex += 1) diffs.push(new Diff2(DIFF_DELETE2, aLines[aIndex]));
    for (; bIndex !== bCommon; bIndex += 1) diffs.push(new Diff2(DIFF_INSERT2, bLines[bIndex]));
    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) diffs.push(new Diff2(DIFF_EQUAL2, bLines[bIndex]));
  }); aIndex !== aLength; aIndex += 1) diffs.push(new Diff2(DIFF_DELETE2, aLines[aIndex]));
  for (; bIndex !== bLength; bIndex += 1) diffs.push(new Diff2(DIFF_INSERT2, bLines[bIndex]));
  return [diffs, truncated];
}
function getNewLineSymbol2(string) {
  return string.includes(`\r
`) ? `\r
` : `
`;
}
function diffStrings2(a22, b6, options2) {
  let truncate3 = (options2 == null ? void 0 : options2.truncateThreshold) ?? false, truncateThreshold = Math.max(Math.floor((options2 == null ? void 0 : options2.truncateThreshold) ?? 0), 0), aLength = a22.length, bLength = b6.length;
  if (truncate3) {
    let aMultipleLines = a22.includes(`
`), bMultipleLines = b6.includes(`
`), aNewLineSymbol = getNewLineSymbol2(a22), bNewLineSymbol = getNewLineSymbol2(b6), _a2 = aMultipleLines ? `${a22.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}
` : a22, _b = bMultipleLines ? `${b6.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}
` : b6;
    aLength = _a2.length, bLength = _b.length;
  }
  let truncated = aLength !== a22.length || bLength !== b6.length, isCommon = (aIndex2, bIndex2) => a22[aIndex2] === b6[bIndex2], aIndex = 0, bIndex = 0, diffs = [];
  return _default(aLength, bLength, isCommon, (nCommon, aCommon, bCommon) => {
    aIndex !== aCommon && diffs.push(new Diff2(DIFF_DELETE2, a22.slice(aIndex, aCommon))), bIndex !== bCommon && diffs.push(new Diff2(DIFF_INSERT2, b6.slice(bIndex, bCommon))), aIndex = aCommon + nCommon, bIndex = bCommon + nCommon, diffs.push(new Diff2(DIFF_EQUAL2, b6.slice(bCommon, bIndex)));
  }), aIndex !== aLength && diffs.push(new Diff2(DIFF_DELETE2, a22.slice(aIndex))), bIndex !== bLength && diffs.push(new Diff2(DIFF_INSERT2, b6.slice(bIndex))), [diffs, truncated];
}
function concatenateRelevantDiffs2(op, diffs, changeColor) {
  return diffs.reduce((reduced, diff22) => reduced + (diff22[0] === DIFF_EQUAL2 ? diff22[1] : diff22[0] === op && diff22[1].length !== 0 ? changeColor(diff22[1]) : ""), "");
}
var ChangeBuffer2 = class {
  constructor(op, changeColor) {
    __publicField(this, "op");
    __publicField(this, "line");
    __publicField(this, "lines");
    __publicField(this, "changeColor");
    this.op = op, this.line = [], this.lines = [], this.changeColor = changeColor;
  }
  pushSubstring(substring) {
    this.pushDiff(new Diff2(this.op, substring));
  }
  pushLine() {
    this.lines.push(this.line.length !== 1 ? new Diff2(this.op, concatenateRelevantDiffs2(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff2(this.op, this.line[0][1])), this.line.length = 0;
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  pushDiff(diff22) {
    this.line.push(diff22);
  }
  align(diff22) {
    let string = diff22[1];
    if (string.includes(`
`)) {
      let substrings = string.split(`
`), iLast = substrings.length - 1;
      substrings.forEach((substring, i4) => {
        i4 < iLast ? (this.pushSubstring(substring), this.pushLine()) : substring.length !== 0 && this.pushSubstring(substring);
      });
    } else this.pushDiff(diff22);
  }
  moveLinesTo(lines) {
    this.isLineEmpty() || this.pushLine(), lines.push(...this.lines), this.lines.length = 0;
  }
};
var CommonBuffer2 = class {
  constructor(deleteBuffer, insertBuffer) {
    __publicField(this, "deleteBuffer");
    __publicField(this, "insertBuffer");
    __publicField(this, "lines");
    this.deleteBuffer = deleteBuffer, this.insertBuffer = insertBuffer, this.lines = [];
  }
  pushDiffCommonLine(diff22) {
    this.lines.push(diff22);
  }
  pushDiffChangeLines(diff22) {
    let isDiffEmpty = diff22[1].length === 0;
    (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(diff22), (!isDiffEmpty || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(diff22);
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines);
  }
  align(diff22) {
    let op = diff22[0], string = diff22[1];
    if (string.includes(`
`)) {
      let substrings = string.split(`
`), iLast = substrings.length - 1;
      substrings.forEach((substring, i4) => {
        if (i4 === 0) {
          let subdiff = new Diff2(op, substring);
          this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty() ? (this.flushChangeLines(), this.pushDiffCommonLine(subdiff)) : (this.pushDiffChangeLines(subdiff), this.flushChangeLines());
        } else i4 < iLast ? this.pushDiffCommonLine(new Diff2(op, substring)) : substring.length !== 0 && this.pushDiffChangeLines(new Diff2(op, substring));
      });
    } else this.pushDiffChangeLines(diff22);
  }
  getLines() {
    return this.flushChangeLines(), this.lines;
  }
};
function getAlignedDiffs2(diffs, changeColor) {
  let deleteBuffer = new ChangeBuffer2(DIFF_DELETE2, changeColor), insertBuffer = new ChangeBuffer2(DIFF_INSERT2, changeColor), commonBuffer = new CommonBuffer2(deleteBuffer, insertBuffer);
  return diffs.forEach((diff22) => {
    switch (diff22[0]) {
      case DIFF_DELETE2:
        deleteBuffer.align(diff22);
        break;
      case DIFF_INSERT2:
        insertBuffer.align(diff22);
        break;
      default:
        commonBuffer.align(diff22);
    }
  }), commonBuffer.getLines();
}
function hasCommonDiff2(diffs, isMultiline) {
  if (isMultiline) {
    let iLast = diffs.length - 1;
    return diffs.some((diff22, i4) => diff22[0] === DIFF_EQUAL2 && (i4 !== iLast || diff22[1] !== `
`));
  }
  return diffs.some((diff22) => diff22[0] === DIFF_EQUAL2);
}
function diffStringsUnified2(a22, b6, options2) {
  if (a22 !== b6 && a22.length !== 0 && b6.length !== 0) {
    let isMultiline = a22.includes(`
`) || b6.includes(`
`), [diffs, truncated] = diffStringsRaw2(isMultiline ? `${a22}
` : a22, isMultiline ? `${b6}
` : b6, true, options2);
    if (hasCommonDiff2(diffs, isMultiline)) {
      let optionsNormalized = normalizeDiffOptions2(options2), lines = getAlignedDiffs2(diffs, optionsNormalized.changeColor);
      return printDiffLines2(lines, truncated, optionsNormalized);
    }
  }
  return diffLinesUnified3(a22.split(`
`), b6.split(`
`), options2);
}
function diffStringsRaw2(a22, b6, cleanup, options2) {
  let [diffs, truncated] = diffStrings2(a22, b6, options2);
  return cleanup && diff_cleanupSemantic2(diffs), [diffs, truncated];
}
function getCommonMessage2(message, options2) {
  let { commonColor } = normalizeDiffOptions2(options2);
  return commonColor(message);
}
var { AsymmetricMatcher: AsymmetricMatcher22, DOMCollection: DOMCollection22, DOMElement: DOMElement22, Immutable: Immutable22, ReactElement: ReactElement22, ReactTestComponent: ReactTestComponent22 } = plugins2;
var PLUGINS22 = [ReactTestComponent22, ReactElement22, DOMElement22, DOMCollection22, Immutable22, AsymmetricMatcher22];
var FORMAT_OPTIONS2 = { plugins: PLUGINS22 };
var FALLBACK_FORMAT_OPTIONS2 = { callToJSON: false, maxDepth: 10, plugins: PLUGINS22 };
function diff2(a22, b6, options2) {
  if (Object.is(a22, b6)) return "";
  let aType = getType32(a22), expectedType = aType, omitDifference = false;
  if (aType === "object" && typeof a22.asymmetricMatch == "function") {
    if (a22.$$typeof !== Symbol.for("jest.asymmetricMatcher") || typeof a22.getExpectedType != "function") return;
    expectedType = a22.getExpectedType(), omitDifference = expectedType === "string";
  }
  if (expectedType !== getType32(b6)) {
    let { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions2(options2), formatOptions = getFormatOptions2(FALLBACK_FORMAT_OPTIONS2, options2), aDisplay = format3(a22, formatOptions), bDisplay = format3(b6, formatOptions), aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} 
${aDisplay}`, bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} 
${bDisplay}`;
    return `${aDiff}

${bDiff}`;
  }
  if (!omitDifference) switch (aType) {
    case "string":
      return diffLinesUnified3(a22.split(`
`), b6.split(`
`), options2);
    case "boolean":
    case "number":
      return comparePrimitive2(a22, b6, options2);
    case "map":
      return compareObjects2(sortMap2(a22), sortMap2(b6), options2);
    case "set":
      return compareObjects2(sortSet2(a22), sortSet2(b6), options2);
    default:
      return compareObjects2(a22, b6, options2);
  }
}
function comparePrimitive2(a22, b6, options2) {
  let aFormat = format3(a22, FORMAT_OPTIONS2), bFormat = format3(b6, FORMAT_OPTIONS2);
  return aFormat === bFormat ? "" : diffLinesUnified3(aFormat.split(`
`), bFormat.split(`
`), options2);
}
function sortMap2(map) {
  return new Map(Array.from(map.entries()).sort());
}
function sortSet2(set2) {
  return new Set(Array.from(set2.values()).sort());
}
function compareObjects2(a22, b6, options2) {
  let difference, hasThrown = false;
  try {
    let formatOptions = getFormatOptions2(FORMAT_OPTIONS2, options2);
    difference = getObjectsDifference2(a22, b6, formatOptions, options2);
  } catch {
    hasThrown = true;
  }
  let noDiffMessage = getCommonMessage2(NO_DIFF_MESSAGE2, options2);
  if (difference === void 0 || difference === noDiffMessage) {
    let formatOptions = getFormatOptions2(FALLBACK_FORMAT_OPTIONS2, options2);
    difference = getObjectsDifference2(a22, b6, formatOptions, options2), difference !== noDiffMessage && !hasThrown && (difference = `${getCommonMessage2(SIMILAR_MESSAGE2, options2)}

${difference}`);
  }
  return difference;
}
function getFormatOptions2(formatOptions, options2) {
  let { compareKeys } = normalizeDiffOptions2(options2);
  return { ...formatOptions, compareKeys };
}
function getObjectsDifference2(a22, b6, formatOptions, options2) {
  let formatOptionsZeroIndent = { ...formatOptions, indent: 0 }, aCompare = format3(a22, formatOptionsZeroIndent), bCompare = format3(b6, formatOptionsZeroIndent);
  if (aCompare === bCompare) return getCommonMessage2(NO_DIFF_MESSAGE2, options2);
  {
    let aDisplay = format3(a22, formatOptions), bDisplay = format3(b6, formatOptions);
    return diffLinesUnified22(aDisplay.split(`
`), bDisplay.split(`
`), aCompare.split(`
`), bCompare.split(`
`), options2);
  }
}
var MAX_DIFF_STRING_LENGTH2 = 2e4;
function isAsymmetricMatcher2(data) {
  return getType4(data) === "Object" && typeof data.asymmetricMatch == "function";
}
function isReplaceable2(obj1, obj2) {
  let obj1Type = getType4(obj1), obj2Type = getType4(obj2);
  return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
}
function printDiffOrStringify2(expected, received, options2) {
  let { aAnnotation, bAnnotation } = normalizeDiffOptions2(options2);
  if (typeof expected == "string" && typeof received == "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH2 && received.length <= MAX_DIFF_STRING_LENGTH2 && expected !== received) {
    if (expected.includes(`
`) || received.includes(`
`)) return diffStringsUnified2(received, expected, options2);
    let [diffs] = diffStringsRaw2(received, expected, true), hasCommonDiff22 = diffs.some((diff22) => diff22[0] === DIFF_EQUAL2), printLabel = getLabelPrinter2(aAnnotation, bAnnotation), expectedLine = printLabel(aAnnotation) + printExpected2(getCommonAndChangedSubstrings2(diffs, DIFF_DELETE2, hasCommonDiff22)), receivedLine = printLabel(bAnnotation) + printReceived2(getCommonAndChangedSubstrings2(diffs, DIFF_INSERT2, hasCommonDiff22));
    return `${expectedLine}
${receivedLine}`;
  }
  let clonedExpected = deepClone2(expected, { forceWritable: true }), clonedReceived = deepClone2(received, { forceWritable: true }), { replacedExpected, replacedActual } = replaceAsymmetricMatcher2(clonedExpected, clonedReceived);
  return diff2(replacedExpected, replacedActual, options2);
}
function replaceAsymmetricMatcher2(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {
  return isReplaceable2(actual, expected) ? actualReplaced.has(actual) || expectedReplaced.has(expected) ? { replacedActual: actual, replacedExpected: expected } : (actualReplaced.add(actual), expectedReplaced.add(expected), getOwnProperties2(expected).forEach((key2) => {
    let expectedValue = expected[key2], actualValue = actual[key2];
    if (isAsymmetricMatcher2(expectedValue)) expectedValue.asymmetricMatch(actualValue) && (actual[key2] = expectedValue);
    else if (isAsymmetricMatcher2(actualValue)) actualValue.asymmetricMatch(expectedValue) && (expected[key2] = actualValue);
    else if (isReplaceable2(actualValue, expectedValue)) {
      let replaced = replaceAsymmetricMatcher2(actualValue, expectedValue, actualReplaced, expectedReplaced);
      actual[key2] = replaced.replacedActual, expected[key2] = replaced.replacedExpected;
    }
  }), { replacedActual: actual, replacedExpected: expected }) : { replacedActual: actual, replacedExpected: expected };
}
function getLabelPrinter2(...strings) {
  let maxLength = strings.reduce((max, string) => string.length > max ? string.length : max, 0);
  return (string) => `${string}: ${" ".repeat(maxLength - string.length)}`;
}
var SPACE_SYMBOL2 = "";
function replaceTrailingSpaces2(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL2.repeat(spaces.length));
}
function printReceived2(object) {
  return f23.red(replaceTrailingSpaces2(stringify2(object)));
}
function printExpected2(value2) {
  return f23.green(replaceTrailingSpaces2(stringify2(value2)));
}
function getCommonAndChangedSubstrings2(diffs, op, hasCommonDiff22) {
  return diffs.reduce((reduced, diff22) => reduced + (diff22[0] === DIFF_EQUAL2 ? diff22[1] : diff22[0] === op ? hasCommonDiff22 ? f23.inverse(diff22[1]) : diff22[1] : ""), "");
}
function d2(e2, t4) {
  if (!e2) throw new Error(t4);
}
function y3(e2, t4) {
  return typeof t4 === e2;
}
function w5(e2) {
  return e2 instanceof Promise;
}
function f32(e2, t4, n3) {
  Object.defineProperty(e2, t4, n3);
}
function p22(e2, t4, n3) {
  Object.defineProperty(e2, t4, { value: n3 });
}
var u4 = Symbol.for("tinyspy:spy");
var x6 = /* @__PURE__ */ new Set();
var P6 = (e2) => {
  e2.called = false, e2.callCount = 0, e2.calls = [], e2.results = [], e2.resolves = [], e2.next = [];
};
var K4 = (e2) => (f32(e2, u4, { value: { reset: () => P6(e2[u4]) } }), e2[u4]);
var I5 = (e2) => e2[u4] || K4(e2);
function g2(e2) {
  d2(y3("function", e2) || y3("undefined", e2), "cannot spy on a non-function value");
  let t4 = function(...s4) {
    let r4 = I5(t4);
    r4.called = true, r4.callCount++, r4.calls.push(s4);
    let R5 = r4.next.shift();
    if (R5) {
      r4.results.push(R5);
      let [o3, l3] = R5;
      if (o3 === "ok") return l3;
      throw l3;
    }
    let i4, c3 = "ok", a22 = r4.results.length;
    if (r4.impl) try {
      new.target ? i4 = Reflect.construct(r4.impl, s4, new.target) : i4 = r4.impl.apply(this, s4), c3 = "ok";
    } catch (o3) {
      throw i4 = o3, c3 = "error", r4.results.push([c3, o3]), o3;
    }
    let S5 = [c3, i4];
    return w5(i4) && i4.then((o3) => r4.resolves[a22] = ["ok", o3], (o3) => r4.resolves[a22] = ["error", o3]), r4.results.push(S5), i4;
  };
  p22(t4, "_isMockFunction", true), p22(t4, "length", e2 ? e2.length : 0), p22(t4, "name", e2 && e2.name || "spy");
  let n3 = I5(t4);
  return n3.reset(), n3.impl = e2, t4;
}
var k7 = (e2, t4) => Object.getOwnPropertyDescriptor(e2, t4);
var O6 = (e2, t4) => {
  t4 != null && typeof t4 == "function" && t4.prototype != null && Object.setPrototypeOf(e2.prototype, t4.prototype);
};
function C22(e2, t4, n3) {
  d2(!y3("undefined", e2), "spyOn could not find an object to spy upon"), d2(y3("object", e2) || y3("function", e2), "cannot spyOn on a primitive value");
  let [s4, r4] = (() => {
    if (!y3("object", t4)) return [t4, "value"];
    if ("getter" in t4 && "setter" in t4) throw new Error("cannot spy on both getter and setter");
    if ("getter" in t4) return [t4.getter, "get"];
    if ("setter" in t4) return [t4.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), R5 = k7(e2, s4), i4 = Object.getPrototypeOf(e2), c3 = i4 && k7(i4, s4), a22 = R5 || c3;
  d2(a22 || s4 in e2, `${String(s4)} does not exist`);
  let S5 = false;
  r4 === "value" && a22 && !a22.value && a22.get && (r4 = "get", S5 = true, n3 = a22.get());
  let o3;
  a22 ? o3 = a22[r4] : r4 !== "value" ? o3 = () => e2[s4] : o3 = e2[s4], n3 || (n3 = o3);
  let l3 = g2(n3);
  r4 === "value" && O6(l3, o3);
  let h22 = (A4) => {
    let { value: M6, ...v6 } = a22 || { configurable: true, writable: true };
    r4 !== "value" && delete v6.writable, v6[r4] = A4, f32(e2, s4, v6);
  }, b6 = () => a22 ? f32(e2, s4, a22) : h22(o3), m22 = l3[u4];
  return p22(m22, "restore", b6), p22(m22, "getOriginal", () => S5 ? o3() : o3), p22(m22, "willCall", (A4) => (m22.impl = A4, l3)), h22(S5 ? () => (O6(l3, n3), l3) : l3), x6.add(l3), l3;
}
var mocks = /* @__PURE__ */ new Set();
function isMockFunction(fn222) {
  return typeof fn222 == "function" && "_isMockFunction" in fn222 && fn222._isMockFunction;
}
function spyOn(obj, method, accessType) {
  let objMethod = accessType ? { [{ get: "getter", set: "setter" }[accessType]]: method } : method, stub = C22(obj, objMethod);
  return enhanceSpy(stub);
}
var callOrder = 0;
function enhanceSpy(spy) {
  let stub = spy, implementation, instances = [], contexts = [], invocations = [], state = I5(spy), mockContext = { get calls() {
    return state.calls;
  }, get contexts() {
    return contexts;
  }, get instances() {
    return instances;
  }, get invocationCallOrder() {
    return invocations;
  }, get results() {
    return state.results.map(([callType, value2]) => ({ type: callType === "error" ? "throw" : "return", value: value2 }));
  }, get settledResults() {
    return state.resolves.map(([callType, value2]) => ({ type: callType === "error" ? "rejected" : "fulfilled", value: value2 }));
  }, get lastCall() {
    return state.calls[state.calls.length - 1];
  } }, onceImplementations = [], implementationChangedTemporarily = false;
  function mockCall(...args2) {
    return instances.push(this), contexts.push(this), invocations.push(++callOrder), (implementationChangedTemporarily ? implementation : onceImplementations.shift() || implementation || state.getOriginal() || (() => {
    })).apply(this, args2);
  }
  let name2 = stub.name;
  stub.getMockName = () => name2 || "vi.fn()", stub.mockName = (n3) => (name2 = n3, stub), stub.mockClear = () => (state.reset(), instances = [], contexts = [], invocations = [], stub), stub.mockReset = () => (stub.mockClear(), implementation = () => {
  }, onceImplementations = [], stub), stub.mockRestore = () => (stub.mockReset(), state.restore(), implementation = void 0, stub), stub.getMockImplementation = () => implementation, stub.mockImplementation = (fn222) => (implementation = fn222, state.willCall(mockCall), stub), stub.mockImplementationOnce = (fn222) => (onceImplementations.push(fn222), stub);
  function withImplementation(fn222, cb) {
    let originalImplementation = implementation;
    implementation = fn222, state.willCall(mockCall), implementationChangedTemporarily = true;
    let reset = () => {
      implementation = originalImplementation, implementationChangedTemporarily = false;
    }, result2 = cb();
    return result2 instanceof Promise ? result2.then(() => (reset(), stub)) : (reset(), stub);
  }
  return stub.withImplementation = withImplementation, stub.mockReturnThis = () => stub.mockImplementation(function() {
    return this;
  }), stub.mockReturnValue = (val) => stub.mockImplementation(() => val), stub.mockReturnValueOnce = (val) => stub.mockImplementationOnce(() => val), stub.mockResolvedValue = (val) => stub.mockImplementation(() => Promise.resolve(val)), stub.mockResolvedValueOnce = (val) => stub.mockImplementationOnce(() => Promise.resolve(val)), stub.mockRejectedValue = (val) => stub.mockImplementation(() => Promise.reject(val)), stub.mockRejectedValueOnce = (val) => stub.mockImplementationOnce(() => Promise.reject(val)), Object.defineProperty(stub, "mock", { get: () => mockContext }), state.willCall(mockCall), mocks.add(stub), stub;
}
function fn2(implementation) {
  let enhancedSpy = enhanceSpy(C22({ spy: implementation || function() {
  } }, "spy"));
  return implementation && enhancedSpy.mockImplementation(implementation), enhancedSpy;
}
var IS_RECORD_SYMBOL2 = "@@__IMMUTABLE_RECORD__@@";
var IS_COLLECTION_SYMBOL2 = "@@__IMMUTABLE_ITERABLE__@@";
function isImmutable2(v6) {
  return v6 && (v6[IS_COLLECTION_SYMBOL2] || v6[IS_RECORD_SYMBOL2]);
}
var OBJECT_PROTO2 = Object.getPrototypeOf({});
function getUnserializableMessage2(err) {
  return err instanceof Error ? `<unserializable>: ${err.message}` : typeof err == "string" ? `<unserializable>: ${err}` : "<unserializable>";
}
function serializeValue2(val, seen = /* @__PURE__ */ new WeakMap()) {
  if (!val || typeof val == "string") return val;
  if (typeof val == "function") return `Function<${val.name || "anonymous"}>`;
  if (typeof val == "symbol") return val.toString();
  if (typeof val != "object") return val;
  if (isImmutable2(val)) return serializeValue2(val.toJSON(), seen);
  if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction") return "Promise";
  if (typeof Element < "u" && val instanceof Element) return val.tagName;
  if (typeof val.asymmetricMatch == "function") return `${val.toString()} ${format22(val.sample)}`;
  if (typeof val.toJSON == "function") return serializeValue2(val.toJSON(), seen);
  if (seen.has(val)) return seen.get(val);
  if (Array.isArray(val)) {
    let clone22 = new Array(val.length);
    return seen.set(val, clone22), val.forEach((e2, i4) => {
      try {
        clone22[i4] = serializeValue2(e2, seen);
      } catch (err) {
        clone22[i4] = getUnserializableMessage2(err);
      }
    }), clone22;
  } else {
    let clone22 = /* @__PURE__ */ Object.create(null);
    seen.set(val, clone22);
    let obj = val;
    for (; obj && obj !== OBJECT_PROTO2; ) Object.getOwnPropertyNames(obj).forEach((key2) => {
      if (!(key2 in clone22)) try {
        clone22[key2] = serializeValue2(val[key2], seen);
      } catch (err) {
        delete clone22[key2], clone22[key2] = getUnserializableMessage2(err);
      }
    }), obj = Object.getPrototypeOf(obj);
    return clone22;
  }
}
function normalizeErrorMessage2(message) {
  return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
function processError2(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {
  if (!_err || typeof _err != "object") return { message: String(_err) };
  let err = _err;
  err.stack && (err.stackStr = String(err.stack)), err.name && (err.nameStr = String(err.name)), (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) && (err.diff = printDiffOrStringify2(err.actual, err.expected, { ...diffOptions, ...err.diffOptions })), typeof err.expected != "string" && (err.expected = stringify2(err.expected, 10)), typeof err.actual != "string" && (err.actual = stringify2(err.actual, 10));
  try {
    typeof err.message == "string" && (err.message = normalizeErrorMessage2(err.message));
  } catch {
  }
  try {
    !seen.has(err) && typeof err.cause == "object" && (seen.add(err), err.cause = processError2(err.cause, diffOptions, seen));
  } catch {
  }
  try {
    return serializeValue2(err);
  } catch (e2) {
    return serializeValue2(new Error(`Failed to fully serialize error: ${e2 == null ? void 0 : e2.message}
Inner error message: ${err == null ? void 0 : err.message}`));
  }
}
var MATCHERS_OBJECT = Symbol.for("matchers-object");
var JEST_MATCHERS_OBJECT = Symbol.for("$$jest-matchers-object-storybook");
var GLOBAL_EXPECT = Symbol.for("expect-global");
var ASYMMETRIC_MATCHERS_OBJECT = Symbol.for("asymmetric-matchers-object");
if (!Object.prototype.hasOwnProperty.call(globalThis, MATCHERS_OBJECT)) {
  let globalState = /* @__PURE__ */ new WeakMap();
  Object.defineProperty(globalThis, MATCHERS_OBJECT, { get: () => globalState });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, JEST_MATCHERS_OBJECT)) {
  let matchers = /* @__PURE__ */ Object.create(null), customEqualityTesters = [];
  Object.defineProperty(globalThis, JEST_MATCHERS_OBJECT, { configurable: true, get: () => ({ state: globalThis[MATCHERS_OBJECT].get(globalThis[GLOBAL_EXPECT]), matchers, customEqualityTesters }) });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, ASYMMETRIC_MATCHERS_OBJECT)) {
  let assymetricMatchers = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(globalThis, ASYMMETRIC_MATCHERS_OBJECT, { get: () => assymetricMatchers });
}
function getState(expect4) {
  return globalThis[MATCHERS_OBJECT].get(expect4);
}
function setState(state, expect4) {
  let map = globalThis[MATCHERS_OBJECT], current = map.get(expect4) || {};
  Object.assign(current, state), map.set(expect4, current);
}
var EXPECTED_COLOR = f23.green;
var RECEIVED_COLOR = f23.red;
var INVERTED_COLOR = f23.inverse;
var BOLD_WEIGHT = f23.bold;
var DIM_COLOR = f23.dim;
function matcherHint(matcherName, received = "received", expected = "expected", options2 = {}) {
  let { comment = "", isDirectExpectCall = false, isNot = false, promise = "", secondArgument = "", expectedColor = EXPECTED_COLOR, receivedColor = RECEIVED_COLOR, secondArgumentColor = EXPECTED_COLOR } = options2, hint = "", dimString = "expect";
  return !isDirectExpectCall && received !== "" && (hint += DIM_COLOR(`${dimString}(`) + receivedColor(received), dimString = ")"), promise !== "" && (hint += DIM_COLOR(`${dimString}.`) + promise, dimString = ""), isNot && (hint += `${DIM_COLOR(`${dimString}.`)}not`, dimString = ""), matcherName.includes(".") ? dimString += matcherName : (hint += DIM_COLOR(`${dimString}.`) + matcherName, dimString = ""), expected === "" ? dimString += "()" : (hint += DIM_COLOR(`${dimString}(`) + expectedColor(expected), secondArgument && (hint += DIM_COLOR(", ") + secondArgumentColor(secondArgument)), dimString = ")"), comment !== "" && (dimString += ` // ${comment}`), dimString !== "" && (hint += DIM_COLOR(dimString)), hint;
}
var SPACE_SYMBOL22 = "";
function replaceTrailingSpaces22(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL22.repeat(spaces.length));
}
function printReceived22(object) {
  return RECEIVED_COLOR(replaceTrailingSpaces22(stringify2(object)));
}
function printExpected22(value2) {
  return EXPECTED_COLOR(replaceTrailingSpaces22(stringify2(value2)));
}
function getMatcherUtils() {
  return { EXPECTED_COLOR, RECEIVED_COLOR, INVERTED_COLOR, BOLD_WEIGHT, DIM_COLOR, diff: diff2, matcherHint, printReceived: printReceived22, printExpected: printExpected22, printDiffOrStringify: printDiffOrStringify2 };
}
function getCustomEqualityTesters() {
  return globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters;
}
function equals(a22, b6, customTesters, strictCheck) {
  return customTesters = customTesters || [], eq(a22, b6, [], [], customTesters, strictCheck ? hasKey : hasDefinedKey);
}
function isAsymmetric(obj) {
  return !!obj && typeof obj == "object" && "asymmetricMatch" in obj && isA("Function", obj.asymmetricMatch);
}
function asymmetricMatch(a22, b6) {
  let asymmetricA = isAsymmetric(a22), asymmetricB = isAsymmetric(b6);
  if (!(asymmetricA && asymmetricB)) {
    if (asymmetricA) return a22.asymmetricMatch(b6);
    if (asymmetricB) return b6.asymmetricMatch(a22);
  }
}
function eq(a22, b6, aStack, bStack, customTesters, hasKey2) {
  let result2 = true, asymmetricResult = asymmetricMatch(a22, b6);
  if (asymmetricResult !== void 0) return asymmetricResult;
  let testerContext = { equals };
  for (let i4 = 0; i4 < customTesters.length; i4++) {
    let customTesterResult = customTesters[i4].call(testerContext, a22, b6, customTesters);
    if (customTesterResult !== void 0) return customTesterResult;
  }
  if (a22 instanceof Error && b6 instanceof Error) return a22.message === b6.message;
  if (typeof URL == "function" && a22 instanceof URL && b6 instanceof URL) return a22.href === b6.href;
  if (Object.is(a22, b6)) return true;
  if (a22 === null || b6 === null) return a22 === b6;
  let className = Object.prototype.toString.call(a22);
  if (className !== Object.prototype.toString.call(b6)) return false;
  switch (className) {
    case "[object Boolean]":
    case "[object String]":
    case "[object Number]":
      return typeof a22 != typeof b6 ? false : typeof a22 != "object" && typeof b6 != "object" ? Object.is(a22, b6) : Object.is(a22.valueOf(), b6.valueOf());
    case "[object Date]": {
      let numA = +a22, numB = +b6;
      return numA === numB || Number.isNaN(numA) && Number.isNaN(numB);
    }
    case "[object RegExp]":
      return a22.source === b6.source && a22.flags === b6.flags;
  }
  if (typeof a22 != "object" || typeof b6 != "object") return false;
  if (isDomNode(a22) && isDomNode(b6)) return a22.isEqualNode(b6);
  let length = aStack.length;
  for (; length--; ) {
    if (aStack[length] === a22) return bStack[length] === b6;
    if (bStack[length] === b6) return false;
  }
  if (aStack.push(a22), bStack.push(b6), className === "[object Array]" && a22.length !== b6.length) return false;
  let aKeys = keys(a22, hasKey2), key2, size = aKeys.length;
  if (keys(b6, hasKey2).length !== size) return false;
  for (; size--; ) if (key2 = aKeys[size], result2 = hasKey2(b6, key2) && eq(a22[key2], b6[key2], aStack, bStack, customTesters, hasKey2), !result2) return false;
  return aStack.pop(), bStack.pop(), result2;
}
function keys(obj, hasKey2) {
  let keys2 = [];
  for (let key2 in obj) hasKey2(obj, key2) && keys2.push(key2);
  return keys2.concat(Object.getOwnPropertySymbols(obj).filter((symbol) => Object.getOwnPropertyDescriptor(obj, symbol).enumerable));
}
function hasDefinedKey(obj, key2) {
  return hasKey(obj, key2) && obj[key2] !== void 0;
}
function hasKey(obj, key2) {
  return Object.prototype.hasOwnProperty.call(obj, key2);
}
function isA(typeName, value2) {
  return Object.prototype.toString.apply(value2) === `[object ${typeName}]`;
}
function isDomNode(obj) {
  return obj !== null && typeof obj == "object" && "nodeType" in obj && typeof obj.nodeType == "number" && "nodeName" in obj && typeof obj.nodeName == "string" && "isEqualNode" in obj && typeof obj.isEqualNode == "function";
}
var IS_KEYED_SENTINEL22 = "@@__IMMUTABLE_KEYED__@@";
var IS_SET_SENTINEL22 = "@@__IMMUTABLE_SET__@@";
var IS_LIST_SENTINEL22 = "@@__IMMUTABLE_LIST__@@";
var IS_ORDERED_SENTINEL22 = "@@__IMMUTABLE_ORDERED__@@";
var IS_RECORD_SYMBOL22 = "@@__IMMUTABLE_RECORD__@@";
function isImmutableUnorderedKeyed(maybeKeyed) {
  return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL22] && !maybeKeyed[IS_ORDERED_SENTINEL22]);
}
function isImmutableUnorderedSet(maybeSet) {
  return !!(maybeSet && maybeSet[IS_SET_SENTINEL22] && !maybeSet[IS_ORDERED_SENTINEL22]);
}
function isObjectLiteral(source2) {
  return source2 != null && typeof source2 == "object" && !Array.isArray(source2);
}
function isImmutableList(source2) {
  return !!(source2 && isObjectLiteral(source2) && source2[IS_LIST_SENTINEL22]);
}
function isImmutableOrderedKeyed(source2) {
  return !!(source2 && isObjectLiteral(source2) && source2[IS_KEYED_SENTINEL22] && source2[IS_ORDERED_SENTINEL22]);
}
function isImmutableOrderedSet(source2) {
  return !!(source2 && isObjectLiteral(source2) && source2[IS_SET_SENTINEL22] && source2[IS_ORDERED_SENTINEL22]);
}
function isImmutableRecord(source2) {
  return !!(source2 && isObjectLiteral(source2) && source2[IS_RECORD_SYMBOL22]);
}
var IteratorSymbol = Symbol.iterator;
function hasIterator(object) {
  return !!(object != null && object[IteratorSymbol]);
}
function iterableEquality(a22, b6, customTesters = [], aStack = [], bStack = []) {
  if (typeof a22 != "object" || typeof b6 != "object" || Array.isArray(a22) || Array.isArray(b6) || !hasIterator(a22) || !hasIterator(b6)) return;
  if (a22.constructor !== b6.constructor) return false;
  let length = aStack.length;
  for (; length--; ) if (aStack[length] === a22) return bStack[length] === b6;
  aStack.push(a22), bStack.push(b6);
  let filteredCustomTesters = [...customTesters.filter((t4) => t4 !== iterableEquality), iterableEqualityWithStack];
  function iterableEqualityWithStack(a222, b22) {
    return iterableEquality(a222, b22, [...customTesters], [...aStack], [...bStack]);
  }
  if (a22.size !== void 0) {
    if (a22.size !== b6.size) return false;
    if (isA("Set", a22) || isImmutableUnorderedSet(a22)) {
      let allFound = true;
      for (let aValue of a22) if (!b6.has(aValue)) {
        let has = false;
        for (let bValue of b6) equals(aValue, bValue, filteredCustomTesters) === true && (has = true);
        if (has === false) {
          allFound = false;
          break;
        }
      }
      return aStack.pop(), bStack.pop(), allFound;
    } else if (isA("Map", a22) || isImmutableUnorderedKeyed(a22)) {
      let allFound = true;
      for (let aEntry of a22) if (!b6.has(aEntry[0]) || !equals(aEntry[1], b6.get(aEntry[0]), filteredCustomTesters)) {
        let has = false;
        for (let bEntry of b6) {
          let matchedKey = equals(aEntry[0], bEntry[0], filteredCustomTesters), matchedValue = false;
          matchedKey === true && (matchedValue = equals(aEntry[1], bEntry[1], filteredCustomTesters)), matchedValue === true && (has = true);
        }
        if (has === false) {
          allFound = false;
          break;
        }
      }
      return aStack.pop(), bStack.pop(), allFound;
    }
  }
  let bIterator = b6[IteratorSymbol]();
  for (let aValue of a22) {
    let nextB = bIterator.next();
    if (nextB.done || !equals(aValue, nextB.value, filteredCustomTesters)) return false;
  }
  if (!bIterator.next().done) return false;
  if (!isImmutableList(a22) && !isImmutableOrderedKeyed(a22) && !isImmutableOrderedSet(a22) && !isImmutableRecord(a22)) {
    let aEntries = Object.entries(a22), bEntries = Object.entries(b6);
    if (!equals(aEntries, bEntries)) return false;
  }
  return aStack.pop(), bStack.pop(), true;
}
function hasPropertyInObject(object, key2) {
  return !object || typeof object != "object" || object === Object.prototype ? false : Object.prototype.hasOwnProperty.call(object, key2) || hasPropertyInObject(Object.getPrototypeOf(object), key2);
}
function isObjectWithKeys(a22) {
  return isObject2(a22) && !(a22 instanceof Error) && !Array.isArray(a22) && !(a22 instanceof Date);
}
function subsetEquality(object, subset, customTesters = []) {
  let filteredCustomTesters = customTesters.filter((t4) => t4 !== subsetEquality), subsetEqualityWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object2, subset2) => {
    if (isObjectWithKeys(subset2)) return Object.keys(subset2).every((key2) => {
      if (subset2[key2] != null && typeof subset2[key2] == "object") {
        if (seenReferences.has(subset2[key2])) return equals(object2[key2], subset2[key2], filteredCustomTesters);
        seenReferences.set(subset2[key2], true);
      }
      let result2 = object2 != null && hasPropertyInObject(object2, key2) && equals(object2[key2], subset2[key2], [...filteredCustomTesters, subsetEqualityWithContext(seenReferences)]);
      return seenReferences.delete(subset2[key2]), result2;
    });
  };
  return subsetEqualityWithContext()(object, subset);
}
function typeEquality(a22, b6) {
  if (!(a22 == null || b6 == null || a22.constructor === b6.constructor)) return false;
}
function arrayBufferEquality(a22, b6) {
  let dataViewA = a22, dataViewB = b6;
  if (!(a22 instanceof DataView && b6 instanceof DataView)) {
    if (!(a22 instanceof ArrayBuffer) || !(b6 instanceof ArrayBuffer)) return;
    try {
      dataViewA = new DataView(a22), dataViewB = new DataView(b6);
    } catch {
      return;
    }
  }
  if (dataViewA.byteLength !== dataViewB.byteLength) return false;
  for (let i4 = 0; i4 < dataViewA.byteLength; i4++) if (dataViewA.getUint8(i4) !== dataViewB.getUint8(i4)) return false;
  return true;
}
function sparseArrayEquality(a22, b6, customTesters = []) {
  if (!Array.isArray(a22) || !Array.isArray(b6)) return;
  let aKeys = Object.keys(a22), bKeys = Object.keys(b6), filteredCustomTesters = customTesters.filter((t4) => t4 !== sparseArrayEquality);
  return equals(a22, b6, filteredCustomTesters, true) && equals(aKeys, bKeys);
}
function generateToBeMessage(deepEqualityName, expected = "#{this}", actual = "#{exp}") {
  let toBeMessage = `expected ${expected} to be ${actual} // Object.is equality`;
  return ["toStrictEqual", "toEqual"].includes(deepEqualityName) ? `${toBeMessage}

If it should pass with deep equality, replace "toBe" with "${deepEqualityName}"

Expected: ${expected}
Received: serializes to the same string
` : toBeMessage;
}
function pluralize(word, count) {
  return `${count} ${word}${count === 1 ? "" : "s"}`;
}
function getObjectKeys(object) {
  return [...Object.keys(object), ...Object.getOwnPropertySymbols(object).filter((s4) => {
    var _a2;
    return (_a2 = Object.getOwnPropertyDescriptor(object, s4)) == null ? void 0 : _a2.enumerable;
  })];
}
function getObjectSubset(object, subset, customTesters = []) {
  let stripped = 0, getObjectSubsetWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object2, subset2) => {
    if (Array.isArray(object2)) {
      if (Array.isArray(subset2) && subset2.length === object2.length) return subset2.map((sub, i4) => getObjectSubsetWithContext(seenReferences)(object2[i4], sub));
    } else {
      if (object2 instanceof Date) return object2;
      if (isObject2(object2) && isObject2(subset2)) {
        if (equals(object2, subset2, [...customTesters, iterableEquality, subsetEquality])) return subset2;
        let trimmed = {};
        seenReferences.set(object2, trimmed);
        for (let key2 of getObjectKeys(object2)) hasPropertyInObject(subset2, key2) ? trimmed[key2] = seenReferences.has(object2[key2]) ? seenReferences.get(object2[key2]) : getObjectSubsetWithContext(seenReferences)(object2[key2], subset2[key2]) : seenReferences.has(object2[key2]) || (stripped += 1, isObject2(object2[key2]) && (stripped += getObjectKeys(object2[key2]).length), getObjectSubsetWithContext(seenReferences)(object2[key2], subset2[key2]));
        if (getObjectKeys(trimmed).length > 0) return trimmed;
      }
    }
    return object2;
  };
  return { subset: getObjectSubsetWithContext()(object, subset), stripped };
}
var AsymmetricMatcher32 = class {
  constructor(sample, inverse = false) {
    __publicField(this, "$$typeof", Symbol.for("jest.asymmetricMatcher"));
    this.sample = sample, this.inverse = inverse;
  }
  getMatcherContext(expect4) {
    return { ...getState(expect4 || globalThis[GLOBAL_EXPECT]), equals, isNot: this.inverse, customTesters: getCustomEqualityTesters(), utils: { ...getMatcherUtils(), diff: diff2, stringify: stringify2, iterableEquality, subsetEquality } };
  }
  [Symbol.for("chai/inspect")](options2) {
    let result2 = stringify2(this, options2.depth, { min: true });
    return result2.length <= options2.truncate ? result2 : `${this.toString()}{}`;
  }
};
var StringContaining = class extends AsymmetricMatcher32 {
  constructor(sample, inverse = false) {
    if (!isA("String", sample)) throw new Error("Expected is not a string");
    super(sample, inverse);
  }
  asymmetricMatch(other) {
    let result2 = isA("String", other) && other.includes(this.sample);
    return this.inverse ? !result2 : result2;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "string";
  }
};
var Anything = class extends AsymmetricMatcher32 {
  asymmetricMatch(other) {
    return other != null;
  }
  toString() {
    return "Anything";
  }
  toAsymmetricMatcher() {
    return "Anything";
  }
};
var ObjectContaining = class extends AsymmetricMatcher32 {
  constructor(sample, inverse = false) {
    super(sample, inverse);
  }
  getPrototype(obj) {
    return Object.getPrototypeOf ? Object.getPrototypeOf(obj) : obj.constructor.prototype === obj ? null : obj.constructor.prototype;
  }
  hasProperty(obj, property) {
    return obj ? Object.prototype.hasOwnProperty.call(obj, property) ? true : this.hasProperty(this.getPrototype(obj), property) : false;
  }
  asymmetricMatch(other) {
    if (typeof this.sample != "object") throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);
    let result2 = true, matcherContext = this.getMatcherContext();
    for (let property in this.sample) if (!this.hasProperty(other, property) || !equals(this.sample[property], other[property], matcherContext.customTesters)) {
      result2 = false;
      break;
    }
    return this.inverse ? !result2 : result2;
  }
  toString() {
    return `Object${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "object";
  }
};
var ArrayContaining = class extends AsymmetricMatcher32 {
  constructor(sample, inverse = false) {
    super(sample, inverse);
  }
  asymmetricMatch(other) {
    if (!Array.isArray(this.sample)) throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);
    let matcherContext = this.getMatcherContext(), result2 = this.sample.length === 0 || Array.isArray(other) && this.sample.every((item) => other.some((another) => equals(item, another, matcherContext.customTesters)));
    return this.inverse ? !result2 : result2;
  }
  toString() {
    return `Array${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "array";
  }
};
var Any = class extends AsymmetricMatcher32 {
  constructor(sample) {
    if (typeof sample > "u") throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");
    super(sample);
  }
  fnNameFor(func) {
    if (func.name) return func.name;
    let matches3 = Function.prototype.toString.call(func).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
    return matches3 ? matches3[1] : "<anonymous>";
  }
  asymmetricMatch(other) {
    return this.sample === String ? typeof other == "string" || other instanceof String : this.sample === Number ? typeof other == "number" || other instanceof Number : this.sample === Function ? typeof other == "function" || other instanceof Function : this.sample === Boolean ? typeof other == "boolean" || other instanceof Boolean : this.sample === BigInt ? typeof other == "bigint" || other instanceof BigInt : this.sample === Symbol ? typeof other == "symbol" || other instanceof Symbol : this.sample === Object ? typeof other == "object" : other instanceof this.sample;
  }
  toString() {
    return "Any";
  }
  getExpectedType() {
    return this.sample === String ? "string" : this.sample === Number ? "number" : this.sample === Function ? "function" : this.sample === Object ? "object" : this.sample === Boolean ? "boolean" : this.fnNameFor(this.sample);
  }
  toAsymmetricMatcher() {
    return `Any<${this.fnNameFor(this.sample)}>`;
  }
};
var StringMatching = class extends AsymmetricMatcher32 {
  constructor(sample, inverse = false) {
    if (!isA("String", sample) && !isA("RegExp", sample)) throw new Error("Expected is not a String or a RegExp");
    super(new RegExp(sample), inverse);
  }
  asymmetricMatch(other) {
    let result2 = isA("String", other) && this.sample.test(other);
    return this.inverse ? !result2 : result2;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Matching`;
  }
  getExpectedType() {
    return "string";
  }
};
var CloseTo = class extends AsymmetricMatcher32 {
  constructor(sample, precision = 2, inverse = false) {
    if (!isA("Number", sample)) throw new Error("Expected is not a Number");
    if (!isA("Number", precision)) throw new Error("Precision is not a Number");
    super(sample);
    __publicField(this, "precision");
    this.inverse = inverse, this.precision = precision;
  }
  asymmetricMatch(other) {
    if (!isA("Number", other)) return false;
    let result2 = false;
    return other === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY || other === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY ? result2 = true : result2 = Math.abs(this.sample - other) < 10 ** -this.precision / 2, this.inverse ? !result2 : result2;
  }
  toString() {
    return `Number${this.inverse ? "Not" : ""}CloseTo`;
  }
  getExpectedType() {
    return "number";
  }
  toAsymmetricMatcher() {
    return [this.toString(), this.sample, `(${pluralize("digit", this.precision)})`].join(" ");
  }
};
var JestAsymmetricMatchers = (chai, utils) => {
  utils.addMethod(chai.expect, "anything", () => new Anything()), utils.addMethod(chai.expect, "any", (expected) => new Any(expected)), utils.addMethod(chai.expect, "stringContaining", (expected) => new StringContaining(expected)), utils.addMethod(chai.expect, "objectContaining", (expected) => new ObjectContaining(expected)), utils.addMethod(chai.expect, "arrayContaining", (expected) => new ArrayContaining(expected)), utils.addMethod(chai.expect, "stringMatching", (expected) => new StringMatching(expected)), utils.addMethod(chai.expect, "closeTo", (expected, precision) => new CloseTo(expected, precision)), chai.expect.not = { stringContaining: (expected) => new StringContaining(expected, true), objectContaining: (expected) => new ObjectContaining(expected, true), arrayContaining: (expected) => new ArrayContaining(expected, true), stringMatching: (expected) => new StringMatching(expected, true), closeTo: (expected, precision) => new CloseTo(expected, precision, true) };
};
function recordAsyncExpect(test3, promise) {
  return test3 && promise instanceof Promise && (promise = promise.finally(() => {
    let index = test3.promises.indexOf(promise);
    index !== -1 && test3.promises.splice(index, 1);
  }), test3.promises || (test3.promises = []), test3.promises.push(promise)), promise;
}
function wrapSoft(utils, fn3) {
  return function(...args2) {
    var _a2;
    if (!utils.flag(this, "soft")) return fn3.apply(this, args2);
    let test3 = utils.flag(this, "vitest-test");
    if (!test3) throw new Error("expect.soft() can only be used inside a test");
    try {
      return fn3.apply(this, args2);
    } catch (err) {
      test3.result || (test3.result = { state: "fail" }), test3.result.state = "fail", (_a2 = test3.result).errors || (_a2.errors = []), test3.result.errors.push(processError2(err));
    }
  };
}
var JestChaiExpect = (chai, utils) => {
  let { AssertionError: AssertionError2 } = chai, customTesters = getCustomEqualityTesters();
  function def(name2, fn3) {
    let addMethod2 = (n3) => {
      let softWrapper = wrapSoft(utils, fn3);
      utils.addMethod(chai.Assertion.prototype, n3, softWrapper), utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, n3, softWrapper);
    };
    Array.isArray(name2) ? name2.forEach((n3) => addMethod2(n3)) : addMethod2(name2);
  }
  ["throw", "throws", "Throw"].forEach((m22) => {
    utils.overwriteMethod(chai.Assertion.prototype, m22, (_super) => function(...args2) {
      let promise = utils.flag(this, "promise"), object = utils.flag(this, "object"), isNot = utils.flag(this, "negate");
      if (promise === "rejects") utils.flag(this, "object", () => {
        throw object;
      });
      else if (promise === "resolves" && typeof object != "function") {
        if (isNot) return;
        {
          let message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't", error = { showDiff: false };
          throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
        }
      }
      _super.apply(this, args2);
    });
  }), def("withTest", function(test3) {
    return utils.flag(this, "vitest-test", test3), this;
  }), def("toEqual", function(expected) {
    let actual = utils.flag(this, "object"), equal = equals(actual, expected, [...customTesters, iterableEquality]);
    return this.assert(equal, "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", expected, actual);
  }), def("toStrictEqual", function(expected) {
    let obj = utils.flag(this, "object"), equal = equals(obj, expected, [...customTesters, iterableEquality, typeEquality, sparseArrayEquality, arrayBufferEquality], true);
    return this.assert(equal, "expected #{this} to strictly equal #{exp}", "expected #{this} to not strictly equal #{exp}", expected, obj);
  }), def("toBe", function(expected) {
    let actual = this._obj, pass = Object.is(actual, expected), deepEqualityName = "";
    return pass || (equals(actual, expected, [...customTesters, iterableEquality, typeEquality, sparseArrayEquality, arrayBufferEquality], true) ? deepEqualityName = "toStrictEqual" : equals(actual, expected, [...customTesters, iterableEquality]) && (deepEqualityName = "toEqual")), this.assert(pass, generateToBeMessage(deepEqualityName), "expected #{this} not to be #{exp} // Object.is equality", expected, actual);
  }), def("toMatchObject", function(expected) {
    let actual = this._obj, pass = equals(actual, expected, [...customTesters, iterableEquality, subsetEquality]), isNot = utils.flag(this, "negate"), { subset: actualSubset, stripped } = getObjectSubset(actual, expected);
    if (pass && isNot || !pass && !isNot) {
      let msg = utils.getMessage(this, [pass, "expected #{this} to match object #{exp}", "expected #{this} to not match object #{exp}", expected, actualSubset, false]), message = stripped === 0 ? msg : `${msg}
(${stripped} matching ${stripped === 1 ? "property" : "properties"} omitted from actual)`;
      throw new AssertionError2(message, { showDiff: true, expected, actual: actualSubset });
    }
  }), def("toMatch", function(expected) {
    let actual = this._obj;
    if (typeof actual != "string") throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof actual}`);
    return this.assert(typeof expected == "string" ? actual.includes(expected) : actual.match(expected), "expected #{this} to match #{exp}", "expected #{this} not to match #{exp}", expected, actual);
  }), def("toContain", function(item) {
    let actual = this._obj;
    if (typeof Node < "u" && actual instanceof Node) {
      if (!(item instanceof Node)) throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof item}`);
      return this.assert(actual.contains(item), "expected #{this} to contain element #{exp}", "expected #{this} not to contain element #{exp}", item, actual);
    }
    if (typeof DOMTokenList < "u" && actual instanceof DOMTokenList) {
      assertTypes(item, "class name", ["string"]);
      let expectedClassList = utils.flag(this, "negate") ? actual.value.replace(item, "").trim() : `${actual.value} ${item}`;
      return this.assert(actual.contains(item), `expected "${actual.value}" to contain "${item}"`, `expected "${actual.value}" not to contain "${item}"`, expectedClassList, actual.value);
    }
    return typeof actual == "string" && typeof item == "string" ? this.assert(actual.includes(item), "expected #{this} to contain #{exp}", "expected #{this} not to contain #{exp}", item, actual) : (actual != null && typeof actual != "string" && utils.flag(this, "object", Array.from(actual)), this.contain(item));
  }), def("toContainEqual", function(expected) {
    let obj = utils.flag(this, "object"), index = Array.from(obj).findIndex((item) => equals(item, expected, customTesters));
    this.assert(index !== -1, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", expected);
  }), def("toBeTruthy", function() {
    let obj = utils.flag(this, "object");
    this.assert(!!obj, "expected #{this} to be truthy", "expected #{this} to not be truthy", obj, false);
  }), def("toBeFalsy", function() {
    let obj = utils.flag(this, "object");
    this.assert(!obj, "expected #{this} to be falsy", "expected #{this} to not be falsy", obj, false);
  }), def("toBeGreaterThan", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual > expected, `expected ${actual} to be greater than ${expected}`, `expected ${actual} to be not greater than ${expected}`, actual, expected, false);
  }), def("toBeGreaterThanOrEqual", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual >= expected, `expected ${actual} to be greater than or equal to ${expected}`, `expected ${actual} to be not greater than or equal to ${expected}`, actual, expected, false);
  }), def("toBeLessThan", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual < expected, `expected ${actual} to be less than ${expected}`, `expected ${actual} to be not less than ${expected}`, actual, expected, false);
  }), def("toBeLessThanOrEqual", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual <= expected, `expected ${actual} to be less than or equal to ${expected}`, `expected ${actual} to be not less than or equal to ${expected}`, actual, expected, false);
  }), def("toBeNaN", function() {
    return this.be.NaN;
  }), def("toBeUndefined", function() {
    return this.be.undefined;
  }), def("toBeNull", function() {
    return this.be.null;
  }), def("toBeDefined", function() {
    let negate = utils.flag(this, "negate");
    return utils.flag(this, "negate", false), negate ? this.be.undefined : this.not.be.undefined;
  }), def("toBeTypeOf", function(expected) {
    let actual = typeof this._obj, equal = expected === actual;
    return this.assert(equal, "expected #{this} to be type of #{exp}", "expected #{this} not to be type of #{exp}", expected, actual);
  }), def("toBeInstanceOf", function(obj) {
    return this.instanceOf(obj);
  }), def("toHaveLength", function(length) {
    return this.have.length(length);
  }), def("toHaveProperty", function(...args2) {
    Array.isArray(args2[0]) && (args2[0] = args2[0].map((key2) => String(key2).replace(/([.[\]])/g, "\\$1")).join("."));
    let actual = this._obj, [propertyName, expected] = args2, getValue = () => Object.prototype.hasOwnProperty.call(actual, propertyName) ? { value: actual[propertyName], exists: true } : utils.getPathInfo(actual, propertyName), { value: value2, exists } = getValue(), pass = exists && (args2.length === 1 || equals(expected, value2, customTesters)), valueString = args2.length === 1 ? "" : ` with value ${utils.objDisplay(expected)}`;
    return this.assert(pass, `expected #{this} to have property "${propertyName}"${valueString}`, `expected #{this} to not have property "${propertyName}"${valueString}`, expected, exists ? value2 : void 0);
  }), def("toBeCloseTo", function(received, precision = 2) {
    let expected = this._obj, pass = false, expectedDiff2 = 0, receivedDiff = 0;
    return received === Number.POSITIVE_INFINITY && expected === Number.POSITIVE_INFINITY || received === Number.NEGATIVE_INFINITY && expected === Number.NEGATIVE_INFINITY ? pass = true : (expectedDiff2 = 10 ** -precision / 2, receivedDiff = Math.abs(expected - received), pass = receivedDiff < expectedDiff2), this.assert(pass, `expected #{this} to be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff2}`, `expected #{this} to not be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff2}`, received, expected, false);
  });
  let assertIsMock = (assertion) => {
    if (!isMockFunction(assertion._obj)) throw new TypeError(`${utils.inspect(assertion._obj)} is not a spy or a call to a spy!`);
  }, getSpy = (assertion) => (assertIsMock(assertion), assertion._obj), ordinalOf = (i4) => {
    let j2 = i4 % 10, k22 = i4 % 100;
    return j2 === 1 && k22 !== 11 ? `${i4}st` : j2 === 2 && k22 !== 12 ? `${i4}nd` : j2 === 3 && k22 !== 13 ? `${i4}rd` : `${i4}th`;
  }, formatCalls = (spy, msg, showActualCall) => (spy.mock.calls && (msg += f23.gray(`

Received: 

${spy.mock.calls.map((callArg, i4) => {
    let methodCall = f23.bold(`  ${ordinalOf(i4 + 1)} ${spy.getMockName()} call:

`);
    return showActualCall ? methodCall += diff2(showActualCall, callArg, { omitAnnotationLines: true }) : methodCall += stringify2(callArg).split(`
`).map((line) => `    ${line}`).join(`
`), methodCall += `
`, methodCall;
  }).join(`
`)}`)), msg += f23.gray(`

Number of calls: ${f23.bold(spy.mock.calls.length)}
`), msg), formatReturns = (spy, results, msg, showActualReturn) => (msg += f23.gray(`

Received: 

${results.map((callReturn, i4) => {
    let methodCall = f23.bold(`  ${ordinalOf(i4 + 1)} ${spy.getMockName()} call return:

`);
    return showActualReturn ? methodCall += diff2(showActualReturn, callReturn.value, { omitAnnotationLines: true }) : methodCall += stringify2(callReturn).split(`
`).map((line) => `    ${line}`).join(`
`), methodCall += `
`, methodCall;
  }).join(`
`)}`), msg += f23.gray(`

Number of calls: ${f23.bold(spy.mock.calls.length)}
`), msg);
  def(["toHaveBeenCalledTimes", "toBeCalledTimes"], function(number) {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length;
    return this.assert(callCount === number, `expected "${spyName}" to be called #{exp} times, but got ${callCount} times`, `expected "${spyName}" to not be called #{exp} times`, number, callCount, false);
  }), def("toHaveBeenCalledOnce", function() {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length;
    return this.assert(callCount === 1, `expected "${spyName}" to be called once, but got ${callCount} times`, `expected "${spyName}" to not be called once`, 1, callCount, false);
  }), def(["toHaveBeenCalled", "toBeCalled"], function() {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length, called = callCount > 0, isNot = utils.flag(this, "negate"), msg = utils.getMessage(this, [called, `expected "${spyName}" to be called at least once`, `expected "${spyName}" to not be called at all, but actually been called ${callCount} times`, true, called]);
    if (called && isNot && (msg = formatCalls(spy, msg)), called && isNot || !called && !isNot) throw new AssertionError2(msg);
  }), def(["toHaveBeenCalledWith", "toBeCalledWith"], function(...args2) {
    let spy = getSpy(this), spyName = spy.getMockName(), pass = spy.mock.calls.some((callArg) => equals(callArg, args2, [...customTesters, iterableEquality])), isNot = utils.flag(this, "negate"), msg = utils.getMessage(this, [pass, `expected "${spyName}" to be called with arguments: #{exp}`, `expected "${spyName}" to not be called with arguments: #{exp}`, args2]);
    if (pass && isNot || !pass && !isNot) throw new AssertionError2(formatCalls(spy, msg, args2));
  }), def(["toHaveBeenNthCalledWith", "nthCalledWith"], function(times, ...args2) {
    let spy = getSpy(this), spyName = spy.getMockName(), nthCall = spy.mock.calls[times - 1], callCount = spy.mock.calls.length, isCalled = times <= callCount;
    this.assert(equals(nthCall, args2, [...customTesters, iterableEquality]), `expected ${ordinalOf(times)} "${spyName}" call to have been called with #{exp}${isCalled ? "" : `, but called only ${callCount} times`}`, `expected ${ordinalOf(times)} "${spyName}" call to not have been called with #{exp}`, args2, nthCall, isCalled);
  }), def(["toHaveBeenLastCalledWith", "lastCalledWith"], function(...args2) {
    let spy = getSpy(this), spyName = spy.getMockName(), lastCall = spy.mock.calls[spy.mock.calls.length - 1];
    this.assert(equals(lastCall, args2, [...customTesters, iterableEquality]), `expected last "${spyName}" call to have been called with #{exp}`, `expected last "${spyName}" call to not have been called with #{exp}`, args2, lastCall);
  }), def(["toThrow", "toThrowError"], function(expected) {
    if (typeof expected == "string" || typeof expected > "u" || expected instanceof RegExp) return this.throws(expected);
    let obj = this._obj, promise = utils.flag(this, "promise"), isNot = utils.flag(this, "negate"), thrown = null;
    if (promise === "rejects") thrown = obj;
    else if (promise === "resolves" && typeof obj != "function") {
      if (isNot) return;
      {
        let message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't", error = { showDiff: false };
        throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
      }
    } else {
      let isThrow = false;
      try {
        obj();
      } catch (err) {
        isThrow = true, thrown = err;
      }
      if (!isThrow && !isNot) {
        let message = utils.flag(this, "message") || "expected function to throw an error, but it didn't", error = { showDiff: false };
        throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
      }
    }
    if (typeof expected == "function") {
      let name2 = expected.name || expected.prototype.constructor.name;
      return this.assert(thrown && thrown instanceof expected, `expected error to be instance of ${name2}`, `expected error not to be instance of ${name2}`, expected, thrown);
    }
    if (expected instanceof Error) return this.assert(thrown && expected.message === thrown.message, `expected error to have message: ${expected.message}`, `expected error not to have message: ${expected.message}`, expected.message, thrown && thrown.message);
    if (typeof expected == "object" && "asymmetricMatch" in expected && typeof expected.asymmetricMatch == "function") {
      let matcher = expected;
      return this.assert(thrown && matcher.asymmetricMatch(thrown), "expected error to match asymmetric matcher", "expected error not to match asymmetric matcher", matcher, thrown);
    }
    throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof expected}"`);
  }), [{ name: "toHaveResolved", condition: (spy) => spy.mock.settledResults.length > 0 && spy.mock.settledResults.some(({ type: type5 }) => type5 === "fulfilled"), action: "resolved" }, { name: ["toHaveReturned", "toReturn"], condition: (spy) => spy.mock.calls.length > 0 && spy.mock.results.some(({ type: type5 }) => type5 !== "throw"), action: "called" }].forEach(({ name: name2, condition, action }) => {
    def(name2, function() {
      let spy = getSpy(this), spyName = spy.getMockName(), pass = condition(spy);
      this.assert(pass, `expected "${spyName}" to be successfully ${action} at least once`, `expected "${spyName}" to not be successfully ${action}`, pass, !pass, false);
    });
  }), [{ name: "toHaveResolvedTimes", condition: (spy, times) => spy.mock.settledResults.reduce((s4, { type: type5 }) => type5 === "fulfilled" ? ++s4 : s4, 0) === times, action: "resolved" }, { name: ["toHaveReturnedTimes", "toReturnTimes"], condition: (spy, times) => spy.mock.results.reduce((s4, { type: type5 }) => type5 === "throw" ? s4 : ++s4, 0) === times, action: "called" }].forEach(({ name: name2, condition, action }) => {
    def(name2, function(times) {
      let spy = getSpy(this), spyName = spy.getMockName(), pass = condition(spy, times);
      this.assert(pass, `expected "${spyName}" to be successfully ${action} ${times} times`, `expected "${spyName}" to not be successfully ${action} ${times} times`, `expected resolved times: ${times}`, `received resolved times: ${pass}`, false);
    });
  }), [{ name: "toHaveResolvedWith", condition: (spy, value2) => spy.mock.settledResults.some(({ type: type5, value: result2 }) => type5 === "fulfilled" && equals(value2, result2)), action: "resolve" }, { name: ["toHaveReturnedWith", "toReturnWith"], condition: (spy, value2) => spy.mock.results.some(({ type: type5, value: result2 }) => type5 === "return" && equals(value2, result2)), action: "return" }].forEach(({ name: name2, condition, action }) => {
    def(name2, function(value2) {
      let spy = getSpy(this), pass = condition(spy, value2), isNot = utils.flag(this, "negate");
      if (pass && isNot || !pass && !isNot) {
        let spyName = spy.getMockName(), msg = utils.getMessage(this, [pass, `expected "${spyName}" to ${action} with: #{exp} at least once`, `expected "${spyName}" to not ${action} with: #{exp}`, value2]), results = action === "return" ? spy.mock.results : spy.mock.settledResults;
        throw new AssertionError2(formatReturns(spy, results, msg, value2));
      }
    });
  }), [{ name: "toHaveLastResolvedWith", condition: (spy, value2) => {
    let result2 = spy.mock.settledResults[spy.mock.settledResults.length - 1];
    return result2 && result2.type === "fulfilled" && equals(result2.value, value2);
  }, action: "resolve" }, { name: ["toHaveLastReturnedWith", "lastReturnedWith"], condition: (spy, value2) => {
    let result2 = spy.mock.results[spy.mock.results.length - 1];
    return result2 && result2.type === "return" && equals(result2.value, value2);
  }, action: "return" }].forEach(({ name: name2, condition, action }) => {
    def(name2, function(value2) {
      let spy = getSpy(this), results = action === "return" ? spy.mock.results : spy.mock.settledResults, result2 = results[results.length - 1], spyName = spy.getMockName();
      this.assert(condition(spy, value2), `expected last "${spyName}" call to ${action} #{exp}`, `expected last "${spyName}" call to not ${action} #{exp}`, value2, result2 == null ? void 0 : result2.value);
    });
  }), [{ name: "toHaveNthResolvedWith", condition: (spy, index, value2) => {
    let result2 = spy.mock.settledResults[index - 1];
    return result2 && result2.type === "fulfilled" && equals(result2.value, value2);
  }, action: "resolve" }, { name: ["toHaveNthReturnedWith", "nthReturnedWith"], condition: (spy, index, value2) => {
    let result2 = spy.mock.results[index - 1];
    return result2 && result2.type === "return" && equals(result2.value, value2);
  }, action: "return" }].forEach(({ name: name2, condition, action }) => {
    def(name2, function(nthCall, value2) {
      let spy = getSpy(this), spyName = spy.getMockName(), result2 = (action === "return" ? spy.mock.results : spy.mock.settledResults)[nthCall - 1], ordinalCall = `${ordinalOf(nthCall)} call`;
      this.assert(condition(spy, nthCall, value2), `expected ${ordinalCall} "${spyName}" call to ${action} #{exp}`, `expected ${ordinalCall} "${spyName}" call to not ${action} #{exp}`, value2, result2 == null ? void 0 : result2.value);
    });
  }), def("toSatisfy", function(matcher, message) {
    return this.be.satisfy(matcher, message);
  }), def("withContext", function(context) {
    for (let key2 in context) utils.flag(this, key2, context[key2]);
    return this;
  }), utils.addProperty(chai.Assertion.prototype, "resolves", function() {
    let error = new Error("resolves");
    utils.flag(this, "promise", "resolves"), utils.flag(this, "error", error);
    let test3 = utils.flag(this, "vitest-test"), obj = utils.flag(this, "object");
    if (utils.flag(this, "poll")) throw new SyntaxError("expect.poll() is not supported in combination with .resolves");
    if (typeof (obj == null ? void 0 : obj.then) != "function") throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof obj}'.`);
    let proxy = new Proxy(this, { get: (target, key2, receiver) => {
      let result2 = Reflect.get(target, key2, receiver);
      return typeof result2 != "function" ? result2 instanceof chai.Assertion ? proxy : result2 : async (...args2) => {
        let promise = obj.then((value2) => (utils.flag(this, "object", value2), result2.call(this, ...args2)), (err) => {
          let _error = new AssertionError2(`promise rejected "${utils.inspect(err)}" instead of resolving`, { showDiff: false });
          throw _error.cause = err, _error.stack = error.stack.replace(error.message, _error.message), _error;
        });
        return recordAsyncExpect(test3, promise);
      };
    } });
    return proxy;
  }), utils.addProperty(chai.Assertion.prototype, "rejects", function() {
    let error = new Error("rejects");
    utils.flag(this, "promise", "rejects"), utils.flag(this, "error", error);
    let test3 = utils.flag(this, "vitest-test"), obj = utils.flag(this, "object"), wrapper = typeof obj == "function" ? obj() : obj;
    if (utils.flag(this, "poll")) throw new SyntaxError("expect.poll() is not supported in combination with .rejects");
    if (typeof (wrapper == null ? void 0 : wrapper.then) != "function") throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof wrapper}'.`);
    let proxy = new Proxy(this, { get: (target, key2, receiver) => {
      let result2 = Reflect.get(target, key2, receiver);
      return typeof result2 != "function" ? result2 instanceof chai.Assertion ? proxy : result2 : async (...args2) => {
        let promise = wrapper.then((value2) => {
          let _error = new AssertionError2(`promise resolved "${utils.inspect(value2)}" instead of rejecting`, { showDiff: true, expected: new Error("rejected promise"), actual: value2 });
          throw _error.stack = error.stack.replace(error.message, _error.message), _error;
        }, (err) => (utils.flag(this, "object", err), result2.call(this, ...args2)));
        return recordAsyncExpect(test3, promise);
      };
    } });
    return proxy;
  });
};
function getMatcherState(assertion, expect4) {
  let obj = assertion._obj, isNot = utils_exports.flag(assertion, "negate"), promise = utils_exports.flag(assertion, "promise") || "", jestUtils = { ...getMatcherUtils(), diff: diff2, stringify: stringify2, iterableEquality, subsetEquality };
  return { state: { ...getState(expect4), customTesters: getCustomEqualityTesters(), isNot, utils: jestUtils, promise, equals, suppressedErrors: [], soft: utils_exports.flag(assertion, "soft"), poll: utils_exports.flag(assertion, "poll") }, isNot, obj };
}
var JestExtendError = class extends Error {
  constructor(message, actual, expected) {
    super(message), this.actual = actual, this.expected = expected;
  }
};
function JestExtendPlugin(c3, expect4, matchers) {
  return (_4, utils) => {
    Object.entries(matchers).forEach(([expectAssertionName, expectAssertion]) => {
      function expectWrapper(...args2) {
        let { state, isNot, obj } = getMatcherState(this, expect4), result2 = expectAssertion.call(state, obj, ...args2);
        if (result2 && typeof result2 == "object" && result2 instanceof Promise) return result2.then(({ pass: pass2, message: message2, actual: actual2, expected: expected2 }) => {
          if (pass2 && isNot || !pass2 && !isNot) throw new JestExtendError(message2(), actual2, expected2);
        });
        let { pass, message, actual, expected } = result2;
        if (pass && isNot || !pass && !isNot) throw new JestExtendError(message(), actual, expected);
      }
      let softWrapper = wrapSoft(utils, expectWrapper);
      utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, expectAssertionName, softWrapper), utils.addMethod(c3.Assertion.prototype, expectAssertionName, softWrapper);
      class CustomMatcher extends AsymmetricMatcher32 {
        constructor(inverse = false, ...sample) {
          super(sample, inverse);
        }
        asymmetricMatch(other) {
          let { pass } = expectAssertion.call(this.getMatcherContext(expect4), other, ...this.sample);
          return this.inverse ? !pass : pass;
        }
        toString() {
          return `${this.inverse ? "not." : ""}${expectAssertionName}`;
        }
        getExpectedType() {
          return "any";
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map(String).join(", ")}>`;
        }
      }
      let customMatcher = (...sample) => new CustomMatcher(false, ...sample);
      Object.defineProperty(expect4, expectAssertionName, { configurable: true, enumerable: true, value: customMatcher, writable: true }), Object.defineProperty(expect4.not, expectAssertionName, { configurable: true, enumerable: true, value: (...sample) => new CustomMatcher(true, ...sample), writable: true }), Object.defineProperty(globalThis[ASYMMETRIC_MATCHERS_OBJECT], expectAssertionName, { configurable: true, enumerable: true, value: customMatcher, writable: true });
    });
  };
}
var JestExtend = (chai, utils) => {
  utils.addMethod(chai.expect, "extend", (expect4, expects) => {
    use(JestExtendPlugin(chai, expect4, expects));
  });
};
function createExpect() {
  use(JestExtend), use(JestChaiExpect), use(JestAsymmetricMatchers);
  let expect4 = (value2, message) => {
    let { assertionCalls } = getState(expect4);
    return setState({ assertionCalls: assertionCalls + 1, soft: false }, expect4), expect(value2, message);
  };
  Object.assign(expect4, expect), expect4.getState = () => getState(expect4), expect4.setState = (state) => setState(state, expect4), expect4.extend = (expects) => expect.extend(expect4, expects), expect4.soft = (...args2) => {
    let assert2 = expect4(...args2);
    return expect4.setState({ soft: true }), assert2;
  }, expect4.unreachable = (message) => {
    assert.fail(`expected${message ? ` "${message}" ` : " "}not to be reached`);
  };
  function assertions(expected) {
    let errorGen = () => new Error(`expected number of assertions to be ${expected}, but got ${expect4.getState().assertionCalls}`);
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(errorGen(), assertions), expect4.setState({ expectedAssertionsNumber: expected, expectedAssertionsNumberErrorGen: errorGen });
  }
  function hasAssertions() {
    let error = new Error("expected any number of assertion, but got none");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(error, hasAssertions), expect4.setState({ isExpectingAssertions: true, isExpectingAssertionsError: error });
  }
  return setState({ assertionCalls: 0, isExpectingAssertions: false, isExpectingAssertionsError: null, expectedAssertionsNumber: null, expectedAssertionsNumberErrorGen: null }, expect4), utils_exports.addMethod(expect4, "assertions", assertions), utils_exports.addMethod(expect4, "hasAssertions", hasAssertions), expect4.extend(matchers_exports), expect4;
}
var expect2 = createExpect();
Object.defineProperty(globalThis, GLOBAL_EXPECT, { value: expect2, writable: true, configurable: true });
var listeners = /* @__PURE__ */ new Set();
function onMockCall(callback) {
  return listeners.add(callback), () => void listeners.delete(callback);
}
var spyOn2 = (...args2) => {
  let mock = spyOn(...args2);
  return reactiveMock(mock);
};
function fn22(implementation) {
  let mock = implementation ? fn2(implementation) : fn2();
  return reactiveMock(mock);
}
function reactiveMock(mock) {
  let reactive = listenWhenCalled(mock), originalMockImplementation = reactive.mockImplementation.bind(null);
  return reactive.mockImplementation = (fn3) => listenWhenCalled(originalMockImplementation(fn3)), reactive;
}
function listenWhenCalled(mock) {
  let state = I5(mock), impl = state.impl;
  return state.willCall(function(...args2) {
    return listeners.forEach((listener) => listener(mock, args2)), impl == null ? void 0 : impl.apply(this, args2);
  }), mock;
}
function clearAllMocks() {
  mocks.forEach((spy) => spy.mockClear());
}
function resetAllMocks() {
  mocks.forEach((spy) => spy.mockReset());
}
function restoreAllMocks() {
  mocks.forEach((spy) => spy.mockRestore());
}
function mocked(item, _options = {}) {
  return item;
}
var dom_esm_exports = {};
__export2(dom_esm_exports, { buildQueries: () => buildQueries, configure: () => configure, createEvent: () => createEvent, findAllByAltText: () => findAllByAltText, findAllByDisplayValue: () => findAllByDisplayValue, findAllByLabelText: () => findAllByLabelText, findAllByPlaceholderText: () => findAllByPlaceholderText, findAllByRole: () => findAllByRole, findAllByTestId: () => findAllByTestId, findAllByText: () => findAllByText, findAllByTitle: () => findAllByTitle, findByAltText: () => findByAltText, findByDisplayValue: () => findByDisplayValue, findByLabelText: () => findByLabelText, findByPlaceholderText: () => findByPlaceholderText, findByRole: () => findByRole, findByTestId: () => findByTestId, findByText: () => findByText, findByTitle: () => findByTitle, fireEvent: () => fireEvent, getAllByAltText: () => getAllByAltText, getAllByDisplayValue: () => getAllByDisplayValue, getAllByLabelText: () => getAllByLabelTextWithSuggestions, getAllByPlaceholderText: () => getAllByPlaceholderText, getAllByRole: () => getAllByRole, getAllByTestId: () => getAllByTestId, getAllByText: () => getAllByText, getAllByTitle: () => getAllByTitle, getByAltText: () => getByAltText, getByDisplayValue: () => getByDisplayValue, getByLabelText: () => getByLabelTextWithSuggestions, getByPlaceholderText: () => getByPlaceholderText, getByRole: () => getByRole, getByTestId: () => getByTestId, getByText: () => getByText, getByTitle: () => getByTitle, getConfig: () => getConfig22, getDefaultNormalizer: () => getDefaultNormalizer, getElementError: () => getElementError, getMultipleElementsFoundError: () => getMultipleElementsFoundError, getNodeText: () => getNodeText, getQueriesForElement: () => getQueriesForElement, getRoles: () => getRoles, getSuggestedQuery: () => getSuggestedQuery, isInaccessible: () => isInaccessible, logDOM: () => logDOM, logRoles: () => logRoles, makeFindQuery: () => makeFindQuery, makeGetAllQuery: () => makeGetAllQuery, makeSingleQuery: () => makeSingleQuery, prettyDOM: () => prettyDOM, prettyFormat: () => prettyFormat, queries: () => queries, queryAllByAltText: () => queryAllByAltTextWithSuggestions, queryAllByAttribute: () => queryAllByAttribute, queryAllByDisplayValue: () => queryAllByDisplayValueWithSuggestions, queryAllByLabelText: () => queryAllByLabelTextWithSuggestions, queryAllByPlaceholderText: () => queryAllByPlaceholderTextWithSuggestions, queryAllByRole: () => queryAllByRoleWithSuggestions, queryAllByTestId: () => queryAllByTestIdWithSuggestions, queryAllByText: () => queryAllByTextWithSuggestions, queryAllByTitle: () => queryAllByTitleWithSuggestions, queryByAltText: () => queryByAltText, queryByAttribute: () => queryByAttribute, queryByDisplayValue: () => queryByDisplayValue, queryByLabelText: () => queryByLabelText, queryByPlaceholderText: () => queryByPlaceholderText, queryByRole: () => queryByRole, queryByTestId: () => queryByTestId, queryByText: () => queryByText, queryByTitle: () => queryByTitle, queryHelpers: () => queryHelpers, screen: () => screen, waitFor: () => waitForWrapper, waitForElementToBeRemoved: () => waitForElementToBeRemoved, within: () => getQueriesForElement, wrapAllByQueryWithSuggestion: () => wrapAllByQueryWithSuggestion, wrapSingleQueryWithSuggestion: () => wrapSingleQueryWithSuggestion });
var prettyFormat = __toESM(require_build());
var toStr2 = Object.prototype.toString;
function isCallable2(fn3) {
  return typeof fn3 == "function" || toStr2.call(fn3) === "[object Function]";
}
function toInteger2(value2) {
  var number = Number(value2);
  return isNaN(number) ? 0 : number === 0 || !isFinite(number) ? number : (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
}
var maxSafeInteger2 = Math.pow(2, 53) - 1;
function toLength2(value2) {
  var len = toInteger2(value2);
  return Math.min(Math.max(len, 0), maxSafeInteger2);
}
function arrayFrom2(arrayLike, mapFn) {
  var C32 = Array, items = Object(arrayLike);
  if (arrayLike == null) throw new TypeError("Array.from requires an array-like object - not null or undefined");
  if (typeof mapFn < "u" && !isCallable2(mapFn)) throw new TypeError("Array.from: when provided, the second argument must be a function");
  for (var len = toLength2(items.length), A4 = isCallable2(C32) ? Object(new C32(len)) : new Array(len), k22 = 0, kValue; k22 < len; ) kValue = items[k22], mapFn ? A4[k22] = mapFn(kValue, k22) : A4[k22] = kValue, k22 += 1;
  return A4.length = len, A4;
}
function _typeof3(obj) {
  "@babel/helpers - typeof";
  return _typeof3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties2(target, props) {
  for (var i4 = 0; i4 < props.length; i4++) {
    var descriptor = props[i4];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, _toPropertyKey3(descriptor.key), descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties2(Constructor.prototype, protoProps), staticProps && _defineProperties2(Constructor, staticProps), Object.defineProperty(Constructor, "prototype", { writable: false }), Constructor;
}
function _defineProperty3(obj, key2, value2) {
  return key2 = _toPropertyKey3(key2), key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
function _toPropertyKey3(arg) {
  var key2 = _toPrimitive3(arg, "string");
  return _typeof3(key2) === "symbol" ? key2 : String(key2);
}
function _toPrimitive3(input2, hint) {
  if (_typeof3(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof3(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var SetLike2 = function() {
  function SetLike3() {
    var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck2(this, SetLike3), _defineProperty3(this, "items", void 0), this.items = items;
  }
  return _createClass2(SetLike3, [{ key: "add", value: function(value2) {
    return this.has(value2) === false && this.items.push(value2), this;
  } }, { key: "clear", value: function() {
    this.items = [];
  } }, { key: "delete", value: function(value2) {
    var previousLength = this.items.length;
    return this.items = this.items.filter(function(item) {
      return item !== value2;
    }), previousLength !== this.items.length;
  } }, { key: "forEach", value: function(callbackfn) {
    var _this = this;
    this.items.forEach(function(item) {
      callbackfn(item, item, _this);
    });
  } }, { key: "has", value: function(value2) {
    return this.items.indexOf(value2) !== -1;
  } }, { key: "size", get: function() {
    return this.items.length;
  } }]), SetLike3;
}();
var SetLike_default2 = typeof Set > "u" ? Set : SetLike2;
function getLocalName2(element) {
  var _element$localName;
  return (_element$localName = element.localName) !== null && _element$localName !== void 0 ? _element$localName : element.tagName.toLowerCase();
}
var localNameToRoleMappings2 = { article: "article", aside: "complementary", button: "button", datalist: "listbox", dd: "definition", details: "group", dialog: "dialog", dt: "term", fieldset: "group", figure: "figure", form: "form", footer: "contentinfo", h1: "heading", h2: "heading", h3: "heading", h4: "heading", h5: "heading", h6: "heading", header: "banner", hr: "separator", html: "document", legend: "legend", li: "listitem", math: "math", main: "main", menu: "list", nav: "navigation", ol: "list", optgroup: "group", option: "option", output: "status", progress: "progressbar", section: "region", summary: "button", table: "table", tbody: "rowgroup", textarea: "textbox", tfoot: "rowgroup", td: "cell", th: "columnheader", thead: "rowgroup", tr: "row", ul: "list" };
var prohibitedAttributes2 = { caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]), insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]), superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]) };
function hasGlobalAriaAttributes2(element, role) {
  return ["aria-atomic", "aria-busy", "aria-controls", "aria-current", "aria-describedby", "aria-details", "aria-dropeffect", "aria-flowto", "aria-grabbed", "aria-hidden", "aria-keyshortcuts", "aria-label", "aria-labelledby", "aria-live", "aria-owns", "aria-relevant", "aria-roledescription"].some(function(attributeName) {
    var _prohibitedAttributes;
    return element.hasAttribute(attributeName) && !((_prohibitedAttributes = prohibitedAttributes2[role]) !== null && _prohibitedAttributes !== void 0 && _prohibitedAttributes.has(attributeName));
  });
}
function ignorePresentationalRole2(element, implicitRole) {
  return hasGlobalAriaAttributes2(element, implicitRole);
}
function getRole2(element) {
  var explicitRole = getExplicitRole2(element);
  if (explicitRole === null || explicitRole === "presentation") {
    var implicitRole = getImplicitRole2(element);
    if (explicitRole !== "presentation" || ignorePresentationalRole2(element, implicitRole || "")) return implicitRole;
  }
  return explicitRole;
}
function getImplicitRole2(element) {
  var mappedByTag = localNameToRoleMappings2[getLocalName2(element)];
  if (mappedByTag !== void 0) return mappedByTag;
  switch (getLocalName2(element)) {
    case "a":
    case "area":
    case "link":
      if (element.hasAttribute("href")) return "link";
      break;
    case "img":
      return element.getAttribute("alt") === "" && !ignorePresentationalRole2(element, "img") ? "presentation" : "img";
    case "input": {
      var _ref = element, type5 = _ref.type;
      switch (type5) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return type5;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return element.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return element.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return element.hasAttribute("multiple") || element.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
function getExplicitRole2(element) {
  var role = element.getAttribute("role");
  if (role !== null) {
    var explicitRole = role.trim().split(" ")[0];
    if (explicitRole.length > 0) return explicitRole;
  }
  return null;
}
function isElement2(node) {
  return node !== null && node.nodeType === node.ELEMENT_NODE;
}
function isHTMLTableCaptionElement2(node) {
  return isElement2(node) && getLocalName2(node) === "caption";
}
function isHTMLInputElement2(node) {
  return isElement2(node) && getLocalName2(node) === "input";
}
function isHTMLOptGroupElement2(node) {
  return isElement2(node) && getLocalName2(node) === "optgroup";
}
function isHTMLSelectElement2(node) {
  return isElement2(node) && getLocalName2(node) === "select";
}
function isHTMLTableElement2(node) {
  return isElement2(node) && getLocalName2(node) === "table";
}
function isHTMLTextAreaElement2(node) {
  return isElement2(node) && getLocalName2(node) === "textarea";
}
function safeWindow2(node) {
  var _ref = node.ownerDocument === null ? node : node.ownerDocument, defaultView = _ref.defaultView;
  if (defaultView === null) throw new TypeError("no window available");
  return defaultView;
}
function isHTMLFieldSetElement2(node) {
  return isElement2(node) && getLocalName2(node) === "fieldset";
}
function isHTMLLegendElement2(node) {
  return isElement2(node) && getLocalName2(node) === "legend";
}
function isHTMLSlotElement2(node) {
  return isElement2(node) && getLocalName2(node) === "slot";
}
function isSVGElement2(node) {
  return isElement2(node) && node.ownerSVGElement !== void 0;
}
function isSVGSVGElement2(node) {
  return isElement2(node) && getLocalName2(node) === "svg";
}
function isSVGTitleElement2(node) {
  return isSVGElement2(node) && getLocalName2(node) === "title";
}
function queryIdRefs2(node, attributeName) {
  if (isElement2(node) && node.hasAttribute(attributeName)) {
    var ids = node.getAttribute(attributeName).split(" "), root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    return ids.map(function(id) {
      return root2.getElementById(id);
    }).filter(function(element) {
      return element !== null;
    });
  }
  return [];
}
function hasAnyConcreteRoles2(node, roles3) {
  return isElement2(node) ? roles3.indexOf(getRole2(node)) !== -1 : false;
}
function asFlatString2(s4) {
  return s4.trim().replace(/\s\s+/g, " ");
}
function isHidden2(node, getComputedStyleImplementation) {
  if (!isElement2(node)) return false;
  if (node.hasAttribute("hidden") || node.getAttribute("aria-hidden") === "true") return true;
  var style = getComputedStyleImplementation(node);
  return style.getPropertyValue("display") === "none" || style.getPropertyValue("visibility") === "hidden";
}
function isControl2(node) {
  return hasAnyConcreteRoles2(node, ["button", "combobox", "listbox", "textbox"]) || hasAbstractRole2(node, "range");
}
function hasAbstractRole2(node, role) {
  if (!isElement2(node)) return false;
  switch (role) {
    case "range":
      return hasAnyConcreteRoles2(node, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(role, "'. This is likely a bug :("));
  }
}
function querySelectorAllSubtree2(element, selectors) {
  var elements = arrayFrom2(element.querySelectorAll(selectors));
  return queryIdRefs2(element, "aria-owns").forEach(function(root2) {
    elements.push.apply(elements, arrayFrom2(root2.querySelectorAll(selectors)));
  }), elements;
}
function querySelectedOptions2(listbox) {
  return isHTMLSelectElement2(listbox) ? listbox.selectedOptions || querySelectorAllSubtree2(listbox, "[selected]") : querySelectorAllSubtree2(listbox, '[aria-selected="true"]');
}
function isMarkedPresentational2(node) {
  return hasAnyConcreteRoles2(node, ["none", "presentation"]);
}
function isNativeHostLanguageTextAlternativeElement2(node) {
  return isHTMLTableCaptionElement2(node);
}
function allowsNameFromContent2(node) {
  return hasAnyConcreteRoles2(node, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
function isDescendantOfNativeHostLanguageTextAlternativeElement2(node) {
  return false;
}
function getValueOfTextbox2(element) {
  return isHTMLInputElement2(element) || isHTMLTextAreaElement2(element) ? element.value : element.textContent || "";
}
function getTextualContent2(declaration) {
  var content = declaration.getPropertyValue("content");
  return /^["'].*["']$/.test(content) ? content.slice(1, -1) : "";
}
function isLabelableElement2(element) {
  var localName = getLocalName2(element);
  return localName === "button" || localName === "input" && element.getAttribute("type") !== "hidden" || localName === "meter" || localName === "output" || localName === "progress" || localName === "select" || localName === "textarea";
}
function findLabelableElement2(element) {
  if (isLabelableElement2(element)) return element;
  var labelableElement = null;
  return element.childNodes.forEach(function(childNode) {
    if (labelableElement === null && isElement2(childNode)) {
      var descendantLabelableElement = findLabelableElement2(childNode);
      descendantLabelableElement !== null && (labelableElement = descendantLabelableElement);
    }
  }), labelableElement;
}
function getControlOfLabel2(label) {
  if (label.control !== void 0) return label.control;
  var htmlFor = label.getAttribute("for");
  return htmlFor !== null ? label.ownerDocument.getElementById(htmlFor) : findLabelableElement2(label);
}
function getLabels2(element) {
  var labelsProperty = element.labels;
  if (labelsProperty === null) return labelsProperty;
  if (labelsProperty !== void 0) return arrayFrom2(labelsProperty);
  if (!isLabelableElement2(element)) return null;
  var document2 = element.ownerDocument;
  return arrayFrom2(document2.querySelectorAll("label")).filter(function(label) {
    return getControlOfLabel2(label) === element;
  });
}
function getSlotContents2(slot) {
  var assignedNodes = slot.assignedNodes();
  return assignedNodes.length === 0 ? arrayFrom2(slot.childNodes) : assignedNodes;
}
function computeTextAlternative2(root2) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, consultedNodes = new SetLike_default2(), window2 = safeWindow2(root2), _options$compute = options2.compute, compute = _options$compute === void 0 ? "name" : _options$compute, _options$computedStyl = options2.computedStyleSupportsPseudoElements, computedStyleSupportsPseudoElements = _options$computedStyl === void 0 ? options2.getComputedStyle !== void 0 : _options$computedStyl, _options$getComputedS = options2.getComputedStyle, getComputedStyle = _options$getComputedS === void 0 ? window2.getComputedStyle.bind(window2) : _options$getComputedS, _options$hidden = options2.hidden, hidden = _options$hidden === void 0 ? false : _options$hidden;
  function computeMiscTextAlternative(node, context) {
    var accumulatedText = "";
    if (isElement2(node) && computedStyleSupportsPseudoElements) {
      var pseudoBefore = getComputedStyle(node, "::before"), beforeContent = getTextualContent2(pseudoBefore);
      accumulatedText = "".concat(beforeContent, " ").concat(accumulatedText);
    }
    var childNodes = isHTMLSlotElement2(node) ? getSlotContents2(node) : arrayFrom2(node.childNodes).concat(queryIdRefs2(node, "aria-owns"));
    if (childNodes.forEach(function(child) {
      var result2 = computeTextAlternative3(child, { isEmbeddedInLabel: context.isEmbeddedInLabel, isReferenced: false, recursion: true }), display2 = isElement2(child) ? getComputedStyle(child).getPropertyValue("display") : "inline", separator = display2 !== "inline" ? " " : "";
      accumulatedText += "".concat(separator).concat(result2).concat(separator);
    }), isElement2(node) && computedStyleSupportsPseudoElements) {
      var pseudoAfter = getComputedStyle(node, "::after"), afterContent = getTextualContent2(pseudoAfter);
      accumulatedText = "".concat(accumulatedText, " ").concat(afterContent);
    }
    return accumulatedText.trim();
  }
  function useAttribute(element, attributeName) {
    var attribute = element.getAttributeNode(attributeName);
    return attribute !== null && !consultedNodes.has(attribute) && attribute.value.trim() !== "" ? (consultedNodes.add(attribute), attribute.value) : null;
  }
  function computeTooltipAttributeValue(node) {
    return isElement2(node) ? useAttribute(node, "title") : null;
  }
  function computeElementTextAlternative(node) {
    if (!isElement2(node)) return null;
    if (isHTMLFieldSetElement2(node)) {
      consultedNodes.add(node);
      for (var children = arrayFrom2(node.childNodes), i4 = 0; i4 < children.length; i4 += 1) {
        var child = children[i4];
        if (isHTMLLegendElement2(child)) return computeTextAlternative3(child, { isEmbeddedInLabel: false, isReferenced: false, recursion: false });
      }
    } else if (isHTMLTableElement2(node)) {
      consultedNodes.add(node);
      for (var _children = arrayFrom2(node.childNodes), _i = 0; _i < _children.length; _i += 1) {
        var _child = _children[_i];
        if (isHTMLTableCaptionElement2(_child)) return computeTextAlternative3(_child, { isEmbeddedInLabel: false, isReferenced: false, recursion: false });
      }
    } else if (isSVGSVGElement2(node)) {
      consultedNodes.add(node);
      for (var _children2 = arrayFrom2(node.childNodes), _i2 = 0; _i2 < _children2.length; _i2 += 1) {
        var _child2 = _children2[_i2];
        if (isSVGTitleElement2(_child2)) return _child2.textContent;
      }
      return null;
    } else if (getLocalName2(node) === "img" || getLocalName2(node) === "area") {
      var nameFromAlt = useAttribute(node, "alt");
      if (nameFromAlt !== null) return nameFromAlt;
    } else if (isHTMLOptGroupElement2(node)) {
      var nameFromLabel = useAttribute(node, "label");
      if (nameFromLabel !== null) return nameFromLabel;
    }
    if (isHTMLInputElement2(node) && (node.type === "button" || node.type === "submit" || node.type === "reset")) {
      var nameFromValue = useAttribute(node, "value");
      if (nameFromValue !== null) return nameFromValue;
      if (node.type === "submit") return "Submit";
      if (node.type === "reset") return "Reset";
    }
    var labels = getLabels2(node);
    if (labels !== null && labels.length !== 0) return consultedNodes.add(node), arrayFrom2(labels).map(function(element) {
      return computeTextAlternative3(element, { isEmbeddedInLabel: true, isReferenced: false, recursion: true });
    }).filter(function(label) {
      return label.length > 0;
    }).join(" ");
    if (isHTMLInputElement2(node) && node.type === "image") {
      var _nameFromAlt = useAttribute(node, "alt");
      if (_nameFromAlt !== null) return _nameFromAlt;
      var nameFromTitle = useAttribute(node, "title");
      return nameFromTitle !== null ? nameFromTitle : "Submit Query";
    }
    if (hasAnyConcreteRoles2(node, ["button"])) {
      var nameFromSubTree = computeMiscTextAlternative(node, { isEmbeddedInLabel: false, isReferenced: false });
      if (nameFromSubTree !== "") return nameFromSubTree;
    }
    return null;
  }
  function computeTextAlternative3(current, context) {
    if (consultedNodes.has(current)) return "";
    if (!hidden && isHidden2(current, getComputedStyle) && !context.isReferenced) return consultedNodes.add(current), "";
    var labelAttributeNode = isElement2(current) ? current.getAttributeNode("aria-labelledby") : null, labelElements = labelAttributeNode !== null && !consultedNodes.has(labelAttributeNode) ? queryIdRefs2(current, "aria-labelledby") : [];
    if (compute === "name" && !context.isReferenced && labelElements.length > 0) return consultedNodes.add(labelAttributeNode), labelElements.map(function(element) {
      return computeTextAlternative3(element, { isEmbeddedInLabel: context.isEmbeddedInLabel, isReferenced: true, recursion: false });
    }).join(" ");
    var skipToStep2E = context.recursion && isControl2(current) && compute === "name";
    if (!skipToStep2E) {
      var ariaLabel = (isElement2(current) && current.getAttribute("aria-label") || "").trim();
      if (ariaLabel !== "" && compute === "name") return consultedNodes.add(current), ariaLabel;
      if (!isMarkedPresentational2(current)) {
        var elementTextAlternative = computeElementTextAlternative(current);
        if (elementTextAlternative !== null) return consultedNodes.add(current), elementTextAlternative;
      }
    }
    if (hasAnyConcreteRoles2(current, ["menu"])) return consultedNodes.add(current), "";
    if (skipToStep2E || context.isEmbeddedInLabel || context.isReferenced) {
      if (hasAnyConcreteRoles2(current, ["combobox", "listbox"])) {
        consultedNodes.add(current);
        var selectedOptions = querySelectedOptions2(current);
        return selectedOptions.length === 0 ? isHTMLInputElement2(current) ? current.value : "" : arrayFrom2(selectedOptions).map(function(selectedOption) {
          return computeTextAlternative3(selectedOption, { isEmbeddedInLabel: context.isEmbeddedInLabel, isReferenced: false, recursion: true });
        }).join(" ");
      }
      if (hasAbstractRole2(current, "range")) return consultedNodes.add(current), current.hasAttribute("aria-valuetext") ? current.getAttribute("aria-valuetext") : current.hasAttribute("aria-valuenow") ? current.getAttribute("aria-valuenow") : current.getAttribute("value") || "";
      if (hasAnyConcreteRoles2(current, ["textbox"])) return consultedNodes.add(current), getValueOfTextbox2(current);
    }
    if (allowsNameFromContent2(current) || isElement2(current) && context.isReferenced || isNativeHostLanguageTextAlternativeElement2(current) || isDescendantOfNativeHostLanguageTextAlternativeElement2()) {
      var accumulatedText2F = computeMiscTextAlternative(current, { isEmbeddedInLabel: context.isEmbeddedInLabel, isReferenced: false });
      if (accumulatedText2F !== "") return consultedNodes.add(current), accumulatedText2F;
    }
    if (current.nodeType === current.TEXT_NODE) return consultedNodes.add(current), current.textContent || "";
    if (context.recursion) return consultedNodes.add(current), computeMiscTextAlternative(current, { isEmbeddedInLabel: context.isEmbeddedInLabel, isReferenced: false });
    var tooltipAttributeValue = computeTooltipAttributeValue(current);
    return tooltipAttributeValue !== null ? (consultedNodes.add(current), tooltipAttributeValue) : (consultedNodes.add(current), "");
  }
  return asFlatString2(computeTextAlternative3(root2, { isEmbeddedInLabel: false, isReferenced: compute === "description", recursion: false }));
}
function _typeof4(obj) {
  "@babel/helpers - typeof";
  return _typeof4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof4(obj);
}
function ownKeys2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source2 = arguments[i4] != null ? arguments[i4] : {};
    i4 % 2 ? ownKeys2(Object(source2), true).forEach(function(key2) {
      _defineProperty4(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys2(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function _defineProperty4(obj, key2, value2) {
  return key2 = _toPropertyKey4(key2), key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
function _toPropertyKey4(arg) {
  var key2 = _toPrimitive4(arg, "string");
  return _typeof4(key2) === "symbol" ? key2 : String(key2);
}
function _toPrimitive4(input2, hint) {
  if (_typeof4(input2) !== "object" || input2 === null) return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof4(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function computeAccessibleDescription2(root2) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, description = queryIdRefs2(root2, "aria-describedby").map(function(element) {
    return computeTextAlternative2(element, _objectSpread2(_objectSpread2({}, options2), {}, { compute: "description" }));
  }).join(" ");
  if (description === "") {
    var title = root2.getAttribute("title");
    description = title === null ? "" : title;
  }
  return description;
}
function prohibitsNaming2(node) {
  return hasAnyConcreteRoles2(node, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
function computeAccessibleName2(root2) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return prohibitsNaming2(root2) ? "" : computeTextAlternative2(root2, options2);
}
var import_aria_query3 = __toESM(require_lib());
var import_lz_string = __toESM(require_lz_string());
function escapeHTML22(str) {
  return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
var printProps22 = (keys2, props, config3, indentation, depth, refs2, printer22) => {
  let indentationNext = indentation + config3.indent, colors = config3.colors;
  return keys2.map((key2) => {
    let value2 = props[key2], printed = printer22(value2, config3, indentationNext, depth, refs2);
    return typeof value2 != "string" && (printed.indexOf(`
`) !== -1 && (printed = config3.spacingOuter + indentationNext + printed + config3.spacingOuter + indentation), printed = "{" + printed + "}"), config3.spacingInner + indentation + colors.prop.open + key2 + colors.prop.close + "=" + colors.value.open + printed + colors.value.close;
  }).join("");
};
var NodeTypeTextNode = 3;
var printChildren22 = (children, config3, indentation, depth, refs2, printer22) => children.map((child) => {
  let printedChild = typeof child == "string" ? printText22(child, config3) : printer22(child, config3, indentation, depth, refs2);
  return printedChild === "" && typeof child == "object" && child !== null && child.nodeType !== NodeTypeTextNode ? "" : config3.spacingOuter + indentation + printedChild;
}).join("");
var printText22 = (text, config3) => {
  let contentColor = config3.colors.content;
  return contentColor.open + escapeHTML22(text) + contentColor.close;
};
var printComment22 = (comment, config3) => {
  let commentColor = config3.colors.comment;
  return commentColor.open + "<!--" + escapeHTML22(comment) + "-->" + commentColor.close;
};
var printElement22 = (type5, printedProps, printedChildren, config3, indentation) => {
  let tagColor = config3.colors.tag;
  return tagColor.open + "<" + type5 + (printedProps && tagColor.close + printedProps + config3.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config3.spacingOuter + indentation + tagColor.open + "</" + type5 : (printedProps && !config3.min ? "" : " ") + "/") + ">" + tagColor.close;
};
var printElementAsLeaf22 = (type5, config3) => {
  let tagColor = config3.colors.tag;
  return tagColor.open + "<" + type5 + tagColor.close + " " + tagColor.open + " />" + tagColor.close;
};
var ELEMENT_NODE$1 = 1;
var TEXT_NODE$1 = 3;
var COMMENT_NODE$1 = 8;
var FRAGMENT_NODE22 = 11;
var ELEMENT_REGEXP22 = /^((HTML|SVG)\w*)?Element$/;
var isCustomElement2 = (val) => {
  let { tagName } = val;
  return !!(typeof tagName == "string" && tagName.includes("-") || typeof val.hasAttribute == "function" && val.hasAttribute("is"));
};
var testNode22 = (val) => {
  let constructorName = val.constructor.name, { nodeType } = val;
  return nodeType === ELEMENT_NODE$1 && (ELEMENT_REGEXP22.test(constructorName) || isCustomElement2(val)) || nodeType === TEXT_NODE$1 && constructorName === "Text" || nodeType === COMMENT_NODE$1 && constructorName === "Comment" || nodeType === FRAGMENT_NODE22 && constructorName === "DocumentFragment";
};
function nodeIsText22(node) {
  return node.nodeType === TEXT_NODE$1;
}
function nodeIsComment22(node) {
  return node.nodeType === COMMENT_NODE$1;
}
function nodeIsFragment22(node) {
  return node.nodeType === FRAGMENT_NODE22;
}
function createDOMElementFilter(filterNode) {
  return { test: (val) => {
    var _val$constructor2;
    return ((val == null || (_val$constructor2 = val.constructor) == null ? void 0 : _val$constructor2.name) || isCustomElement2(val)) && testNode22(val);
  }, serialize: (node, config3, indentation, depth, refs2, printer22) => {
    if (nodeIsText22(node)) return printText22(node.data, config3);
    if (nodeIsComment22(node)) return printComment22(node.data, config3);
    let type5 = nodeIsFragment22(node) ? "DocumentFragment" : node.tagName.toLowerCase();
    return ++depth > config3.maxDepth ? printElementAsLeaf22(type5, config3) : printElement22(type5, printProps22(nodeIsFragment22(node) ? [] : Array.from(node.attributes).map((attr) => attr.name).sort(), nodeIsFragment22(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}), config3, indentation + config3.indent, depth, refs2, printer22), printChildren22(Array.prototype.slice.call(node.childNodes || node.children).filter(filterNode), config3, indentation + config3.indent, depth, refs2, printer22), config3, indentation);
  } };
}
var chalk2 = null;
var readFileSync = null;
var codeFrameColumns = null;
try {
  let nodeRequire = module && module.require;
  readFileSync = nodeRequire.call(module, "fs").readFileSync, codeFrameColumns = nodeRequire.call(module, "@babel/code-frame").codeFrameColumns, chalk2 = nodeRequire.call(module, "chalk");
} catch {
}
function getCodeFrame(frame) {
  let locationStart = frame.indexOf("(") + 1, locationEnd = frame.indexOf(")"), frameLocation = frame.slice(locationStart, locationEnd), frameLocationElements = frameLocation.split(":"), [filename, line, column] = [frameLocationElements[0], parseInt(frameLocationElements[1], 10), parseInt(frameLocationElements[2], 10)], rawFileContents = "";
  try {
    rawFileContents = readFileSync(filename, "utf-8");
  } catch {
    return "";
  }
  let codeFrame = codeFrameColumns(rawFileContents, { start: { line, column } }, { highlightCode: true, linesBelow: 0 });
  return chalk2.dim(frameLocation) + `
` + codeFrame + `
`;
}
function getUserCodeFrame() {
  if (!readFileSync || !codeFrameColumns) return "";
  let firstClientCodeFrame = new Error().stack.split(`
`).slice(1).find((frame) => !frame.includes("node_modules/"));
  return getCodeFrame(firstClientCodeFrame);
}
var TEXT_NODE22 = 3;
function jestFakeTimersAreEnabled() {
  return typeof jest < "u" && jest !== null ? setTimeout._isMockFunction === true || Object.prototype.hasOwnProperty.call(setTimeout, "clock") : false;
}
function getDocument() {
  if (typeof window > "u") throw new Error("Could not find default container");
  return window.document;
}
function getWindowFromNode(node) {
  if (node.defaultView) return node.defaultView;
  if (node.ownerDocument && node.ownerDocument.defaultView) return node.ownerDocument.defaultView;
  if (node.window) return node.window;
  throw node.ownerDocument && node.ownerDocument.defaultView === null ? new Error("It looks like the window object is not available for the provided node.") : node.then instanceof Function ? new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?") : Array.isArray(node) ? new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?") : typeof node.debug == "function" && typeof node.logTestingPlaygroundURL == "function" ? new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?") : new Error("The given node is not an Element, the node type is: " + typeof node + ".");
}
function checkContainerType(container) {
  if (!container || typeof container.querySelector != "function" || typeof container.querySelectorAll != "function") throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got " + getTypeName(container) + ".");
  function getTypeName(object) {
    return typeof object == "object" ? object === null ? "null" : object.constructor.name : typeof object;
  }
}
var shouldHighlight = () => {
  if (typeof process > "u") return false;
  let colors;
  try {
    var _process$env;
    let colorsJSON = (_process$env = process.env) == null ? void 0 : _process$env.COLORS;
    colorsJSON && (colors = JSON.parse(colorsJSON));
  } catch {
  }
  return typeof colors == "boolean" ? colors : process.versions !== void 0 && process.versions.node !== void 0;
};
var { DOMCollection: DOMCollection32 } = prettyFormat.plugins;
var ELEMENT_NODE22 = 1;
var COMMENT_NODE22 = 8;
function filterCommentsAndDefaultIgnoreTagsTags(value2) {
  return value2.nodeType !== COMMENT_NODE22 && (value2.nodeType !== ELEMENT_NODE22 || !value2.matches(getConfig22().defaultIgnore));
}
function prettyDOM(dom, maxLength, options2) {
  if (options2 === void 0 && (options2 = {}), dom || (dom = getDocument().body), typeof maxLength != "number" && (maxLength = typeof process < "u" && typeof process.env < "u" && process.env.DEBUG_PRINT_LIMIT || 7e3), maxLength === 0) return "";
  dom.documentElement && (dom = dom.documentElement);
  let domTypeName = typeof dom;
  if (domTypeName === "object" ? domTypeName = dom.constructor.name : dom = {}, !("outerHTML" in dom)) throw new TypeError("Expected an element or document but got " + domTypeName);
  let { filterNode = filterCommentsAndDefaultIgnoreTagsTags, ...prettyFormatOptions } = options2, debugContent = prettyFormat.format(dom, { plugins: [createDOMElementFilter(filterNode), DOMCollection32], printFunctionName: false, highlight: shouldHighlight(), ...prettyFormatOptions });
  return maxLength !== void 0 && dom.outerHTML.length > maxLength ? debugContent.slice(0, maxLength) + "..." : debugContent;
}
var logDOM = function() {
  let userCodeFrame = getUserCodeFrame();
  console.log(userCodeFrame ? prettyDOM(...arguments) + `

` + userCodeFrame : prettyDOM(...arguments));
};
var config2 = { testIdAttribute: "data-testid", asyncUtilTimeout: 1e3, asyncWrapper: (cb) => cb(), unstable_advanceTimersWrapper: (cb) => cb(), eventWrapper: (cb) => cb(), defaultHidden: false, defaultIgnore: "script, style", showOriginalStackTrace: false, throwSuggestions: false, getElementError(message, container) {
  let prettifiedDOM = prettyDOM(container), error = new Error([message, "Ignored nodes: comments, " + config2.defaultIgnore + `
` + prettifiedDOM].filter(Boolean).join(`

`));
  return error.name = "TestingLibraryElementError", error;
}, _disableExpensiveErrorDiagnostics: false, computedStyleSupportsPseudoElements: false };
function runWithExpensiveErrorDiagnosticsDisabled(callback) {
  try {
    return config2._disableExpensiveErrorDiagnostics = true, callback();
  } finally {
    config2._disableExpensiveErrorDiagnostics = false;
  }
}
function configure(newConfig) {
  typeof newConfig == "function" && (newConfig = newConfig(config2)), config2 = { ...config2, ...newConfig };
}
function getConfig22() {
  return config2;
}
var labelledNodeNames = ["button", "meter", "output", "progress", "select", "textarea", "input"];
function getTextContent(node) {
  return labelledNodeNames.includes(node.nodeName.toLowerCase()) ? "" : node.nodeType === TEXT_NODE22 ? node.textContent : Array.from(node.childNodes).map((childNode) => getTextContent(childNode)).join("");
}
function getLabelContent(element) {
  let textContent;
  return element.tagName.toLowerCase() === "label" ? textContent = getTextContent(element) : textContent = element.value || element.textContent, textContent;
}
function getRealLabels(element) {
  if (element.labels !== void 0) {
    var _labels;
    return (_labels = element.labels) != null ? _labels : [];
  }
  if (!isLabelable(element)) return [];
  let labels = element.ownerDocument.querySelectorAll("label");
  return Array.from(labels).filter((label) => label.control === element);
}
function isLabelable(element) {
  return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(element.tagName) || element.tagName === "INPUT" && element.getAttribute("type") !== "hidden";
}
function getLabels3(container, element, _temp) {
  let { selector = "*" } = _temp === void 0 ? {} : _temp, ariaLabelledBy = element.getAttribute("aria-labelledby"), labelsId = ariaLabelledBy ? ariaLabelledBy.split(" ") : [];
  return labelsId.length ? labelsId.map((labelId) => {
    let labellingElement = container.querySelector('[id="' + labelId + '"]');
    return labellingElement ? { content: getLabelContent(labellingElement), formControl: null } : { content: "", formControl: null };
  }) : Array.from(getRealLabels(element)).map((label) => {
    let textToMatch = getLabelContent(label), labelledFormControl = Array.from(label.querySelectorAll("button, input, meter, output, progress, select, textarea")).filter((formControlElement) => formControlElement.matches(selector))[0];
    return { content: textToMatch, formControl: labelledFormControl };
  });
}
function assertNotNullOrUndefined(matcher) {
  if (matcher == null) throw new Error("It looks like " + matcher + " was passed instead of a matcher. Did you do something like getByText(" + matcher + ")?");
}
function fuzzyMatches(textToMatch, node, matcher, normalizer) {
  if (typeof textToMatch != "string") return false;
  assertNotNullOrUndefined(matcher);
  let normalizedText = normalizer(textToMatch);
  return typeof matcher == "string" || typeof matcher == "number" ? normalizedText.toLowerCase().includes(matcher.toString().toLowerCase()) : typeof matcher == "function" ? matcher(normalizedText, node) : matchRegExp(matcher, normalizedText);
}
function matches2(textToMatch, node, matcher, normalizer) {
  if (typeof textToMatch != "string") return false;
  assertNotNullOrUndefined(matcher);
  let normalizedText = normalizer(textToMatch);
  return matcher instanceof Function ? matcher(normalizedText, node) : matcher instanceof RegExp ? matchRegExp(matcher, normalizedText) : normalizedText === String(matcher);
}
function getDefaultNormalizer(_temp) {
  let { trim = true, collapseWhitespace = true } = _temp === void 0 ? {} : _temp;
  return (text) => {
    let normalizedText = text;
    return normalizedText = trim ? normalizedText.trim() : normalizedText, normalizedText = collapseWhitespace ? normalizedText.replace(/\s+/g, " ") : normalizedText, normalizedText;
  };
}
function makeNormalizer(_ref) {
  let { trim, collapseWhitespace, normalizer } = _ref;
  if (!normalizer) return getDefaultNormalizer({ trim, collapseWhitespace });
  if (typeof trim < "u" || typeof collapseWhitespace < "u") throw new Error('trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
  return normalizer;
}
function matchRegExp(matcher, text) {
  let match = matcher.test(text);
  return matcher.global && matcher.lastIndex !== 0 && (console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp."), matcher.lastIndex = 0), match;
}
function getNodeText(node) {
  return node.matches("input[type=submit], input[type=button], input[type=reset]") ? node.value : Array.from(node.childNodes).filter((child) => child.nodeType === TEXT_NODE22 && !!child.textContent).map((c3) => c3.textContent).join("");
}
var elementRoleList2 = buildElementRoleList2(import_aria_query3.elementRoles);
function isSubtreeInaccessible(element) {
  return element.hidden === true || element.getAttribute("aria-hidden") === "true" || element.ownerDocument.defaultView.getComputedStyle(element).display === "none";
}
function isInaccessible(element, options2) {
  options2 === void 0 && (options2 = {});
  let { isSubtreeInaccessible: isSubtreeInaccessibleImpl = isSubtreeInaccessible } = options2;
  if (element.ownerDocument.defaultView.getComputedStyle(element).visibility === "hidden") return true;
  let currentElement = element;
  for (; currentElement; ) {
    if (isSubtreeInaccessibleImpl(currentElement)) return true;
    currentElement = currentElement.parentElement;
  }
  return false;
}
function getImplicitAriaRoles2(currentNode) {
  for (let { match, roles: roles3 } of elementRoleList2) if (match(currentNode)) return [...roles3];
  return [];
}
function buildElementRoleList2(elementRolesMap) {
  function makeElementSelector(_ref) {
    let { name: name2, attributes } = _ref;
    return "" + name2 + attributes.map((_ref2) => {
      let { name: attributeName, value: value2, constraints = [] } = _ref2, shouldNotExist = constraints.indexOf("undefined") !== -1, shouldBeNonEmpty = constraints.indexOf("set") !== -1;
      return typeof value2 < "u" ? "[" + attributeName + '="' + value2 + '"]' : shouldNotExist ? ":not([" + attributeName + "])" : shouldBeNonEmpty ? "[" + attributeName + "]:not([" + attributeName + '=""])' : "[" + attributeName + "]";
    }).join("");
  }
  function getSelectorSpecificity(_ref3) {
    let { attributes = [] } = _ref3;
    return attributes.length;
  }
  function bySelectorSpecificity(_ref4, _ref5) {
    let { specificity: leftSpecificity } = _ref4, { specificity: rightSpecificity } = _ref5;
    return rightSpecificity - leftSpecificity;
  }
  function match(element) {
    let { attributes = [] } = element, typeTextIndex = attributes.findIndex((attribute) => attribute.value && attribute.name === "type" && attribute.value === "text");
    typeTextIndex >= 0 && (attributes = [...attributes.slice(0, typeTextIndex), ...attributes.slice(typeTextIndex + 1)]);
    let selector = makeElementSelector({ ...element, attributes });
    return (node) => typeTextIndex >= 0 && node.type !== "text" ? false : node.matches(selector);
  }
  let result2 = [];
  for (let [element, roles3] of elementRolesMap.entries()) result2 = [...result2, { match: match(element), roles: Array.from(roles3), specificity: getSelectorSpecificity(element) }];
  return result2.sort(bySelectorSpecificity);
}
function getRoles(container, _temp) {
  let { hidden = false } = _temp === void 0 ? {} : _temp;
  function flattenDOM(node) {
    return [node, ...Array.from(node.children).reduce((acc, child) => [...acc, ...flattenDOM(child)], [])];
  }
  return flattenDOM(container).filter((element) => hidden === false ? isInaccessible(element) === false : true).reduce((acc, node) => {
    let roles3 = [];
    return node.hasAttribute("role") ? roles3 = node.getAttribute("role").split(" ").slice(0, 1) : roles3 = getImplicitAriaRoles2(node), roles3.reduce((rolesAcc, role) => Array.isArray(rolesAcc[role]) ? { ...rolesAcc, [role]: [...rolesAcc[role], node] } : { ...rolesAcc, [role]: [node] }, acc);
  }, {});
}
function prettyRoles(dom, _ref6) {
  let { hidden, includeDescription } = _ref6, roles3 = getRoles(dom, { hidden });
  return Object.entries(roles3).filter((_ref7) => {
    let [role] = _ref7;
    return role !== "generic";
  }).map((_ref8) => {
    let [role, elements] = _ref8, delimiterBar = "-".repeat(50), elementsString = elements.map((el) => {
      let nameString = 'Name "' + computeAccessibleName2(el, { computedStyleSupportsPseudoElements: getConfig22().computedStyleSupportsPseudoElements }) + `":
`, domString = prettyDOM(el.cloneNode(false));
      if (includeDescription) {
        let descriptionString = 'Description "' + computeAccessibleDescription2(el, { computedStyleSupportsPseudoElements: getConfig22().computedStyleSupportsPseudoElements }) + `":
`;
        return "" + nameString + descriptionString + domString;
      }
      return "" + nameString + domString;
    }).join(`

`);
    return role + `:

` + elementsString + `

` + delimiterBar;
  }).join(`
`);
}
var logRoles = function(dom, _temp2) {
  let { hidden = false } = _temp2 === void 0 ? {} : _temp2;
  return console.log(prettyRoles(dom, { hidden }));
};
function computeAriaSelected(element) {
  return element.tagName === "OPTION" ? element.selected : checkBooleanAttribute(element, "aria-selected");
}
function computeAriaBusy(element) {
  return element.getAttribute("aria-busy") === "true";
}
function computeAriaChecked(element) {
  if (!("indeterminate" in element && element.indeterminate)) return "checked" in element ? element.checked : checkBooleanAttribute(element, "aria-checked");
}
function computeAriaPressed(element) {
  return checkBooleanAttribute(element, "aria-pressed");
}
function computeAriaCurrent(element) {
  var _ref9, _checkBooleanAttribut;
  return (_ref9 = (_checkBooleanAttribut = checkBooleanAttribute(element, "aria-current")) != null ? _checkBooleanAttribut : element.getAttribute("aria-current")) != null ? _ref9 : false;
}
function computeAriaExpanded(element) {
  return checkBooleanAttribute(element, "aria-expanded");
}
function checkBooleanAttribute(element, attribute) {
  let attributeValue = element.getAttribute(attribute);
  if (attributeValue === "true") return true;
  if (attributeValue === "false") return false;
}
function computeHeadingLevel(element) {
  let implicitHeadingLevels = { H1: 1, H2: 2, H3: 3, H4: 4, H5: 5, H6: 6 };
  return element.getAttribute("aria-level") && Number(element.getAttribute("aria-level")) || implicitHeadingLevels[element.tagName];
}
function computeAriaValueNow(element) {
  let valueNow = element.getAttribute("aria-valuenow");
  return valueNow === null ? void 0 : +valueNow;
}
function computeAriaValueMax(element) {
  let valueMax = element.getAttribute("aria-valuemax");
  return valueMax === null ? void 0 : +valueMax;
}
function computeAriaValueMin(element) {
  let valueMin = element.getAttribute("aria-valuemin");
  return valueMin === null ? void 0 : +valueMin;
}
function computeAriaValueText(element) {
  let valueText = element.getAttribute("aria-valuetext");
  return valueText === null ? void 0 : valueText;
}
var normalize2 = getDefaultNormalizer();
function escapeRegExp(string) {
  return string.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
function getRegExpMatcher(string) {
  return new RegExp(escapeRegExp(string.toLowerCase()), "i");
}
function makeSuggestion(queryName, element, content, _ref) {
  let { variant, name: name2 } = _ref, warning = "", queryOptions = {}, queryArgs = [["Role", "TestId"].includes(queryName) ? content : getRegExpMatcher(content)];
  name2 && (queryOptions.name = getRegExpMatcher(name2)), queryName === "Role" && isInaccessible(element) && (queryOptions.hidden = true, warning = `Element is inaccessible. This means that the element and all its children are invisible to screen readers.
    If you are using the aria-hidden prop, make sure this is the right choice for your case.
    `), Object.keys(queryOptions).length > 0 && queryArgs.push(queryOptions);
  let queryMethod = variant + "By" + queryName;
  return { queryName, queryMethod, queryArgs, variant, warning, toString() {
    warning && console.warn(warning);
    let [text, options2] = queryArgs;
    return text = typeof text == "string" ? "'" + text + "'" : text, options2 = options2 ? ", { " + Object.entries(options2).map((_ref2) => {
      let [k22, v6] = _ref2;
      return k22 + ": " + v6;
    }).join(", ") + " }" : "", queryMethod + "(" + text + options2 + ")";
  } };
}
function canSuggest(currentMethod, requestedMethod, data) {
  return data && (!requestedMethod || requestedMethod.toLowerCase() === currentMethod.toLowerCase());
}
function getSuggestedQuery(element, variant, method) {
  var _element$getAttribute, _getImplicitAriaRoles;
  if (variant === void 0 && (variant = "get"), element.matches(getConfig22().defaultIgnore)) return;
  let role = (_element$getAttribute = element.getAttribute("role")) != null ? _element$getAttribute : (_getImplicitAriaRoles = getImplicitAriaRoles2(element)) == null ? void 0 : _getImplicitAriaRoles[0];
  if (role !== "generic" && canSuggest("Role", method, role)) return makeSuggestion("Role", element, role, { variant, name: computeAccessibleName2(element, { computedStyleSupportsPseudoElements: getConfig22().computedStyleSupportsPseudoElements }) });
  let labelText = getLabels3(document, element).map((label) => label.content).join(" ");
  if (canSuggest("LabelText", method, labelText)) return makeSuggestion("LabelText", element, labelText, { variant });
  let placeholderText = element.getAttribute("placeholder");
  if (canSuggest("PlaceholderText", method, placeholderText)) return makeSuggestion("PlaceholderText", element, placeholderText, { variant });
  let textContent = normalize2(getNodeText(element));
  if (canSuggest("Text", method, textContent)) return makeSuggestion("Text", element, textContent, { variant });
  if (canSuggest("DisplayValue", method, element.value)) return makeSuggestion("DisplayValue", element, normalize2(element.value), { variant });
  let alt = element.getAttribute("alt");
  if (canSuggest("AltText", method, alt)) return makeSuggestion("AltText", element, alt, { variant });
  let title = element.getAttribute("title");
  if (canSuggest("Title", method, title)) return makeSuggestion("Title", element, title, { variant });
  let testId = element.getAttribute(getConfig22().testIdAttribute);
  if (canSuggest("TestId", method, testId)) return makeSuggestion("TestId", element, testId, { variant });
}
function copyStackTrace(target, source2) {
  target.stack = source2.stack.replace(source2.message, target.message);
}
function waitFor(callback, _ref) {
  let { container = getDocument(), timeout = getConfig22().asyncUtilTimeout, showOriginalStackTrace = getConfig22().showOriginalStackTrace, stackTraceError, interval = 50, onTimeout = (error) => (Object.defineProperty(error, "message", { value: getConfig22().getElementError(error.message, container).message }), error), mutationObserverOptions = { subtree: true, childList: true, attributes: true, characterData: true } } = _ref;
  if (typeof callback != "function") throw new TypeError("Received `callback` arg must be a function");
  return new Promise(async (resolve, reject) => {
    let lastError, intervalId, observer, finished = false, promiseStatus = "idle", overallTimeoutTimer = setTimeout(handleTimeout, timeout), usingJestFakeTimers = jestFakeTimersAreEnabled();
    if (usingJestFakeTimers) {
      let { unstable_advanceTimersWrapper: advanceTimersWrapper } = getConfig22();
      for (checkCallback(); !finished; ) {
        if (!jestFakeTimersAreEnabled()) {
          let error = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
          showOriginalStackTrace || copyStackTrace(error, stackTraceError), reject(error);
          return;
        }
        if (await advanceTimersWrapper(async () => {
          jest.advanceTimersByTime(interval);
        }), finished) break;
        checkCallback();
      }
    } else {
      try {
        checkContainerType(container);
      } catch (e2) {
        reject(e2);
        return;
      }
      intervalId = setInterval(checkRealTimersCallback, interval);
      let { MutationObserver } = getWindowFromNode(container);
      observer = new MutationObserver(checkRealTimersCallback), observer.observe(container, mutationObserverOptions), checkCallback();
    }
    function onDone(error, result2) {
      finished = true, clearTimeout(overallTimeoutTimer), usingJestFakeTimers || (clearInterval(intervalId), observer.disconnect()), error ? reject(error) : resolve(result2);
    }
    function checkRealTimersCallback() {
      if (jestFakeTimersAreEnabled()) {
        let error = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
        return showOriginalStackTrace || copyStackTrace(error, stackTraceError), reject(error);
      } else return checkCallback();
    }
    function checkCallback() {
      if (promiseStatus !== "pending") try {
        let result2 = runWithExpensiveErrorDiagnosticsDisabled(callback);
        typeof (result2 == null ? void 0 : result2.then) == "function" ? (promiseStatus = "pending", result2.then((resolvedValue) => {
          promiseStatus = "resolved", onDone(null, resolvedValue);
        }, (rejectedValue) => {
          promiseStatus = "rejected", lastError = rejectedValue;
        })) : onDone(null, result2);
      } catch (error) {
        lastError = error;
      }
    }
    function handleTimeout() {
      let error;
      lastError ? (error = lastError, !showOriginalStackTrace && error.name === "TestingLibraryElementError" && copyStackTrace(error, stackTraceError)) : (error = new Error("Timed out in waitFor."), showOriginalStackTrace || copyStackTrace(error, stackTraceError)), onDone(onTimeout(error), null);
    }
  });
}
function waitForWrapper(callback, options2) {
  let stackTraceError = new Error("STACK_TRACE_MESSAGE");
  return getConfig22().asyncWrapper(() => waitFor(callback, { stackTraceError, ...options2 }));
}
function getElementError(message, container) {
  return getConfig22().getElementError(message, container);
}
function getMultipleElementsFoundError(message, container) {
  return getElementError(message + "\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).", container);
}
function queryAllByAttribute(attribute, container, text, _temp) {
  let { exact = true, collapseWhitespace, trim, normalizer } = _temp === void 0 ? {} : _temp, matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({ collapseWhitespace, trim, normalizer });
  return Array.from(container.querySelectorAll("[" + attribute + "]")).filter((node) => matcher(node.getAttribute(attribute), node, text, matchNormalizer));
}
function queryByAttribute(attribute, container, text, options2) {
  let els = queryAllByAttribute(attribute, container, text, options2);
  if (els.length > 1) throw getMultipleElementsFoundError("Found multiple elements by [" + attribute + "=" + text + "]", container);
  return els[0] || null;
}
function makeSingleQuery(allQuery, getMultipleError2) {
  return function(container) {
    for (var _len = arguments.length, args2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args2[_key - 1] = arguments[_key];
    let els = allQuery(container, ...args2);
    if (els.length > 1) {
      let elementStrings = els.map((element) => getElementError(null, element).message).join(`

`);
      throw getMultipleElementsFoundError(getMultipleError2(container, ...args2) + `

Here are the matching elements:

` + elementStrings, container);
    }
    return els[0] || null;
  };
}
function getSuggestionError(suggestion, container) {
  return getConfig22().getElementError(`A better query is available, try this:
` + suggestion.toString() + `
`, container);
}
function makeGetAllQuery(allQuery, getMissingError2) {
  return function(container) {
    for (var _len2 = arguments.length, args2 = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args2[_key2 - 1] = arguments[_key2];
    let els = allQuery(container, ...args2);
    if (!els.length) throw getConfig22().getElementError(getMissingError2(container, ...args2), container);
    return els;
  };
}
function makeFindQuery(getter) {
  return (container, text, options2, waitForOptions) => waitForWrapper(() => getter(container, text, options2), { container, ...waitForOptions });
}
var wrapSingleQueryWithSuggestion = (query, queryAllByName, variant) => function(container) {
  for (var _len3 = arguments.length, args2 = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) args2[_key3 - 1] = arguments[_key3];
  let element = query(container, ...args2), [{ suggest = getConfig22().throwSuggestions } = {}] = args2.slice(-1);
  if (element && suggest) {
    let suggestion = getSuggestedQuery(element, variant);
    if (suggestion && !queryAllByName.endsWith(suggestion.queryName)) throw getSuggestionError(suggestion.toString(), container);
  }
  return element;
};
var wrapAllByQueryWithSuggestion = (query, queryAllByName, variant) => function(container) {
  for (var _len4 = arguments.length, args2 = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) args2[_key4 - 1] = arguments[_key4];
  let els = query(container, ...args2), [{ suggest = getConfig22().throwSuggestions } = {}] = args2.slice(-1);
  if (els.length && suggest) {
    let uniqueSuggestionMessages = [...new Set(els.map((element) => {
      var _getSuggestedQuery;
      return (_getSuggestedQuery = getSuggestedQuery(element, variant)) == null ? void 0 : _getSuggestedQuery.toString();
    }))];
    if (uniqueSuggestionMessages.length === 1 && !queryAllByName.endsWith(getSuggestedQuery(els[0], variant).queryName)) throw getSuggestionError(uniqueSuggestionMessages[0], container);
  }
  return els;
};
function buildQueries(queryAllBy, getMultipleError2, getMissingError2) {
  let queryBy = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllBy, getMultipleError2), queryAllBy.name, "query"), getAllBy = makeGetAllQuery(queryAllBy, getMissingError2), getBy = makeSingleQuery(getAllBy, getMultipleError2), getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "get"), getAllWithSuggestions = wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name.replace("query", "get"), "getAll"), findAllBy = makeFindQuery(wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name, "findAll")), findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, "find"));
  return [queryBy, getAllWithSuggestions, getByWithSuggestions, findAllBy, findBy];
}
var queryHelpers = Object.freeze({ __proto__: null, getElementError, wrapAllByQueryWithSuggestion, wrapSingleQueryWithSuggestion, getMultipleElementsFoundError, queryAllByAttribute, queryByAttribute, makeSingleQuery, makeGetAllQuery, makeFindQuery, buildQueries });
function queryAllLabels(container) {
  return Array.from(container.querySelectorAll("label,input")).map((node) => ({ node, textToMatch: getLabelContent(node) })).filter((_ref) => {
    let { textToMatch } = _ref;
    return textToMatch !== null;
  });
}
var queryAllLabelsByText = function(container, text, _temp) {
  let { exact = true, trim, collapseWhitespace, normalizer } = _temp === void 0 ? {} : _temp, matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({ collapseWhitespace, trim, normalizer });
  return queryAllLabels(container).filter((_ref2) => {
    let { node, textToMatch } = _ref2;
    return matcher(textToMatch, node, text, matchNormalizer);
  }).map((_ref3) => {
    let { node } = _ref3;
    return node;
  });
};
var queryAllByLabelText = function(container, text, _temp2) {
  let { selector = "*", exact = true, collapseWhitespace, trim, normalizer } = _temp2 === void 0 ? {} : _temp2;
  checkContainerType(container);
  let matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({ collapseWhitespace, trim, normalizer }), matchingLabelledElements = Array.from(container.querySelectorAll("*")).filter((element) => getRealLabels(element).length || element.hasAttribute("aria-labelledby")).reduce((labelledElements, labelledElement) => {
    let labelList = getLabels3(container, labelledElement, { selector });
    labelList.filter((label) => !!label.formControl).forEach((label) => {
      matcher(label.content, label.formControl, text, matchNormalizer) && label.formControl && labelledElements.push(label.formControl);
    });
    let labelsValue = labelList.filter((label) => !!label.content).map((label) => label.content);
    return matcher(labelsValue.join(" "), labelledElement, text, matchNormalizer) && labelledElements.push(labelledElement), labelsValue.length > 1 && labelsValue.forEach((labelValue, index) => {
      matcher(labelValue, labelledElement, text, matchNormalizer) && labelledElements.push(labelledElement);
      let labelsFiltered = [...labelsValue];
      labelsFiltered.splice(index, 1), labelsFiltered.length > 1 && matcher(labelsFiltered.join(" "), labelledElement, text, matchNormalizer) && labelledElements.push(labelledElement);
    }), labelledElements;
  }, []).concat(queryAllByAttribute("aria-label", container, text, { exact, normalizer: matchNormalizer }));
  return Array.from(new Set(matchingLabelledElements)).filter((element) => element.matches(selector));
};
var getAllByLabelText = function(container, text) {
  for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) rest[_key - 2] = arguments[_key];
  let els = queryAllByLabelText(container, text, ...rest);
  if (!els.length) {
    let labels = queryAllLabelsByText(container, text, ...rest);
    if (labels.length) {
      let tagNames = labels.map((label) => getTagNameOfElementAssociatedWithLabelViaFor(container, label)).filter((tagName) => !!tagName);
      throw tagNames.length ? getConfig22().getElementError(tagNames.map((tagName) => "Found a label with the text of: " + text + ", however the element associated with this label (<" + tagName + " />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <" + tagName + " />, you can use aria-label or aria-labelledby instead.").join(`

`), container) : getConfig22().getElementError("Found a label with the text of: " + text + `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`, container);
    } else throw getConfig22().getElementError("Unable to find a label with the text of: " + text, container);
  }
  return els;
};
function getTagNameOfElementAssociatedWithLabelViaFor(container, label) {
  let htmlFor = label.getAttribute("for");
  if (!htmlFor) return null;
  let element = container.querySelector('[id="' + htmlFor + '"]');
  return element ? element.tagName.toLowerCase() : null;
}
var getMultipleError$7 = (c3, text) => "Found multiple elements with the text of: " + text;
var queryByLabelText = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllByLabelText, getMultipleError$7), queryAllByLabelText.name, "query");
var getByLabelText = makeSingleQuery(getAllByLabelText, getMultipleError$7);
var findAllByLabelText = makeFindQuery(wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "findAll"));
var findByLabelText = makeFindQuery(wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "find"));
var getAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(getAllByLabelText, getAllByLabelText.name, "getAll");
var getByLabelTextWithSuggestions = wrapSingleQueryWithSuggestion(getByLabelText, getAllByLabelText.name, "get");
var queryAllByLabelTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByLabelText, queryAllByLabelText.name, "queryAll");
var queryAllByPlaceholderText = function() {
  for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) args2[_key] = arguments[_key];
  return checkContainerType(args2[0]), queryAllByAttribute("placeholder", ...args2);
};
var getMultipleError$6 = (c3, text) => "Found multiple elements with the placeholder text of: " + text;
var getMissingError$6 = (c3, text) => "Unable to find an element with the placeholder text of: " + text;
var queryAllByPlaceholderTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByPlaceholderText, queryAllByPlaceholderText.name, "queryAll");
var [queryByPlaceholderText, getAllByPlaceholderText, getByPlaceholderText, findAllByPlaceholderText, findByPlaceholderText] = buildQueries(queryAllByPlaceholderText, getMultipleError$6, getMissingError$6);
var queryAllByText = function(container, text, _temp) {
  let { selector = "*", exact = true, collapseWhitespace, trim, ignore = getConfig22().defaultIgnore, normalizer } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  let matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({ collapseWhitespace, trim, normalizer }), baseArray = [];
  return typeof container.matches == "function" && container.matches(selector) && (baseArray = [container]), [...baseArray, ...Array.from(container.querySelectorAll(selector))].filter((node) => !ignore || !node.matches(ignore)).filter((node) => matcher(getNodeText(node), node, text, matchNormalizer));
};
var getMultipleError$5 = (c3, text) => "Found multiple elements with the text: " + text;
var getMissingError$5 = function(c3, text, options2) {
  options2 === void 0 && (options2 = {});
  let { collapseWhitespace, trim, normalizer, selector } = options2, normalizedText = makeNormalizer({ collapseWhitespace, trim, normalizer })(text.toString()), isNormalizedDifferent = normalizedText !== text.toString(), isCustomSelector = (selector ?? "*") !== "*";
  return "Unable to find an element with the text: " + (isNormalizedDifferent ? normalizedText + " (normalized from '" + text + "')" : text) + (isCustomSelector ? ", which matches selector '" + selector + "'" : "") + ". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.";
};
var queryAllByTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByText, queryAllByText.name, "queryAll");
var [queryByText, getAllByText, getByText, findAllByText, findByText] = buildQueries(queryAllByText, getMultipleError$5, getMissingError$5);
var queryAllByDisplayValue = function(container, value2, _temp) {
  let { exact = true, collapseWhitespace, trim, normalizer } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  let matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({ collapseWhitespace, trim, normalizer });
  return Array.from(container.querySelectorAll("input,textarea,select")).filter((node) => node.tagName === "SELECT" ? Array.from(node.options).filter((option) => option.selected).some((optionNode) => matcher(getNodeText(optionNode), optionNode, value2, matchNormalizer)) : matcher(node.value, node, value2, matchNormalizer));
};
var getMultipleError$4 = (c3, value2) => "Found multiple elements with the display value: " + value2 + ".";
var getMissingError$4 = (c3, value2) => "Unable to find an element with the display value: " + value2 + ".";
var queryAllByDisplayValueWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByDisplayValue, queryAllByDisplayValue.name, "queryAll");
var [queryByDisplayValue, getAllByDisplayValue, getByDisplayValue, findAllByDisplayValue, findByDisplayValue] = buildQueries(queryAllByDisplayValue, getMultipleError$4, getMissingError$4);
var VALID_TAG_REGEXP = /^(img|input|area|.+-.+)$/i;
var queryAllByAltText = function(container, alt, options2) {
  return options2 === void 0 && (options2 = {}), checkContainerType(container), queryAllByAttribute("alt", container, alt, options2).filter((node) => VALID_TAG_REGEXP.test(node.tagName));
};
var getMultipleError$3 = (c3, alt) => "Found multiple elements with the alt text: " + alt;
var getMissingError$3 = (c3, alt) => "Unable to find an element with the alt text: " + alt;
var queryAllByAltTextWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByAltText, queryAllByAltText.name, "queryAll");
var [queryByAltText, getAllByAltText, getByAltText, findAllByAltText, findByAltText] = buildQueries(queryAllByAltText, getMultipleError$3, getMissingError$3);
var isSvgTitle = (node) => {
  var _node$parentElement;
  return node.tagName.toLowerCase() === "title" && ((_node$parentElement = node.parentElement) == null ? void 0 : _node$parentElement.tagName.toLowerCase()) === "svg";
};
var queryAllByTitle = function(container, text, _temp) {
  let { exact = true, collapseWhitespace, trim, normalizer } = _temp === void 0 ? {} : _temp;
  checkContainerType(container);
  let matcher = exact ? matches2 : fuzzyMatches, matchNormalizer = makeNormalizer({ collapseWhitespace, trim, normalizer });
  return Array.from(container.querySelectorAll("[title], svg > title")).filter((node) => matcher(node.getAttribute("title"), node, text, matchNormalizer) || isSvgTitle(node) && matcher(getNodeText(node), node, text, matchNormalizer));
};
var getMultipleError$2 = (c3, title) => "Found multiple elements with the title: " + title + ".";
var getMissingError$2 = (c3, title) => "Unable to find an element with the title: " + title + ".";
var queryAllByTitleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTitle, queryAllByTitle.name, "queryAll");
var [queryByTitle, getAllByTitle, getByTitle, findAllByTitle, findByTitle] = buildQueries(queryAllByTitle, getMultipleError$2, getMissingError$2);
var queryAllByRole = function(container, role, _temp) {
  let { hidden = getConfig22().defaultHidden, name: name2, description, queryFallbacks = false, selected, busy, checked, pressed, current, level, expanded, value: { now: valueNow, min: valueMin, max: valueMax, text: valueText } = {} } = _temp === void 0 ? {} : _temp;
  if (checkContainerType(container), selected !== void 0) {
    var _allRoles$get;
    if (((_allRoles$get = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get.props["aria-selected"]) === void 0) throw new Error('"aria-selected" is not supported on role "' + role + '".');
  }
  if (busy !== void 0) {
    var _allRoles$get2;
    if (((_allRoles$get2 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get2.props["aria-busy"]) === void 0) throw new Error('"aria-busy" is not supported on role "' + role + '".');
  }
  if (checked !== void 0) {
    var _allRoles$get3;
    if (((_allRoles$get3 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get3.props["aria-checked"]) === void 0) throw new Error('"aria-checked" is not supported on role "' + role + '".');
  }
  if (pressed !== void 0) {
    var _allRoles$get4;
    if (((_allRoles$get4 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get4.props["aria-pressed"]) === void 0) throw new Error('"aria-pressed" is not supported on role "' + role + '".');
  }
  if (current !== void 0) {
    var _allRoles$get5;
    if (((_allRoles$get5 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get5.props["aria-current"]) === void 0) throw new Error('"aria-current" is not supported on role "' + role + '".');
  }
  if (level !== void 0 && role !== "heading") throw new Error('Role "' + role + '" cannot have "level" property.');
  if (valueNow !== void 0) {
    var _allRoles$get6;
    if (((_allRoles$get6 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get6.props["aria-valuenow"]) === void 0) throw new Error('"aria-valuenow" is not supported on role "' + role + '".');
  }
  if (valueMax !== void 0) {
    var _allRoles$get7;
    if (((_allRoles$get7 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get7.props["aria-valuemax"]) === void 0) throw new Error('"aria-valuemax" is not supported on role "' + role + '".');
  }
  if (valueMin !== void 0) {
    var _allRoles$get8;
    if (((_allRoles$get8 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get8.props["aria-valuemin"]) === void 0) throw new Error('"aria-valuemin" is not supported on role "' + role + '".');
  }
  if (valueText !== void 0) {
    var _allRoles$get9;
    if (((_allRoles$get9 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get9.props["aria-valuetext"]) === void 0) throw new Error('"aria-valuetext" is not supported on role "' + role + '".');
  }
  if (expanded !== void 0) {
    var _allRoles$get10;
    if (((_allRoles$get10 = import_aria_query3.roles.get(role)) == null ? void 0 : _allRoles$get10.props["aria-expanded"]) === void 0) throw new Error('"aria-expanded" is not supported on role "' + role + '".');
  }
  let subtreeIsInaccessibleCache = /* @__PURE__ */ new WeakMap();
  function cachedIsSubtreeInaccessible(element) {
    return subtreeIsInaccessibleCache.has(element) || subtreeIsInaccessibleCache.set(element, isSubtreeInaccessible(element)), subtreeIsInaccessibleCache.get(element);
  }
  return Array.from(container.querySelectorAll(makeRoleSelector(role))).filter((node) => {
    if (node.hasAttribute("role")) {
      let roleValue = node.getAttribute("role");
      if (queryFallbacks) return roleValue.split(" ").filter(Boolean).some((roleAttributeToken) => roleAttributeToken === role);
      let [firstRoleAttributeToken] = roleValue.split(" ");
      return firstRoleAttributeToken === role;
    }
    return getImplicitAriaRoles2(node).some((implicitRole) => implicitRole === role);
  }).filter((element) => {
    if (selected !== void 0) return selected === computeAriaSelected(element);
    if (busy !== void 0) return busy === computeAriaBusy(element);
    if (checked !== void 0) return checked === computeAriaChecked(element);
    if (pressed !== void 0) return pressed === computeAriaPressed(element);
    if (current !== void 0) return current === computeAriaCurrent(element);
    if (expanded !== void 0) return expanded === computeAriaExpanded(element);
    if (level !== void 0) return level === computeHeadingLevel(element);
    if (valueNow !== void 0 || valueMax !== void 0 || valueMin !== void 0 || valueText !== void 0) {
      let valueMatches = true;
      if (valueNow !== void 0 && valueMatches && (valueMatches = valueNow === computeAriaValueNow(element)), valueMax !== void 0 && valueMatches && (valueMatches = valueMax === computeAriaValueMax(element)), valueMin !== void 0 && valueMatches && (valueMatches = valueMin === computeAriaValueMin(element)), valueText !== void 0) {
        var _computeAriaValueText;
        valueMatches && (valueMatches = matches2((_computeAriaValueText = computeAriaValueText(element)) != null ? _computeAriaValueText : null, element, valueText, (text) => text));
      }
      return valueMatches;
    }
    return true;
  }).filter((element) => name2 === void 0 ? true : matches2(computeAccessibleName2(element, { computedStyleSupportsPseudoElements: getConfig22().computedStyleSupportsPseudoElements }), element, name2, (text) => text)).filter((element) => description === void 0 ? true : matches2(computeAccessibleDescription2(element, { computedStyleSupportsPseudoElements: getConfig22().computedStyleSupportsPseudoElements }), element, description, (text) => text)).filter((element) => hidden === false ? isInaccessible(element, { isSubtreeInaccessible: cachedIsSubtreeInaccessible }) === false : true);
};
function makeRoleSelector(role) {
  var _roleElements$get;
  let explicitRoleSelector = '*[role~="' + role + '"]', roleRelations = (_roleElements$get = import_aria_query3.roleElements.get(role)) != null ? _roleElements$get : /* @__PURE__ */ new Set(), implicitRoleSelectors = new Set(Array.from(roleRelations).map((_ref) => {
    let { name: name2 } = _ref;
    return name2;
  }));
  return [explicitRoleSelector].concat(Array.from(implicitRoleSelectors)).join(",");
}
var getNameHint = (name2) => {
  let nameHint = "";
  return name2 === void 0 ? nameHint = "" : typeof name2 == "string" ? nameHint = ' and name "' + name2 + '"' : nameHint = " and name `" + name2 + "`", nameHint;
};
var getMultipleError$1 = function(c3, role, _temp2) {
  let { name: name2 } = _temp2 === void 0 ? {} : _temp2;
  return 'Found multiple elements with the role "' + role + '"' + getNameHint(name2);
};
var getMissingError$1 = function(container, role, _temp3) {
  let { hidden = getConfig22().defaultHidden, name: name2, description } = _temp3 === void 0 ? {} : _temp3;
  if (getConfig22()._disableExpensiveErrorDiagnostics) return 'Unable to find role="' + role + '"' + getNameHint(name2);
  let roles3 = "";
  Array.from(container.children).forEach((childElement) => {
    roles3 += prettyRoles(childElement, { hidden, includeDescription: description !== void 0 });
  });
  let roleMessage;
  roles3.length === 0 ? hidden === false ? roleMessage = "There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole" : roleMessage = "There are no available roles." : roleMessage = (`
Here are the ` + (hidden === false ? "accessible" : "available") + ` roles:

  ` + roles3.replace(/\n/g, `
  `).replace(/\n\s\s\n/g, `

`) + `
`).trim();
  let nameHint = "";
  name2 === void 0 ? nameHint = "" : typeof name2 == "string" ? nameHint = ' and name "' + name2 + '"' : nameHint = " and name `" + name2 + "`";
  let descriptionHint = "";
  return description === void 0 ? descriptionHint = "" : typeof description == "string" ? descriptionHint = ' and description "' + description + '"' : descriptionHint = " and description `" + description + "`", (`
Unable to find an ` + (hidden === false ? "accessible " : "") + 'element with the role "' + role + '"' + nameHint + descriptionHint + `

` + roleMessage).trim();
};
var queryAllByRoleWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByRole, queryAllByRole.name, "queryAll");
var [queryByRole, getAllByRole, getByRole, findAllByRole, findByRole] = buildQueries(queryAllByRole, getMultipleError$1, getMissingError$1);
var getTestIdAttribute = () => getConfig22().testIdAttribute;
var queryAllByTestId = function() {
  for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) args2[_key] = arguments[_key];
  return checkContainerType(args2[0]), queryAllByAttribute(getTestIdAttribute(), ...args2);
};
var getMultipleError = (c3, id) => "Found multiple elements by: [" + getTestIdAttribute() + '="' + id + '"]';
var getMissingError = (c3, id) => "Unable to find an element by: [" + getTestIdAttribute() + '="' + id + '"]';
var queryAllByTestIdWithSuggestions = wrapAllByQueryWithSuggestion(queryAllByTestId, queryAllByTestId.name, "queryAll");
var [queryByTestId, getAllByTestId, getByTestId, findAllByTestId, findByTestId] = buildQueries(queryAllByTestId, getMultipleError, getMissingError);
var queries = Object.freeze({ __proto__: null, queryAllByLabelText: queryAllByLabelTextWithSuggestions, queryByLabelText, getAllByLabelText: getAllByLabelTextWithSuggestions, getByLabelText: getByLabelTextWithSuggestions, findAllByLabelText, findByLabelText, queryByPlaceholderText, queryAllByPlaceholderText: queryAllByPlaceholderTextWithSuggestions, getByPlaceholderText, getAllByPlaceholderText, findAllByPlaceholderText, findByPlaceholderText, queryByText, queryAllByText: queryAllByTextWithSuggestions, getByText, getAllByText, findAllByText, findByText, queryByDisplayValue, queryAllByDisplayValue: queryAllByDisplayValueWithSuggestions, getByDisplayValue, getAllByDisplayValue, findAllByDisplayValue, findByDisplayValue, queryByAltText, queryAllByAltText: queryAllByAltTextWithSuggestions, getByAltText, getAllByAltText, findAllByAltText, findByAltText, queryByTitle, queryAllByTitle: queryAllByTitleWithSuggestions, getByTitle, getAllByTitle, findAllByTitle, findByTitle, queryByRole, queryAllByRole: queryAllByRoleWithSuggestions, getAllByRole, getByRole, findAllByRole, findByRole, queryByTestId, queryAllByTestId: queryAllByTestIdWithSuggestions, getByTestId, getAllByTestId, findAllByTestId, findByTestId });
function getQueriesForElement(element, queries$1, initialValue2) {
  return queries$1 === void 0 && (queries$1 = queries), initialValue2 === void 0 && (initialValue2 = {}), Object.keys(queries$1).reduce((helpers, key2) => {
    let fn3 = queries$1[key2];
    return helpers[key2] = fn3.bind(null, element), helpers;
  }, initialValue2);
}
var isRemoved = (result2) => !result2 || Array.isArray(result2) && !result2.length;
function initialCheck(elements) {
  if (isRemoved(elements)) throw new Error("The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.");
}
async function waitForElementToBeRemoved(callback, options2) {
  let timeoutError = new Error("Timed out in waitForElementToBeRemoved.");
  if (typeof callback != "function") {
    initialCheck(callback);
    let getRemainingElements = (Array.isArray(callback) ? callback : [callback]).map((element) => {
      let parent = element.parentElement;
      if (parent === null) return () => null;
      for (; parent.parentElement; ) parent = parent.parentElement;
      return () => parent.contains(element) ? element : null;
    });
    callback = () => getRemainingElements.map((c3) => c3()).filter(Boolean);
  }
  return initialCheck(callback()), waitForWrapper(() => {
    let result2;
    try {
      result2 = callback();
    } catch (error) {
      if (error.name === "TestingLibraryElementError") return;
      throw error;
    }
    if (!isRemoved(result2)) throw timeoutError;
  }, options2);
}
var eventMap = { copy: { EventType: "ClipboardEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, cut: { EventType: "ClipboardEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, paste: { EventType: "ClipboardEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, compositionEnd: { EventType: "CompositionEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, compositionStart: { EventType: "CompositionEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, compositionUpdate: { EventType: "CompositionEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, keyDown: { EventType: "KeyboardEvent", defaultInit: { bubbles: true, cancelable: true, charCode: 0, composed: true } }, keyPress: { EventType: "KeyboardEvent", defaultInit: { bubbles: true, cancelable: true, charCode: 0, composed: true } }, keyUp: { EventType: "KeyboardEvent", defaultInit: { bubbles: true, cancelable: true, charCode: 0, composed: true } }, focus: { EventType: "FocusEvent", defaultInit: { bubbles: false, cancelable: false, composed: true } }, blur: { EventType: "FocusEvent", defaultInit: { bubbles: false, cancelable: false, composed: true } }, focusIn: { EventType: "FocusEvent", defaultInit: { bubbles: true, cancelable: false, composed: true } }, focusOut: { EventType: "FocusEvent", defaultInit: { bubbles: true, cancelable: false, composed: true } }, change: { EventType: "Event", defaultInit: { bubbles: true, cancelable: false } }, input: { EventType: "InputEvent", defaultInit: { bubbles: true, cancelable: false, composed: true } }, invalid: { EventType: "Event", defaultInit: { bubbles: false, cancelable: true } }, submit: { EventType: "Event", defaultInit: { bubbles: true, cancelable: true } }, reset: { EventType: "Event", defaultInit: { bubbles: true, cancelable: true } }, click: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, button: 0, composed: true } }, contextMenu: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, dblClick: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, drag: { EventType: "DragEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, dragEnd: { EventType: "DragEvent", defaultInit: { bubbles: true, cancelable: false, composed: true } }, dragEnter: { EventType: "DragEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, dragExit: { EventType: "DragEvent", defaultInit: { bubbles: true, cancelable: false, composed: true } }, dragLeave: { EventType: "DragEvent", defaultInit: { bubbles: true, cancelable: false, composed: true } }, dragOver: { EventType: "DragEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, dragStart: { EventType: "DragEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, drop: { EventType: "DragEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, mouseDown: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, mouseEnter: { EventType: "MouseEvent", defaultInit: { bubbles: false, cancelable: false, composed: true } }, mouseLeave: { EventType: "MouseEvent", defaultInit: { bubbles: false, cancelable: false, composed: true } }, mouseMove: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, mouseOut: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, mouseOver: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, mouseUp: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, select: { EventType: "Event", defaultInit: { bubbles: true, cancelable: false } }, touchCancel: { EventType: "TouchEvent", defaultInit: { bubbles: true, cancelable: false, composed: true } }, touchEnd: { EventType: "TouchEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, touchMove: { EventType: "TouchEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, touchStart: { EventType: "TouchEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, resize: { EventType: "UIEvent", defaultInit: { bubbles: false, cancelable: false } }, scroll: { EventType: "UIEvent", defaultInit: { bubbles: false, cancelable: false } }, wheel: { EventType: "WheelEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, abort: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, canPlay: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, canPlayThrough: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, durationChange: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, emptied: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, encrypted: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, ended: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, loadedData: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, loadedMetadata: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, loadStart: { EventType: "ProgressEvent", defaultInit: { bubbles: false, cancelable: false } }, pause: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, play: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, playing: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, progress: { EventType: "ProgressEvent", defaultInit: { bubbles: false, cancelable: false } }, rateChange: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, seeked: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, seeking: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, stalled: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, suspend: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, timeUpdate: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, volumeChange: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, waiting: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, load: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, error: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, animationStart: { EventType: "AnimationEvent", defaultInit: { bubbles: true, cancelable: false } }, animationEnd: { EventType: "AnimationEvent", defaultInit: { bubbles: true, cancelable: false } }, animationIteration: { EventType: "AnimationEvent", defaultInit: { bubbles: true, cancelable: false } }, transitionCancel: { EventType: "TransitionEvent", defaultInit: { bubbles: true, cancelable: false } }, transitionEnd: { EventType: "TransitionEvent", defaultInit: { bubbles: true, cancelable: true } }, transitionRun: { EventType: "TransitionEvent", defaultInit: { bubbles: true, cancelable: false } }, transitionStart: { EventType: "TransitionEvent", defaultInit: { bubbles: true, cancelable: false } }, pointerOver: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, pointerEnter: { EventType: "PointerEvent", defaultInit: { bubbles: false, cancelable: false } }, pointerDown: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, pointerMove: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, pointerUp: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, pointerCancel: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: false, composed: true } }, pointerOut: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, pointerLeave: { EventType: "PointerEvent", defaultInit: { bubbles: false, cancelable: false } }, gotPointerCapture: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: false, composed: true } }, lostPointerCapture: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: false, composed: true } }, popState: { EventType: "PopStateEvent", defaultInit: { bubbles: true, cancelable: false } }, offline: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, online: { EventType: "Event", defaultInit: { bubbles: false, cancelable: false } }, pageHide: { EventType: "PageTransitionEvent", defaultInit: { bubbles: true, cancelable: true } }, pageShow: { EventType: "PageTransitionEvent", defaultInit: { bubbles: true, cancelable: true } } };
var eventAliasMap = { doubleClick: "dblClick" };
function fireEvent(element, event) {
  return getConfig22().eventWrapper(() => {
    if (!event) throw new Error("Unable to fire an event - please provide an event object.");
    if (!element) throw new Error('Unable to fire a "' + event.type + '" event - please provide a DOM element.');
    return element.dispatchEvent(event);
  });
}
function createEvent(eventName, node, init, _temp) {
  let { EventType = "Event", defaultInit = {} } = _temp === void 0 ? {} : _temp;
  if (!node) throw new Error('Unable to fire a "' + eventName + '" event - please provide a DOM element.');
  let eventInit = { ...defaultInit, ...init }, { target: { value: value2, files, ...targetProperties } = {} } = eventInit;
  value2 !== void 0 && setNativeValue(node, value2), files !== void 0 && Object.defineProperty(node, "files", { configurable: true, enumerable: true, writable: true, value: files }), Object.assign(node, targetProperties);
  let window2 = getWindowFromNode(node), EventConstructor = window2[EventType] || window2.Event, event;
  if (typeof EventConstructor == "function") event = new EventConstructor(eventName, eventInit);
  else {
    event = window2.document.createEvent(EventType);
    let { bubbles, cancelable, detail, ...otherInit } = eventInit;
    event.initEvent(eventName, bubbles, cancelable, detail), Object.keys(otherInit).forEach((eventKey) => {
      event[eventKey] = otherInit[eventKey];
    });
  }
  return ["dataTransfer", "clipboardData"].forEach((dataTransferKey) => {
    let dataTransferValue = eventInit[dataTransferKey];
    typeof dataTransferValue == "object" && (typeof window2.DataTransfer == "function" ? Object.defineProperty(event, dataTransferKey, { value: Object.getOwnPropertyNames(dataTransferValue).reduce((acc, propName) => (Object.defineProperty(acc, propName, { value: dataTransferValue[propName] }), acc), new window2.DataTransfer()) }) : Object.defineProperty(event, dataTransferKey, { value: dataTransferValue }));
  }), event;
}
Object.keys(eventMap).forEach((key2) => {
  let { EventType, defaultInit } = eventMap[key2], eventName = key2.toLowerCase();
  createEvent[key2] = (node, init) => createEvent(eventName, node, init, { EventType, defaultInit }), fireEvent[key2] = (node, init) => fireEvent(node, createEvent[key2](node, init));
});
function setNativeValue(element, value2) {
  let { set: valueSetter } = Object.getOwnPropertyDescriptor(element, "value") || {}, prototype = Object.getPrototypeOf(element), { set: prototypeValueSetter } = Object.getOwnPropertyDescriptor(prototype, "value") || {};
  if (prototypeValueSetter && valueSetter !== prototypeValueSetter) prototypeValueSetter.call(element, value2);
  else if (valueSetter) valueSetter.call(element, value2);
  else throw new Error("The given element does not have a value setter");
}
Object.keys(eventAliasMap).forEach((aliasKey) => {
  let key2 = eventAliasMap[aliasKey];
  fireEvent[aliasKey] = function() {
    return fireEvent[key2](...arguments);
  };
});
function unindent(string) {
  return string.replace(/[ \t]*[\n][ \t]*/g, `
`);
}
function encode(value2) {
  return import_lz_string.default.compressToEncodedURIComponent(unindent(value2));
}
function getPlaygroundUrl(markup) {
  return "https://testing-playground.com/#markup=" + encode(markup);
}
var debug = (element, maxLength, options2) => Array.isArray(element) ? element.forEach((el) => logDOM(el, maxLength, options2)) : logDOM(element, maxLength, options2);
var logTestingPlaygroundURL = function(element) {
  if (element === void 0 && (element = getDocument().body), !element || !("innerHTML" in element)) {
    console.log("The element you're providing isn't a valid DOM element.");
    return;
  }
  if (!element.innerHTML) {
    console.log("The provided element doesn't have any children.");
    return;
  }
  let playgroundUrl = getPlaygroundUrl(element.innerHTML);
  return console.log(`Open this URL in your browser

` + playgroundUrl), playgroundUrl;
};
var initialValue = { debug, logTestingPlaygroundURL };
var screen = typeof document < "u" && document.body ? getQueriesForElement(document.body, queries, initialValue) : Object.keys(queries).reduce((helpers, key2) => (helpers[key2] = () => {
  throw new TypeError("For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error");
}, helpers), initialValue);
function isElementType(element, tag, props) {
  return element.namespaceURI && element.namespaceURI !== "http://www.w3.org/1999/xhtml" || (tag = Array.isArray(tag) ? tag : [tag], !tag.includes(element.tagName.toLowerCase())) ? false : props ? Object.entries(props).every(([k22, v6]) => element[k22] === v6) : true;
}
var clickableInputTypes;
(function(clickableInputTypes2) {
  clickableInputTypes2.button = "button", clickableInputTypes2.color = "color", clickableInputTypes2.file = "file", clickableInputTypes2.image = "image", clickableInputTypes2.reset = "reset", clickableInputTypes2.submit = "submit", clickableInputTypes2.checkbox = "checkbox", clickableInputTypes2.radio = "radio";
})(clickableInputTypes || (clickableInputTypes = {}));
function isClickableInput(element) {
  return isElementType(element, "button") || isElementType(element, "input") && element.type in clickableInputTypes;
}
function getWindow(node) {
  var _node_ownerDocument;
  if (isDocument(node) && node.defaultView) return node.defaultView;
  if (!((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0) && _node_ownerDocument.defaultView) return node.ownerDocument.defaultView;
  throw new Error(`Could not determine window of node. Node was ${describe(node)}`);
}
function isDocument(node) {
  return node.nodeType === 9;
}
function describe(val) {
  return typeof val == "function" ? `function ${val.name}` : val === null ? "null" : String(val);
}
function readBlobText(blob, FileReader) {
  return new Promise((res, rej) => {
    let fr3 = new FileReader();
    fr3.onerror = rej, fr3.onabort = rej, fr3.onload = () => {
      res(String(fr3.result));
    }, fr3.readAsText(blob);
  });
}
function createFileList(window2, files) {
  let list = { ...files, length: files.length, item: (index) => list[index], [Symbol.iterator]: function* () {
    for (let i4 = 0; i4 < list.length; i4++) yield list[i4];
  } };
  return list.constructor = window2.FileList, window2.FileList && Object.setPrototypeOf(list, window2.FileList.prototype), Object.freeze(list), list;
}
function _define_property(obj, key2, value2) {
  return key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
var DataTransferItemStub = class {
  getAsFile() {
    return this.file;
  }
  getAsString(callback) {
    typeof this.data == "string" && callback(this.data);
  }
  webkitGetAsEntry() {
    throw new Error("not implemented");
  }
  constructor(dataOrFile, type5) {
    _define_property(this, "kind", void 0), _define_property(this, "type", void 0), _define_property(this, "file", null), _define_property(this, "data", void 0), typeof dataOrFile == "string" ? (this.kind = "string", this.type = String(type5), this.data = dataOrFile) : (this.kind = "file", this.type = dataOrFile.type, this.file = dataOrFile);
  }
};
var DataTransferItemListStub = class extends Array {
  add(...args2) {
    let item = new DataTransferItemStub(args2[0], args2[1]);
    return this.push(item), item;
  }
  clear() {
    this.splice(0, this.length);
  }
  remove(index) {
    this.splice(index, 1);
  }
};
function getTypeMatcher(type5, exact) {
  let [group, sub] = type5.split("/"), isGroup = !sub || sub === "*";
  return (item) => exact ? item.type === (isGroup ? group : type5) : isGroup ? item.type.startsWith(`${group}/`) : item.type === group;
}
function createDataTransferStub(window2) {
  return new class {
    getData(format4) {
      var _this_items_find;
      let match = (_this_items_find = this.items.find(getTypeMatcher(format4, true))) !== null && _this_items_find !== void 0 ? _this_items_find : this.items.find(getTypeMatcher(format4, false)), text = "";
      return match == null ? void 0 : match.getAsString((t4) => {
        text = t4;
      }), text;
    }
    setData(format4, data) {
      let matchIndex = this.items.findIndex(getTypeMatcher(format4, true)), item = new DataTransferItemStub(data, format4);
      matchIndex >= 0 ? this.items.splice(matchIndex, 1, item) : this.items.push(item);
    }
    clearData(format4) {
      if (format4) {
        let matchIndex = this.items.findIndex(getTypeMatcher(format4, true));
        matchIndex >= 0 && this.items.remove(matchIndex);
      } else this.items.clear();
    }
    get types() {
      let t4 = [];
      return this.files.length && t4.push("Files"), this.items.forEach((i4) => t4.push(i4.type)), Object.freeze(t4), t4;
    }
    setDragImage() {
    }
    constructor() {
      _define_property(this, "dropEffect", "none"), _define_property(this, "effectAllowed", "uninitialized"), _define_property(this, "items", new DataTransferItemListStub()), _define_property(this, "files", createFileList(window2, []));
    }
  }();
}
function createDataTransfer(window2, files = []) {
  let dt2 = typeof window2.DataTransfer > "u" ? createDataTransferStub(window2) : new window2.DataTransfer();
  return Object.defineProperty(dt2, "files", { get: () => createFileList(window2, files) }), dt2;
}
function getBlobFromDataTransferItem(window2, item) {
  if (item.kind === "file") return item.getAsFile();
  let data = "";
  return item.getAsString((s4) => {
    data = s4;
  }), new window2.Blob([data], { type: item.type });
}
function _define_property2(obj, key2, value2) {
  return key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
function createClipboardItem(window2, ...blobs) {
  let dataMap = Object.fromEntries(blobs.map((b6) => [typeof b6 == "string" ? "text/plain" : b6.type, Promise.resolve(b6)]));
  return typeof window2.ClipboardItem < "u" ? new window2.ClipboardItem(dataMap) : new class {
    get types() {
      return Array.from(Object.keys(this.data));
    }
    async getType(type5) {
      let value2 = await this.data[type5];
      if (!value2) throw new Error(`${type5} is not one of the available MIME types on this item.`);
      return value2 instanceof window2.Blob ? value2 : new window2.Blob([value2], { type: type5 });
    }
    constructor(d22) {
      _define_property2(this, "data", void 0), this.data = d22;
    }
  }(dataMap);
}
var ClipboardStubControl = Symbol("Manage ClipboardSub");
function createClipboardStub(window2, control) {
  return Object.assign(new class extends window2.EventTarget {
    async read() {
      return Array.from(this.items);
    }
    async readText() {
      let text = "";
      for (let item of this.items) {
        let type5 = item.types.includes("text/plain") ? "text/plain" : item.types.find((t4) => t4.startsWith("text/"));
        type5 && (text += await item.getType(type5).then((b6) => readBlobText(b6, window2.FileReader)));
      }
      return text;
    }
    async write(data) {
      this.items = data;
    }
    async writeText(text) {
      this.items = [createClipboardItem(window2, text)];
    }
    constructor(...args2) {
      super(...args2), _define_property2(this, "items", []);
    }
  }(), { [ClipboardStubControl]: control });
}
function isClipboardStub(clipboard) {
  return !!(clipboard == null ? void 0 : clipboard[ClipboardStubControl]);
}
function attachClipboardStubToView(window2) {
  if (isClipboardStub(window2.navigator.clipboard)) return window2.navigator.clipboard[ClipboardStubControl];
  let realClipboard = Object.getOwnPropertyDescriptor(window2.navigator, "clipboard"), stub, control = { resetClipboardStub: () => {
    stub = createClipboardStub(window2, control);
  }, detachClipboardStub: () => {
    realClipboard ? Object.defineProperty(window2.navigator, "clipboard", realClipboard) : Object.defineProperty(window2.navigator, "clipboard", { value: void 0, configurable: true });
  } };
  return stub = createClipboardStub(window2, control), Object.defineProperty(window2.navigator, "clipboard", { get: () => stub, configurable: true }), stub[ClipboardStubControl];
}
function resetClipboardStubOnView(window2) {
  isClipboardStub(window2.navigator.clipboard) && window2.navigator.clipboard[ClipboardStubControl].resetClipboardStub();
}
function detachClipboardStubFromView(window2) {
  isClipboardStub(window2.navigator.clipboard) && window2.navigator.clipboard[ClipboardStubControl].detachClipboardStub();
}
async function readDataTransferFromClipboard(document2) {
  let window2 = document2.defaultView, clipboard = window2 == null ? void 0 : window2.navigator.clipboard, items = clipboard && await clipboard.read();
  if (!items) throw new Error("The Clipboard API is unavailable.");
  let dt2 = createDataTransfer(window2);
  for (let item of items) for (let type5 of item.types) dt2.setData(type5, await item.getType(type5).then((b6) => readBlobText(b6, window2.FileReader)));
  return dt2;
}
async function writeDataTransferToClipboard(document2, clipboardData) {
  let window2 = getWindow(document2), clipboard = window2.navigator.clipboard, items = [];
  for (let i4 = 0; i4 < clipboardData.items.length; i4++) {
    let dtItem = clipboardData.items[i4], blob = getBlobFromDataTransferItem(window2, dtItem);
    items.push(createClipboardItem(window2, blob));
  }
  if (!(clipboard && await clipboard.write(items).then(() => true, () => false))) throw new Error("The Clipboard API is unavailable.");
}
var g22 = globalThis;
typeof g22.afterEach == "function" && g22.afterEach(() => resetClipboardStubOnView(globalThis.window));
typeof g22.afterAll == "function" && g22.afterAll(() => detachClipboardStubFromView(globalThis.window));
function isContentEditable(element) {
  return element.hasAttribute("contenteditable") && (element.getAttribute("contenteditable") == "true" || element.getAttribute("contenteditable") == "");
}
function getContentEditable(node) {
  let element = getElement(node);
  return element && (element.closest('[contenteditable=""]') || element.closest('[contenteditable="true"]'));
}
function getElement(node) {
  return node.nodeType === 1 ? node : node.parentElement;
}
function isEditable(element) {
  return isEditableInputOrTextArea(element) && !element.readOnly || isContentEditable(element);
}
var editableInputTypes;
(function(editableInputTypes2) {
  editableInputTypes2.text = "text", editableInputTypes2.date = "date", editableInputTypes2["datetime-local"] = "datetime-local", editableInputTypes2.email = "email", editableInputTypes2.month = "month", editableInputTypes2.number = "number", editableInputTypes2.password = "password", editableInputTypes2.search = "search", editableInputTypes2.tel = "tel", editableInputTypes2.time = "time", editableInputTypes2.url = "url", editableInputTypes2.week = "week";
})(editableInputTypes || (editableInputTypes = {}));
function isEditableInputOrTextArea(element) {
  return isElementType(element, "textarea") || isElementType(element, "input") && element.type in editableInputTypes;
}
var maxLengthSupportedTypes;
(function(maxLengthSupportedTypes2) {
  maxLengthSupportedTypes2.email = "email", maxLengthSupportedTypes2.password = "password", maxLengthSupportedTypes2.search = "search", maxLengthSupportedTypes2.telephone = "telephone", maxLengthSupportedTypes2.text = "text", maxLengthSupportedTypes2.url = "url";
})(maxLengthSupportedTypes || (maxLengthSupportedTypes = {}));
function getMaxLength(element) {
  var _element_getAttribute;
  let attr = (_element_getAttribute = element.getAttribute("maxlength")) !== null && _element_getAttribute !== void 0 ? _element_getAttribute : "";
  return /^\d+$/.test(attr) && Number(attr) >= 0 ? Number(attr) : void 0;
}
function supportsMaxLength(element) {
  return isElementType(element, "textarea") || isElementType(element, "input") && element.type in maxLengthSupportedTypes;
}
var FOCUSABLE_SELECTOR = ["input:not([type=hidden]):not([disabled])", "button:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", '[contenteditable=""]', '[contenteditable="true"]', "a[href]", "[tabindex]:not([disabled])"].join(", ");
function isFocusable(element) {
  return element.matches(FOCUSABLE_SELECTOR);
}
var bracketDict;
(function(bracketDict2) {
  bracketDict2["{"] = "}", bracketDict2["["] = "]";
})(bracketDict || (bracketDict = {}));
function readNextDescriptor(text, context) {
  let pos = 0, startBracket = text[pos] in bracketDict ? text[pos] : "";
  pos += startBracket.length;
  let type5 = new RegExp(`^\\${startBracket}{2}`).test(text) ? "" : startBracket;
  return { type: type5, ...type5 === "" ? readPrintableChar(text, pos, context) : readTag(text, pos, type5, context) };
}
function readPrintableChar(text, pos, context) {
  let descriptor = text[pos];
  return assertDescriptor(descriptor, text, pos, context), pos += descriptor.length, { consumedLength: pos, descriptor, releasePrevious: false, releaseSelf: true, repeat: 1 };
}
function readTag(text, pos, startBracket, context) {
  var _text_slice_match, _text_slice_match1;
  let releasePreviousModifier = text[pos] === "/" ? "/" : "";
  pos += releasePreviousModifier.length;
  let escapedDescriptor = startBracket === "{" && text[pos] === "\\";
  pos += Number(escapedDescriptor);
  let descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === "{" ? /^\w+|^[^}>/]/ : /^\w+/)) === null || _text_slice_match === void 0 ? void 0 : _text_slice_match[0];
  assertDescriptor(descriptor, text, pos, context), pos += descriptor.length;
  var _text_slice_match_;
  let repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\d+/)) === null || _text_slice_match1 === void 0 ? void 0 : _text_slice_match1[0]) !== null && _text_slice_match_ !== void 0 ? _text_slice_match_ : "";
  pos += repeatModifier.length;
  let releaseSelfModifier = text[pos] === "/" || !repeatModifier && text[pos] === ">" ? text[pos] : "";
  pos += releaseSelfModifier.length;
  let expectedEndBracket = bracketDict[startBracket], endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : "";
  if (!endBracket) throw new Error(getErrorMessage([!repeatModifier && "repeat modifier", !releaseSelfModifier && "release modifier", `"${expectedEndBracket}"`].filter(Boolean).join(" or "), text[pos], text, context));
  return pos += endBracket.length, { consumedLength: pos, descriptor, releasePrevious: !!releasePreviousModifier, repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1, releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier) };
}
function assertDescriptor(descriptor, text, pos, context) {
  if (!descriptor) throw new Error(getErrorMessage("key descriptor", text[pos], text, context));
}
function hasReleaseSelf(releaseSelfModifier, repeatModifier) {
  if (releaseSelfModifier) return releaseSelfModifier === "/";
  if (repeatModifier) return false;
}
function getErrorMessage(expected, found, text, context) {
  return `Expected ${expected} but found "${found ?? ""}" in "${text}"
    See ${context === "pointer" ? "https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen" : "https://testing-library.com/docs/user-event/keyboard"}
    for more information about how userEvent parses your input.`;
}
function cloneEvent(event) {
  return new event.constructor(event.type, event);
}
var ApiLevel;
(function(ApiLevel2) {
  ApiLevel2[ApiLevel2.Trigger = 2] = "Trigger", ApiLevel2[ApiLevel2.Call = 1] = "Call";
})(ApiLevel || (ApiLevel = {}));
function setLevelRef(instance, level) {
  instance.levelRefs[level] = {};
}
function getLevelRef(instance, level) {
  return instance.levelRefs[level];
}
var PointerEventsCheckLevel;
(function(PointerEventsCheckLevel2) {
  PointerEventsCheckLevel2[PointerEventsCheckLevel2.EachTrigger = 4] = "EachTrigger", PointerEventsCheckLevel2[PointerEventsCheckLevel2.EachApiCall = 2] = "EachApiCall", PointerEventsCheckLevel2[PointerEventsCheckLevel2.EachTarget = 1] = "EachTarget", PointerEventsCheckLevel2[PointerEventsCheckLevel2.Never = 0] = "Never";
})(PointerEventsCheckLevel || (PointerEventsCheckLevel = {}));
function isDisabled2(element) {
  for (let el = element; el; el = el.parentElement) if (isElementType(el, ["button", "input", "select", "textarea", "optgroup", "option"])) {
    if (el.hasAttribute("disabled")) return true;
  } else if (isElementType(el, "fieldset")) {
    var _el_querySelector;
    if (el.hasAttribute("disabled") && !(!((_el_querySelector = el.querySelector(":scope > legend")) === null || _el_querySelector === void 0) && _el_querySelector.contains(element))) return true;
  } else if (el.tagName.includes("-") && el.constructor.formAssociated && el.hasAttribute("disabled")) return true;
  return false;
}
function getActiveElement(document2) {
  let activeElement = document2.activeElement;
  return (activeElement == null ? void 0 : activeElement.shadowRoot) ? getActiveElement(activeElement.shadowRoot) : isDisabled2(activeElement) ? document2.ownerDocument ? document2.ownerDocument.body : document2.body : activeElement;
}
function getActiveElementOrBody(document2) {
  var _getActiveElement;
  return (_getActiveElement = getActiveElement(document2)) !== null && _getActiveElement !== void 0 ? _getActiveElement : document2.body;
}
function findClosest(element, callback) {
  let el = element;
  do {
    if (callback(el)) return el;
    el = el.parentElement;
  } while (el && el !== element.ownerDocument.body);
}
function hasOwnSelection(node) {
  return isElement3(node) && isEditableInputOrTextArea(node);
}
function hasNoSelection(node) {
  return isElement3(node) && isClickableInput(node);
}
function isElement3(node) {
  return node.nodeType === 1;
}
function updateSelectionOnFocus(element) {
  let selection = element.ownerDocument.getSelection();
  if ((selection == null ? void 0 : selection.focusNode) && hasOwnSelection(element)) {
    let contenteditable = getContentEditable(selection.focusNode);
    if (contenteditable) {
      if (!selection.isCollapsed) {
        var _contenteditable_firstChild;
        let focusNode = ((_contenteditable_firstChild = contenteditable.firstChild) === null || _contenteditable_firstChild === void 0 ? void 0 : _contenteditable_firstChild.nodeType) === 3 ? contenteditable.firstChild : contenteditable;
        selection.setBaseAndExtent(focusNode, 0, focusNode, 0);
      }
    } else selection.setBaseAndExtent(element, 0, element, 0);
  }
}
function wrapEvent(cb, _element) {
  return getConfig22().eventWrapper(cb);
}
function focusElement(element) {
  let target = findClosest(element, isFocusable), activeElement = getActiveElement(element.ownerDocument);
  (target ?? element.ownerDocument.body) !== activeElement && (target ? wrapEvent(() => target.focus()) : wrapEvent(() => activeElement == null ? void 0 : activeElement.blur()), updateSelectionOnFocus(target ?? element.ownerDocument.body));
}
function blurElement(element) {
  !isFocusable(element) || !(getActiveElement(element.ownerDocument) === element) || wrapEvent(() => element.blur());
}
var behavior = {};
behavior.click = (event, target, instance) => {
  let context = target.closest("button,input,label,select,textarea"), control = context && isElementType(context, "label") && context.control;
  if (control) return () => {
    isFocusable(control) && focusElement(control), instance.dispatchEvent(control, cloneEvent(event));
  };
  if (isElementType(target, "input", { type: "file" })) return () => {
    blurElement(target), target.dispatchEvent(new (getWindow(target)).Event("fileDialog")), focusElement(target);
  };
};
var UIValue = Symbol("Displayed value in UI");
var UISelection = Symbol("Displayed selection in UI");
var InitialValue = Symbol("Initial value to compare on blur");
function isUIValue(value2) {
  return typeof value2 == "object" && UIValue in value2;
}
function isUISelectionStart(start) {
  return !!start && typeof start == "object" && UISelection in start;
}
function setUIValue(element, value2) {
  element[InitialValue] === void 0 && (element[InitialValue] = element.value), element[UIValue] = value2, element.value = Object.assign(new String(value2), { [UIValue]: true });
}
function getUIValue(element) {
  return element[UIValue] === void 0 ? element.value : String(element[UIValue]);
}
function setUIValueClean(element) {
  element[UIValue] = void 0;
}
function clearInitialValue(element) {
  element[InitialValue] = void 0;
}
function getInitialValue(element) {
  return element[InitialValue];
}
function setUISelectionRaw(element, selection) {
  element[UISelection] = selection;
}
function setUISelection(element, { focusOffset: focusOffsetParam, anchorOffset: anchorOffsetParam = focusOffsetParam }, mode = "replace") {
  let valueLength = getUIValue(element).length, sanitizeOffset = (o3) => Math.max(0, Math.min(valueLength, o3)), anchorOffset = mode === "replace" || element[UISelection] === void 0 ? sanitizeOffset(anchorOffsetParam) : element[UISelection].anchorOffset, focusOffset = sanitizeOffset(focusOffsetParam), startOffset = Math.min(anchorOffset, focusOffset), endOffset = Math.max(anchorOffset, focusOffset);
  if (element[UISelection] = { anchorOffset, focusOffset }, element.selectionStart === startOffset && element.selectionEnd === endOffset) return;
  let startObj = Object.assign(new Number(startOffset), { [UISelection]: true });
  try {
    element.setSelectionRange(startObj, endOffset);
  } catch {
  }
}
function getUISelection(element) {
  var _element_selectionStart, _element_selectionEnd, _element_UISelection;
  let sel = (_element_UISelection = element[UISelection]) !== null && _element_UISelection !== void 0 ? _element_UISelection : { anchorOffset: (_element_selectionStart = element.selectionStart) !== null && _element_selectionStart !== void 0 ? _element_selectionStart : 0, focusOffset: (_element_selectionEnd = element.selectionEnd) !== null && _element_selectionEnd !== void 0 ? _element_selectionEnd : 0 };
  return { ...sel, startOffset: Math.min(sel.anchorOffset, sel.focusOffset), endOffset: Math.max(sel.anchorOffset, sel.focusOffset) };
}
function hasUISelection(element) {
  return !!element[UISelection];
}
function setUISelectionClean(element) {
  element[UISelection] = void 0;
}
var parseInt2 = globalThis.parseInt;
function buildTimeValue(value2) {
  let onlyDigitsValue = value2.replace(/\D/g, "");
  if (onlyDigitsValue.length < 2) return value2;
  let firstDigit = parseInt2(onlyDigitsValue[0], 10), secondDigit = parseInt2(onlyDigitsValue[1], 10);
  if (firstDigit >= 3 || firstDigit === 2 && secondDigit >= 4) {
    let index;
    return firstDigit >= 3 ? index = 1 : index = 2, build22(onlyDigitsValue, index);
  }
  return value2.length === 2 ? value2 : build22(onlyDigitsValue, 2);
}
function build22(onlyDigitsValue, index) {
  let hours = onlyDigitsValue.slice(0, index), validHours = Math.min(parseInt2(hours, 10), 23), minuteCharacters = onlyDigitsValue.slice(index), parsedMinutes = parseInt2(minuteCharacters, 10), validMinutes = Math.min(parsedMinutes, 59);
  return `${validHours.toString().padStart(2, "0")}:${validMinutes.toString().padStart(2, "0")}`;
}
function isValidDateOrTimeValue(element, value2) {
  let clone22 = element.cloneNode();
  return clone22.value = value2, clone22.value === value2;
}
function getNextCursorPosition(node, offset, direction, inputType) {
  if (isTextNode(node) && offset + direction >= 0 && offset + direction <= node.nodeValue.length) return { node, offset: offset + direction };
  let nextNode = getNextCharacterContentNode(node, offset, direction);
  if (nextNode) {
    if (isTextNode(nextNode)) return { node: nextNode, offset: direction > 0 ? Math.min(1, nextNode.nodeValue.length) : Math.max(nextNode.nodeValue.length - 1, 0) };
    if (isElementType(nextNode, "br")) {
      let nextPlusOne = getNextCharacterContentNode(nextNode, void 0, direction);
      return nextPlusOne ? isTextNode(nextPlusOne) ? { node: nextPlusOne, offset: direction > 0 ? 0 : nextPlusOne.nodeValue.length } : direction < 0 && isElementType(nextPlusOne, "br") ? { node: nextNode.parentNode, offset: getOffset(nextNode) } : { node: nextPlusOne.parentNode, offset: getOffset(nextPlusOne) + (direction > 0 ? 0 : 1) } : direction < 0 && inputType === "deleteContentBackward" ? { node: nextNode.parentNode, offset: getOffset(nextNode) } : void 0;
    } else return { node: nextNode.parentNode, offset: getOffset(nextNode) + (direction > 0 ? 1 : 0) };
  }
}
function getNextCharacterContentNode(node, offset, direction) {
  let nextOffset = Number(offset) + (direction < 0 ? -1 : 0);
  return offset !== void 0 && isElement4(node) && nextOffset >= 0 && nextOffset < node.children.length && (node = node.children[nextOffset]), walkNodes(node, direction === 1 ? "next" : "previous", isTreatedAsCharacterContent);
}
function isTreatedAsCharacterContent(node) {
  if (isTextNode(node)) return true;
  if (isElement4(node)) {
    if (isElementType(node, ["input", "textarea"])) return node.type !== "hidden";
    if (isElementType(node, "br")) return true;
  }
  return false;
}
function getOffset(node) {
  let i4 = 0;
  for (; node.previousSibling; ) i4++, node = node.previousSibling;
  return i4;
}
function isElement4(node) {
  return node.nodeType === 1;
}
function isTextNode(node) {
  return node.nodeType === 3;
}
function walkNodes(node, direction, callback) {
  for (; ; ) {
    var _node_ownerDocument;
    let sibling = node[`${direction}Sibling`];
    if (sibling) {
      if (node = getDescendant(sibling, direction === "next" ? "first" : "last"), callback(node)) return node;
    } else if (node.parentNode && (!isElement4(node.parentNode) || !isContentEditable(node.parentNode) && node.parentNode !== ((_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.body))) node = node.parentNode;
    else break;
  }
}
function getDescendant(node, direction) {
  for (; node.hasChildNodes(); ) node = node[`${direction}Child`];
  return node;
}
var TrackChanges = Symbol("Track programmatic changes for React workaround");
function isReact17Element(element) {
  return Object.getOwnPropertyNames(element).some((k22) => k22.startsWith("__react")) && getWindow(element).REACT_VERSION === 17;
}
function startTrackValue(element) {
  isReact17Element(element) && (element[TrackChanges] = { previousValue: String(element.value), tracked: [] });
}
function trackOrSetValue(element, v6) {
  var _element_TrackChanges_tracked, _element_TrackChanges;
  (_element_TrackChanges = element[TrackChanges]) === null || _element_TrackChanges === void 0 || (_element_TrackChanges_tracked = _element_TrackChanges.tracked) === null || _element_TrackChanges_tracked === void 0 || _element_TrackChanges_tracked.push(v6), element[TrackChanges] || (setUIValueClean(element), setUISelection(element, { focusOffset: v6.length }));
}
function commitValueAfterInput(element, cursorOffset) {
  var _changes_tracked;
  let changes = element[TrackChanges];
  if (element[TrackChanges] = void 0, !(!(changes == null || (_changes_tracked = changes.tracked) === null || _changes_tracked === void 0) && _changes_tracked.length)) return;
  let isJustReactStateUpdate = changes.tracked.length === 2 && changes.tracked[0] === changes.previousValue && changes.tracked[1] === element.value;
  isJustReactStateUpdate || setUIValueClean(element), hasUISelection(element) && setUISelection(element, { focusOffset: isJustReactStateUpdate ? cursorOffset : element.value.length });
}
function getTargetTypeAndSelection(node) {
  let element = getElement2(node);
  if (element && hasOwnSelection(element)) return { type: "input", selection: getUISelection(element) };
  let selection = element == null ? void 0 : element.ownerDocument.getSelection();
  return { type: getContentEditable(node) && (selection == null ? void 0 : selection.anchorNode) && getContentEditable(selection.anchorNode) ? "contenteditable" : "default", selection };
}
function getElement2(node) {
  return node.nodeType === 1 ? node : node.parentElement;
}
function getInputRange(focusNode) {
  let typeAndSelection = getTargetTypeAndSelection(focusNode);
  if (typeAndSelection.type === "input") return typeAndSelection.selection;
  if (typeAndSelection.type === "contenteditable") {
    var _typeAndSelection_selection;
    return (_typeAndSelection_selection = typeAndSelection.selection) === null || _typeAndSelection_selection === void 0 ? void 0 : _typeAndSelection_selection.getRangeAt(0);
  }
}
function setSelection({ focusNode, focusOffset, anchorNode = focusNode, anchorOffset = focusOffset }) {
  var _anchorNode_ownerDocument_getSelection, _anchorNode_ownerDocument;
  if (getTargetTypeAndSelection(focusNode).type === "input") return setUISelection(focusNode, { anchorOffset, focusOffset });
  (_anchorNode_ownerDocument = anchorNode.ownerDocument) === null || _anchorNode_ownerDocument === void 0 || (_anchorNode_ownerDocument_getSelection = _anchorNode_ownerDocument.getSelection()) === null || _anchorNode_ownerDocument_getSelection === void 0 || _anchorNode_ownerDocument_getSelection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
}
function isDateOrTime(element) {
  return isElementType(element, "input") && ["date", "time"].includes(element.type);
}
function input(instance, element, data, inputType = "insertText") {
  let inputRange = getInputRange(element);
  inputRange && (!isDateOrTime(element) && !instance.dispatchUIEvent(element, "beforeinput", { inputType, data }) || ("startContainer" in inputRange ? editContenteditable(instance, element, inputRange, data, inputType) : editInputElement(instance, element, inputRange, data, inputType)));
}
function editContenteditable(instance, element, inputRange, data, inputType) {
  let del = false;
  if (!inputRange.collapsed) del = true, inputRange.deleteContents();
  else if (["deleteContentBackward", "deleteContentForward"].includes(inputType)) {
    let nextPosition = getNextCursorPosition(inputRange.startContainer, inputRange.startOffset, inputType === "deleteContentBackward" ? -1 : 1, inputType);
    if (nextPosition) {
      del = true;
      let delRange = inputRange.cloneRange();
      delRange.comparePoint(nextPosition.node, nextPosition.offset) < 0 ? delRange.setStart(nextPosition.node, nextPosition.offset) : delRange.setEnd(nextPosition.node, nextPosition.offset), delRange.deleteContents();
    }
  }
  if (data) if (inputRange.endContainer.nodeType === 3) {
    let offset = inputRange.endOffset;
    inputRange.endContainer.insertData(offset, data), inputRange.setStart(inputRange.endContainer, offset + data.length), inputRange.setEnd(inputRange.endContainer, offset + data.length);
  } else {
    let text = element.ownerDocument.createTextNode(data);
    inputRange.insertNode(text), inputRange.setStart(text, data.length), inputRange.setEnd(text, data.length);
  }
  (del || data) && instance.dispatchUIEvent(element, "input", { inputType });
}
function editInputElement(instance, element, inputRange, data, inputType) {
  let dataToInsert = data;
  if (supportsMaxLength(element)) {
    let maxLength = getMaxLength(element);
    if (maxLength !== void 0 && data.length > 0) {
      let spaceUntilMaxLength = maxLength - element.value.length;
      if (spaceUntilMaxLength > 0) dataToInsert = data.substring(0, spaceUntilMaxLength);
      else return;
    }
  }
  let { newValue, newOffset, oldValue } = calculateNewValue(dataToInsert, element, inputRange, inputType);
  newValue === oldValue && newOffset === inputRange.startOffset && newOffset === inputRange.endOffset || isElementType(element, "input", { type: "number" }) && !isValidNumberInput(newValue) || (setUIValue(element, newValue), setSelection({ focusNode: element, anchorOffset: newOffset, focusOffset: newOffset }), isDateOrTime(element) ? isValidDateOrTimeValue(element, newValue) && (commitInput(instance, element, newOffset, {}), instance.dispatchUIEvent(element, "change"), clearInitialValue(element)) : commitInput(instance, element, newOffset, { data, inputType }));
}
function calculateNewValue(inputData, node, { startOffset, endOffset }, inputType) {
  let value2 = getUIValue(node), prologEnd = Math.max(0, startOffset === endOffset && inputType === "deleteContentBackward" ? startOffset - 1 : startOffset), prolog = value2.substring(0, prologEnd), epilogStart = Math.min(value2.length, startOffset === endOffset && inputType === "deleteContentForward" ? startOffset + 1 : endOffset), epilog = value2.substring(epilogStart, value2.length), newValue = `${prolog}${inputData}${epilog}`, newOffset = prologEnd + inputData.length;
  if (isElementType(node, "input", { type: "time" })) {
    let builtValue = buildTimeValue(newValue);
    builtValue !== "" && isValidDateOrTimeValue(node, builtValue) && (newValue = builtValue, newOffset = builtValue.length);
  }
  return { oldValue: value2, newValue, newOffset };
}
function commitInput(instance, element, newOffset, inputInit) {
  instance.dispatchUIEvent(element, "input", inputInit), commitValueAfterInput(element, newOffset);
}
function isValidNumberInput(value2) {
  var _value_match, _value_match1;
  let valueParts = value2.split("e", 2);
  return !(/[^\d.\-e]/.test(value2) || Number((_value_match = value2.match(/-/g)) === null || _value_match === void 0 ? void 0 : _value_match.length) > 2 || Number((_value_match1 = value2.match(/\./g)) === null || _value_match1 === void 0 ? void 0 : _value_match1.length) > 1 || valueParts[1] && !/^-?\d*$/.test(valueParts[1]));
}
behavior.cut = (event, target, instance) => () => {
  isEditable(target) && input(instance, target, "", "deleteByCut");
};
function getValueOrTextContent(element) {
  return element ? isContentEditable(element) ? element.textContent : getUIValue(element) : null;
}
function isVisible(element) {
  let window2 = getWindow(element);
  for (let el = element; el == null ? void 0 : el.ownerDocument; el = el.parentElement) {
    let { display: display2, visibility } = window2.getComputedStyle(el);
    if (display2 === "none" || visibility === "hidden") return false;
  }
  return true;
}
function getTabDestination(activeElement, shift) {
  let document2 = activeElement.ownerDocument, focusableElements = document2.querySelectorAll(FOCUSABLE_SELECTOR), enabledElements = Array.from(focusableElements).filter((el) => el === activeElement || !(Number(el.getAttribute("tabindex")) < 0 || isDisabled2(el)));
  Number(activeElement.getAttribute("tabindex")) >= 0 && enabledElements.sort((a22, b6) => {
    let i4 = Number(a22.getAttribute("tabindex")), j2 = Number(b6.getAttribute("tabindex"));
    return i4 === j2 ? 0 : i4 === 0 ? 1 : j2 === 0 ? -1 : i4 - j2;
  });
  let checkedRadio = {}, prunedElements = [document2.body], activeRadioGroup = isElementType(activeElement, "input", { type: "radio" }) ? activeElement.name : void 0;
  enabledElements.forEach((currentElement) => {
    let el = currentElement;
    if (isElementType(el, "input", { type: "radio" }) && el.name) {
      if (el === activeElement) {
        prunedElements.push(el);
        return;
      } else if (el.name === activeRadioGroup) return;
      if (el.checked) {
        prunedElements = prunedElements.filter((e2) => !isElementType(e2, "input", { type: "radio", name: el.name })), prunedElements.push(el), checkedRadio[el.name] = el;
        return;
      }
      if (typeof checkedRadio[el.name] < "u") return;
    }
    prunedElements.push(el);
  });
  for (let index = prunedElements.findIndex((el) => el === activeElement); ; ) if (index += shift ? -1 : 1, index === prunedElements.length ? index = 0 : index === -1 && (index = prunedElements.length - 1), prunedElements[index] === activeElement || prunedElements[index] === document2.body || isVisible(prunedElements[index])) return prunedElements[index];
}
function moveSelection(node, direction) {
  if (hasOwnSelection(node)) {
    let selection = getUISelection(node);
    setSelection({ focusNode: node, focusOffset: selection.startOffset === selection.endOffset ? selection.focusOffset + direction : direction < 0 ? selection.startOffset : selection.endOffset });
  } else {
    let selection = node.ownerDocument.getSelection();
    if (!(selection == null ? void 0 : selection.focusNode)) return;
    if (selection.isCollapsed) {
      let nextPosition = getNextCursorPosition(selection.focusNode, selection.focusOffset, direction);
      nextPosition && setSelection({ focusNode: nextPosition.node, focusOffset: nextPosition.offset });
    } else selection[direction < 0 ? "collapseToStart" : "collapseToEnd"]();
  }
}
function selectAll(target) {
  if (hasOwnSelection(target)) return setSelection({ focusNode: target, anchorOffset: 0, focusOffset: getUIValue(target).length });
  var _getContentEditable;
  let focusNode = (_getContentEditable = getContentEditable(target)) !== null && _getContentEditable !== void 0 ? _getContentEditable : target.ownerDocument.body;
  setSelection({ focusNode, anchorOffset: 0, focusOffset: focusNode.childNodes.length });
}
function isAllSelected(target) {
  if (hasOwnSelection(target)) return getUISelection(target).startOffset === 0 && getUISelection(target).endOffset === getUIValue(target).length;
  var _getContentEditable;
  let focusNode = (_getContentEditable = getContentEditable(target)) !== null && _getContentEditable !== void 0 ? _getContentEditable : target.ownerDocument.body, selection = target.ownerDocument.getSelection();
  return (selection == null ? void 0 : selection.anchorNode) === focusNode && selection.focusNode === focusNode && selection.anchorOffset === 0 && selection.focusOffset === focusNode.childNodes.length;
}
function setSelectionRange(element, anchorOffset, focusOffset) {
  var _element_firstChild;
  if (hasOwnSelection(element)) return setSelection({ focusNode: element, anchorOffset, focusOffset });
  if (isContentEditable(element) && ((_element_firstChild = element.firstChild) === null || _element_firstChild === void 0 ? void 0 : _element_firstChild.nodeType) === 3) return setSelection({ focusNode: element.firstChild, anchorOffset, focusOffset });
  throw new Error("Not implemented. The result of this interaction is unreliable.");
}
function walkRadio(instance, el, direction) {
  let window2 = getWindow(el), group = Array.from(el.ownerDocument.querySelectorAll(el.name ? `input[type="radio"][name="${window2.CSS.escape(el.name)}"]` : 'input[type="radio"][name=""], input[type="radio"]:not([name])'));
  for (let i4 = group.findIndex((e2) => e2 === el) + direction; ; i4 += direction) {
    if (group[i4] || (i4 = direction > 0 ? 0 : group.length - 1), group[i4] === el) return;
    isDisabled2(group[i4]) || (focusElement(group[i4]), instance.dispatchUIEvent(group[i4], "click"));
  }
}
behavior.keydown = (event, target, instance) => {
  var _keydownBehavior_event_key, _keydownBehavior_event_key1;
  return (_keydownBehavior_event_key1 = (_keydownBehavior_event_key = keydownBehavior[event.key]) === null || _keydownBehavior_event_key === void 0 ? void 0 : _keydownBehavior_event_key.call(keydownBehavior, event, target, instance)) !== null && _keydownBehavior_event_key1 !== void 0 ? _keydownBehavior_event_key1 : combinationBehavior(event, target, instance);
};
var keydownBehavior = { ArrowDown: (event, target, instance) => {
  if (isElementType(target, "input", { type: "radio" })) return () => walkRadio(instance, target, -1);
}, ArrowLeft: (event, target, instance) => isElementType(target, "input", { type: "radio" }) ? () => walkRadio(instance, target, -1) : () => moveSelection(target, -1), ArrowRight: (event, target, instance) => isElementType(target, "input", { type: "radio" }) ? () => walkRadio(instance, target, 1) : () => moveSelection(target, 1), ArrowUp: (event, target, instance) => {
  if (isElementType(target, "input", { type: "radio" })) return () => walkRadio(instance, target, 1);
}, Backspace: (event, target, instance) => {
  if (isEditable(target)) return () => {
    input(instance, target, "", "deleteContentBackward");
  };
}, Delete: (event, target, instance) => {
  if (isEditable(target)) return () => {
    input(instance, target, "", "deleteContentForward");
  };
}, End: (event, target) => {
  if (isElementType(target, ["input", "textarea"]) || isContentEditable(target)) return () => {
    var _getValueOrTextContent, _getValueOrTextContent_length;
    let newPos = (_getValueOrTextContent_length = (_getValueOrTextContent = getValueOrTextContent(target)) === null || _getValueOrTextContent === void 0 ? void 0 : _getValueOrTextContent.length) !== null && _getValueOrTextContent_length !== void 0 ? _getValueOrTextContent_length : 0;
    setSelectionRange(target, newPos, newPos);
  };
}, Home: (event, target) => {
  if (isElementType(target, ["input", "textarea"]) || isContentEditable(target)) return () => {
    setSelectionRange(target, 0, 0);
  };
}, PageDown: (event, target) => {
  if (isElementType(target, ["input"])) return () => {
    let newPos = getUIValue(target).length;
    setSelectionRange(target, newPos, newPos);
  };
}, PageUp: (event, target) => {
  if (isElementType(target, ["input"])) return () => {
    setSelectionRange(target, 0, 0);
  };
}, Tab: (event, target, instance) => () => {
  let dest = getTabDestination(target, instance.system.keyboard.modifiers.Shift);
  focusElement(dest), hasOwnSelection(dest) && setUISelection(dest, { anchorOffset: 0, focusOffset: dest.value.length });
} };
var combinationBehavior = (event, target, instance) => {
  if (event.code === "KeyA" && instance.system.keyboard.modifiers.Control) return () => selectAll(target);
};
behavior.keypress = (event, target, instance) => {
  if (event.key === "Enter") {
    if (isElementType(target, "button") || isElementType(target, "input") && ClickInputOnEnter.includes(target.type) || isElementType(target, "a") && target.href) return () => {
      instance.dispatchUIEvent(target, "click");
    };
    if (isElementType(target, "input")) {
      let form = target.form, submit = form == null ? void 0 : form.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
      return submit ? () => instance.dispatchUIEvent(submit, "click") : form && SubmitSingleInputOnEnter.includes(target.type) && form.querySelectorAll("input").length === 1 ? () => instance.dispatchUIEvent(form, "submit") : void 0;
    }
  }
  if (isEditable(target)) {
    let inputType = event.key === "Enter" ? isContentEditable(target) && !instance.system.keyboard.modifiers.Shift ? "insertParagraph" : "insertLineBreak" : "insertText", inputData = event.key === "Enter" ? `
` : event.key;
    return () => input(instance, target, inputData, inputType);
  }
};
var ClickInputOnEnter = ["button", "color", "file", "image", "reset", "submit"];
var SubmitSingleInputOnEnter = ["email", "month", "password", "search", "tel", "text", "url", "week"];
behavior.keyup = (event, target, instance) => {
  var _keyupBehavior_event_key;
  return (_keyupBehavior_event_key = keyupBehavior[event.key]) === null || _keyupBehavior_event_key === void 0 ? void 0 : _keyupBehavior_event_key.call(keyupBehavior, event, target, instance);
};
var keyupBehavior = { " ": (event, target, instance) => {
  if (isClickableInput(target)) return () => instance.dispatchUIEvent(target, "click");
} };
behavior.paste = (event, target, instance) => {
  if (isEditable(target)) return () => {
    var _event_clipboardData;
    let insertData = (_event_clipboardData = event.clipboardData) === null || _event_clipboardData === void 0 ? void 0 : _event_clipboardData.getData("text");
    insertData && input(instance, target, insertData, "insertFromPaste");
  };
};
var eventMap2 = { auxclick: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, beforeinput: { EventType: "InputEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, click: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, contextmenu: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, copy: { EventType: "ClipboardEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, change: { EventType: "Event", defaultInit: { bubbles: true, cancelable: false } }, cut: { EventType: "ClipboardEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, dblclick: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, keydown: { EventType: "KeyboardEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, keypress: { EventType: "KeyboardEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, keyup: { EventType: "KeyboardEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, paste: { EventType: "ClipboardEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, input: { EventType: "InputEvent", defaultInit: { bubbles: true, cancelable: false, composed: true } }, mousedown: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, mouseenter: { EventType: "MouseEvent", defaultInit: { bubbles: false, cancelable: false, composed: true } }, mouseleave: { EventType: "MouseEvent", defaultInit: { bubbles: false, cancelable: false, composed: true } }, mousemove: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, mouseout: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, mouseover: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, mouseup: { EventType: "MouseEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, pointerover: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, pointerenter: { EventType: "PointerEvent", defaultInit: { bubbles: false, cancelable: false } }, pointerdown: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, pointermove: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, pointerup: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, pointercancel: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: false, composed: true } }, pointerout: { EventType: "PointerEvent", defaultInit: { bubbles: true, cancelable: true, composed: true } }, pointerleave: { EventType: "PointerEvent", defaultInit: { bubbles: false, cancelable: false } }, submit: { EventType: "Event", defaultInit: { bubbles: true, cancelable: true } } };
function getEventClass(type5) {
  return eventMap2[type5].EventType;
}
var mouseEvents = ["MouseEvent", "PointerEvent"];
function isMouseEvent(type5) {
  return mouseEvents.includes(getEventClass(type5));
}
function isKeyboardEvent(type5) {
  return getEventClass(type5) === "KeyboardEvent";
}
var eventInitializer = { ClipboardEvent: [initClipboardEvent], Event: [], InputEvent: [initUIEvent, initInputEvent], MouseEvent: [initUIEvent, initUIEventModififiers, initMouseEvent], PointerEvent: [initUIEvent, initUIEventModififiers, initMouseEvent, initPointerEvent], KeyboardEvent: [initUIEvent, initUIEventModififiers, initKeyboardEvent] };
function createEvent2(type5, target, init) {
  let window2 = getWindow(target), { EventType, defaultInit } = eventMap2[type5], event = new (getEventConstructors(window2))[EventType](type5, defaultInit);
  return eventInitializer[EventType].forEach((f42) => f42(event, init ?? {})), event;
}
function getEventConstructors(window2) {
  var _window_Event;
  let Event2 = (_window_Event = window2.Event) !== null && _window_Event !== void 0 ? _window_Event : class {
  };
  var _window_AnimationEvent;
  let AnimationEvent = (_window_AnimationEvent = window2.AnimationEvent) !== null && _window_AnimationEvent !== void 0 ? _window_AnimationEvent : class extends Event2 {
  };
  var _window_ClipboardEvent;
  let ClipboardEvent = (_window_ClipboardEvent = window2.ClipboardEvent) !== null && _window_ClipboardEvent !== void 0 ? _window_ClipboardEvent : class extends Event2 {
  };
  var _window_PopStateEvent;
  let PopStateEvent = (_window_PopStateEvent = window2.PopStateEvent) !== null && _window_PopStateEvent !== void 0 ? _window_PopStateEvent : class extends Event2 {
  };
  var _window_ProgressEvent;
  let ProgressEvent = (_window_ProgressEvent = window2.ProgressEvent) !== null && _window_ProgressEvent !== void 0 ? _window_ProgressEvent : class extends Event2 {
  };
  var _window_TransitionEvent;
  let TransitionEvent = (_window_TransitionEvent = window2.TransitionEvent) !== null && _window_TransitionEvent !== void 0 ? _window_TransitionEvent : class extends Event2 {
  };
  var _window_UIEvent;
  let UIEvent = (_window_UIEvent = window2.UIEvent) !== null && _window_UIEvent !== void 0 ? _window_UIEvent : class extends Event2 {
  };
  var _window_CompositionEvent;
  let CompositionEvent = (_window_CompositionEvent = window2.CompositionEvent) !== null && _window_CompositionEvent !== void 0 ? _window_CompositionEvent : class extends UIEvent {
  };
  var _window_FocusEvent;
  let FocusEvent = (_window_FocusEvent = window2.FocusEvent) !== null && _window_FocusEvent !== void 0 ? _window_FocusEvent : class extends UIEvent {
  };
  var _window_InputEvent;
  let InputEvent = (_window_InputEvent = window2.InputEvent) !== null && _window_InputEvent !== void 0 ? _window_InputEvent : class extends UIEvent {
  };
  var _window_KeyboardEvent;
  let KeyboardEvent = (_window_KeyboardEvent = window2.KeyboardEvent) !== null && _window_KeyboardEvent !== void 0 ? _window_KeyboardEvent : class extends UIEvent {
  };
  var _window_MouseEvent;
  let MouseEvent = (_window_MouseEvent = window2.MouseEvent) !== null && _window_MouseEvent !== void 0 ? _window_MouseEvent : class extends UIEvent {
  };
  var _window_DragEvent;
  let DragEvent = (_window_DragEvent = window2.DragEvent) !== null && _window_DragEvent !== void 0 ? _window_DragEvent : class extends MouseEvent {
  };
  var _window_PointerEvent;
  let PointerEvent = (_window_PointerEvent = window2.PointerEvent) !== null && _window_PointerEvent !== void 0 ? _window_PointerEvent : class extends MouseEvent {
  };
  var _window_TouchEvent;
  let TouchEvent = (_window_TouchEvent = window2.TouchEvent) !== null && _window_TouchEvent !== void 0 ? _window_TouchEvent : class extends UIEvent {
  };
  return { Event: Event2, AnimationEvent, ClipboardEvent, PopStateEvent, ProgressEvent, TransitionEvent, UIEvent, CompositionEvent, FocusEvent, InputEvent, KeyboardEvent, MouseEvent, DragEvent, PointerEvent, TouchEvent };
}
function assignProps(obj, props) {
  for (let [key2, value2] of Object.entries(props)) Object.defineProperty(obj, key2, { get: () => value2 ?? null });
}
function sanitizeNumber(n3) {
  return Number(n3 ?? 0);
}
function initClipboardEvent(event, { clipboardData }) {
  assignProps(event, { clipboardData });
}
function initInputEvent(event, { data, inputType, isComposing }) {
  assignProps(event, { data, isComposing: !!isComposing, inputType: String(inputType) });
}
function initUIEvent(event, { view, detail }) {
  assignProps(event, { view, detail: sanitizeNumber(detail ?? 0) });
}
function initUIEventModififiers(event, { altKey, ctrlKey, metaKey, shiftKey, modifierAltGraph, modifierCapsLock, modifierFn, modifierFnLock, modifierNumLock, modifierScrollLock, modifierSymbol, modifierSymbolLock }) {
  assignProps(event, { altKey: !!altKey, ctrlKey: !!ctrlKey, metaKey: !!metaKey, shiftKey: !!shiftKey, getModifierState(k22) {
    return !!{ Alt: altKey, AltGraph: modifierAltGraph, CapsLock: modifierCapsLock, Control: ctrlKey, Fn: modifierFn, FnLock: modifierFnLock, Meta: metaKey, NumLock: modifierNumLock, ScrollLock: modifierScrollLock, Shift: shiftKey, Symbol: modifierSymbol, SymbolLock: modifierSymbolLock }[k22];
  } });
}
function initKeyboardEvent(event, { key: key2, code, location, repeat, isComposing, charCode }) {
  assignProps(event, { key: String(key2), code: String(code), location: sanitizeNumber(location), repeat: !!repeat, isComposing: !!isComposing, charCode });
}
function initMouseEvent(event, { x: x22, y: y22, screenX, screenY, clientX = x22, clientY = y22, button, buttons, relatedTarget }) {
  assignProps(event, { screenX: sanitizeNumber(screenX), screenY: sanitizeNumber(screenY), clientX: sanitizeNumber(clientX), x: sanitizeNumber(clientX), clientY: sanitizeNumber(clientY), y: sanitizeNumber(clientY), button: sanitizeNumber(button), buttons: sanitizeNumber(buttons), relatedTarget });
}
function initPointerEvent(event, { pointerId, width, height, pressure, tangentialPressure, tiltX, tiltY, twist, pointerType, isPrimary }) {
  assignProps(event, { pointerId: sanitizeNumber(pointerId), width: sanitizeNumber(width), height: sanitizeNumber(height), pressure: sanitizeNumber(pressure), tangentialPressure: sanitizeNumber(tangentialPressure), tiltX: sanitizeNumber(tiltX), tiltY: sanitizeNumber(tiltY), twist: sanitizeNumber(twist), pointerType: String(pointerType), isPrimary: !!isPrimary });
}
function dispatchUIEvent(target, type5, init, preventDefault = false) {
  (isMouseEvent(type5) || isKeyboardEvent(type5)) && (init = { ...init, ...this.system.getUIEventModifiers() });
  let event = createEvent2(type5, target, init);
  return dispatchEvent.call(this, target, event, preventDefault);
}
function dispatchEvent(target, event, preventDefault = false) {
  var _behavior_type;
  let type5 = event.type, behaviorImplementation = preventDefault ? () => {
  } : (_behavior_type = behavior[type5]) === null || _behavior_type === void 0 ? void 0 : _behavior_type.call(behavior, event, target, this);
  if (behaviorImplementation) {
    event.preventDefault();
    let defaultPrevented = false;
    return Object.defineProperty(event, "defaultPrevented", { get: () => defaultPrevented }), Object.defineProperty(event, "preventDefault", { value: () => {
      defaultPrevented = event.cancelable;
    } }), wrapEvent(() => target.dispatchEvent(event)), defaultPrevented || behaviorImplementation(), !defaultPrevented;
  }
  return wrapEvent(() => target.dispatchEvent(event));
}
function dispatchDOMEvent(target, type5, init) {
  let event = createEvent2(type5, target, init);
  wrapEvent(() => target.dispatchEvent(event));
}
var Interceptor = Symbol("Interceptor for programmatical calls");
function prepareInterceptor(element, propName, interceptorImpl) {
  let prototypeDescriptor = Object.getOwnPropertyDescriptor(element.constructor.prototype, propName), objectDescriptor = Object.getOwnPropertyDescriptor(element, propName), target = (prototypeDescriptor == null ? void 0 : prototypeDescriptor.set) ? "set" : "value";
  if (typeof (prototypeDescriptor == null ? void 0 : prototypeDescriptor[target]) != "function" || prototypeDescriptor[target][Interceptor]) throw new Error(`Element ${element.tagName} does not implement "${String(propName)}".`);
  function intercept(...args2) {
    let { applyNative = false, realArgs, then } = interceptorImpl.call(this, ...args2), realFunc = (!applyNative && objectDescriptor || prototypeDescriptor)[target];
    target === "set" ? realFunc.call(this, realArgs) : realFunc.call(this, ...realArgs), then == null ? void 0 : then();
  }
  intercept[Interceptor] = Interceptor, Object.defineProperty(element, propName, { ...objectDescriptor ?? prototypeDescriptor, [target]: intercept });
}
function prepareValueInterceptor(element) {
  prepareInterceptor(element, "value", function(v6) {
    let isUI = isUIValue(v6);
    return isUI && startTrackValue(this), { applyNative: !!isUI, realArgs: sanitizeValue(this, v6), then: isUI ? void 0 : () => trackOrSetValue(this, String(v6)) };
  });
}
function sanitizeValue(element, v6) {
  return isElementType(element, "input", { type: "number" }) && String(v6) !== "" && !Number.isNaN(Number(v6)) ? String(Number(v6)) : String(v6);
}
function prepareSelectionInterceptor(element) {
  prepareInterceptor(element, "setSelectionRange", function(start, ...others) {
    let isUI = isUISelectionStart(start);
    return { applyNative: !!isUI, realArgs: [Number(start), ...others], then: () => isUI ? void 0 : setUISelectionClean(element) };
  }), prepareInterceptor(element, "selectionStart", function(v6) {
    return { realArgs: v6, then: () => setUISelectionClean(element) };
  }), prepareInterceptor(element, "selectionEnd", function(v6) {
    return { realArgs: v6, then: () => setUISelectionClean(element) };
  }), prepareInterceptor(element, "select", function() {
    return { realArgs: [], then: () => setUISelectionRaw(element, { anchorOffset: 0, focusOffset: getUIValue(element).length }) };
  });
}
function prepareRangeTextInterceptor(element) {
  prepareInterceptor(element, "setRangeText", function(...realArgs) {
    return { realArgs, then: () => {
      setUIValueClean(element), setUISelectionClean(element);
    } };
  });
}
var isPrepared = Symbol("Node prepared with document state workarounds");
function prepareDocument(document2) {
  document2[isPrepared] || (document2.addEventListener("focus", (e2) => {
    let el = e2.target;
    prepareElement(el);
  }, { capture: true, passive: true }), document2.activeElement && prepareElement(document2.activeElement), document2.addEventListener("blur", (e2) => {
    let el = e2.target, initialValue2 = getInitialValue(el);
    initialValue2 !== void 0 && (el.value !== initialValue2 && dispatchDOMEvent(el, "change"), clearInitialValue(el));
  }, { capture: true, passive: true }), document2[isPrepared] = isPrepared);
}
function prepareElement(el) {
  el[isPrepared] || (isElementType(el, ["input", "textarea"]) && (prepareValueInterceptor(el), prepareSelectionInterceptor(el), prepareRangeTextInterceptor(el)), el[isPrepared] = isPrepared);
}
function getDocumentFromNode(el) {
  return isDocument2(el) ? el : el.ownerDocument;
}
function isDocument2(node) {
  return node.nodeType === 9;
}
function wait(config3) {
  let delay = config3.delay;
  if (typeof delay == "number") return Promise.all([new Promise((resolve) => globalThis.setTimeout(() => resolve(), delay)), config3.advanceTimers(delay)]);
}
function _define_property3(obj, key2, value2) {
  return key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
var DOM_KEY_LOCATION;
(function(DOM_KEY_LOCATION2) {
  DOM_KEY_LOCATION2[DOM_KEY_LOCATION2.STANDARD = 0] = "STANDARD", DOM_KEY_LOCATION2[DOM_KEY_LOCATION2.LEFT = 1] = "LEFT", DOM_KEY_LOCATION2[DOM_KEY_LOCATION2.RIGHT = 2] = "RIGHT", DOM_KEY_LOCATION2[DOM_KEY_LOCATION2.NUMPAD = 3] = "NUMPAD";
})(DOM_KEY_LOCATION || (DOM_KEY_LOCATION = {}));
var modifierKeys = ["Alt", "AltGraph", "Control", "Fn", "Meta", "Shift", "Symbol"];
function isModifierKey(key2) {
  return modifierKeys.includes(key2);
}
var modifierLocks = ["CapsLock", "FnLock", "NumLock", "ScrollLock", "SymbolLock"];
function isModifierLock(key2) {
  return modifierLocks.includes(key2);
}
var KeyboardHost = class {
  isKeyPressed(keyDef) {
    return !!this.pressed[String(keyDef.code)];
  }
  getPressedKeys() {
    return Object.values(this.pressed).map((p32) => p32.keyDef);
  }
  async keydown(instance, keyDef) {
    var _this_pressed, _code, _this_pressed_code;
    let key2 = String(keyDef.key), code = String(keyDef.code), target = getActiveElementOrBody(instance.config.document);
    this.setKeydownTarget(target);
    var _4;
    (_4 = (_this_pressed = this.pressed)[_code = code]) !== null && _4 !== void 0 || (_this_pressed[_code] = { keyDef, unpreventedDefault: false }), isModifierKey(key2) && (this.modifiers[key2] = true);
    let unprevented = instance.dispatchUIEvent(target, "keydown", { key: key2, code });
    isModifierLock(key2) && !this.modifiers[key2] && (this.modifiers[key2] = true, this.modifierLockStart[key2] = true), (_this_pressed_code = this.pressed[code]).unpreventedDefault || (_this_pressed_code.unpreventedDefault = unprevented), unprevented && this.hasKeyPress(key2) && instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), "keypress", { key: key2, code, charCode: keyDef.key === "Enter" ? 13 : String(keyDef.key).charCodeAt(0) });
  }
  async keyup(instance, keyDef) {
    let key2 = String(keyDef.key), code = String(keyDef.code), unprevented = this.pressed[code].unpreventedDefault;
    delete this.pressed[code], isModifierKey(key2) && !Object.values(this.pressed).find((p32) => p32.keyDef.key === key2) && (this.modifiers[key2] = false), instance.dispatchUIEvent(getActiveElementOrBody(instance.config.document), "keyup", { key: key2, code }, !unprevented), isModifierLock(key2) && this.modifiers[key2] && (this.modifierLockStart[key2] ? this.modifierLockStart[key2] = false : this.modifiers[key2] = false);
  }
  setKeydownTarget(target) {
    target !== this.lastKeydownTarget && (this.carryChar = ""), this.lastKeydownTarget = target;
  }
  hasKeyPress(key2) {
    return (key2.length === 1 || key2 === "Enter") && !this.modifiers.Control && !this.modifiers.Alt;
  }
  constructor(system) {
    _define_property3(this, "system", void 0), _define_property3(this, "modifiers", { Alt: false, AltGraph: false, CapsLock: false, Control: false, Fn: false, FnLock: false, Meta: false, NumLock: false, ScrollLock: false, Shift: false, Symbol: false, SymbolLock: false }), _define_property3(this, "pressed", {}), _define_property3(this, "carryChar", ""), _define_property3(this, "lastKeydownTarget", void 0), _define_property3(this, "modifierLockStart", {}), this.system = system;
  }
};
var defaultKeyMap = [..."0123456789".split("").map((c3) => ({ code: `Digit${c3}`, key: c3 })), ...")!@#$%^&*(".split("").map((c3, i4) => ({ code: `Digit${i4}`, key: c3, shiftKey: true })), ..."abcdefghijklmnopqrstuvwxyz".split("").map((c3) => ({ code: `Key${c3.toUpperCase()}`, key: c3 })), ..."ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").map((c3) => ({ code: `Key${c3}`, key: c3, shiftKey: true })), { code: "Space", key: " " }, { code: "AltLeft", key: "Alt", location: DOM_KEY_LOCATION.LEFT }, { code: "AltRight", key: "Alt", location: DOM_KEY_LOCATION.RIGHT }, { code: "ShiftLeft", key: "Shift", location: DOM_KEY_LOCATION.LEFT }, { code: "ShiftRight", key: "Shift", location: DOM_KEY_LOCATION.RIGHT }, { code: "ControlLeft", key: "Control", location: DOM_KEY_LOCATION.LEFT }, { code: "ControlRight", key: "Control", location: DOM_KEY_LOCATION.RIGHT }, { code: "MetaLeft", key: "Meta", location: DOM_KEY_LOCATION.LEFT }, { code: "MetaRight", key: "Meta", location: DOM_KEY_LOCATION.RIGHT }, { code: "OSLeft", key: "OS", location: DOM_KEY_LOCATION.LEFT }, { code: "OSRight", key: "OS", location: DOM_KEY_LOCATION.RIGHT }, { code: "Tab", key: "Tab" }, { code: "CapsLock", key: "CapsLock" }, { code: "Backspace", key: "Backspace" }, { code: "Enter", key: "Enter" }, { code: "Escape", key: "Escape" }, { code: "ArrowUp", key: "ArrowUp" }, { code: "ArrowDown", key: "ArrowDown" }, { code: "ArrowLeft", key: "ArrowLeft" }, { code: "ArrowRight", key: "ArrowRight" }, { code: "Home", key: "Home" }, { code: "End", key: "End" }, { code: "Delete", key: "Delete" }, { code: "PageUp", key: "PageUp" }, { code: "PageDown", key: "PageDown" }, { code: "Fn", key: "Fn" }, { code: "Symbol", key: "Symbol" }, { code: "AltRight", key: "AltGraph" }];
var defaultKeyMap2 = [{ name: "MouseLeft", pointerType: "mouse", button: "primary" }, { name: "MouseRight", pointerType: "mouse", button: "secondary" }, { name: "MouseMiddle", pointerType: "mouse", button: "auxiliary" }, { name: "TouchA", pointerType: "touch" }, { name: "TouchB", pointerType: "touch" }, { name: "TouchC", pointerType: "touch" }];
function _define_property4(obj, key2, value2) {
  return key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
var Buttons = class {
  getButtons() {
    let v6 = 0;
    for (let button of Object.keys(this.pressed)) v6 |= 2 ** Number(button);
    return v6;
  }
  down(keyDef) {
    let button = getMouseButtonId(keyDef.button);
    if (button in this.pressed) {
      this.pressed[button].push(keyDef);
      return;
    }
    return this.pressed[button] = [keyDef], button;
  }
  up(keyDef) {
    let button = getMouseButtonId(keyDef.button);
    if (button in this.pressed && (this.pressed[button] = this.pressed[button].filter((k22) => k22.name !== keyDef.name), this.pressed[button].length === 0)) return delete this.pressed[button], button;
  }
  constructor() {
    _define_property4(this, "pressed", {});
  }
};
var MouseButton = { primary: 0, secondary: 1, auxiliary: 2, back: 3, X1: 3, forward: 4, X2: 4 };
function getMouseButtonId(button = 0) {
  return button in MouseButton ? MouseButton[button] : Number(button);
}
var MouseButtonFlip = { 1: 2, 2: 1 };
function getMouseEventButton(button) {
  return button = getMouseButtonId(button), button in MouseButtonFlip ? MouseButtonFlip[button] : button;
}
function _define_property5(obj, key2, value2) {
  return key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
var Device = class {
  get countPressed() {
    return this.pressedKeys.size;
  }
  isPressed(keyDef) {
    return this.pressedKeys.has(keyDef.name);
  }
  addPressed(keyDef) {
    return this.pressedKeys.add(keyDef.name);
  }
  removePressed(keyDef) {
    return this.pressedKeys.delete(keyDef.name);
  }
  constructor() {
    _define_property5(this, "pressedKeys", /* @__PURE__ */ new Set());
  }
};
function getTreeDiff(a22, b6) {
  let treeA = [];
  for (let el = a22; el; el = el.parentElement) treeA.push(el);
  let treeB = [];
  for (let el = b6; el; el = el.parentElement) treeB.push(el);
  let i4 = 0;
  for (; !(i4 >= treeA.length || i4 >= treeB.length || treeA[treeA.length - 1 - i4] !== treeB[treeB.length - 1 - i4]); i4++) ;
  return [treeA.slice(0, treeA.length - i4), treeB.slice(0, treeB.length - i4), treeB.slice(treeB.length - i4)];
}
function resolveCaretPosition({ target, node, offset }) {
  return hasOwnSelection(target) ? { node: target, offset: offset ?? getUIValue(target).length } : node ? { node, offset: offset ?? (node.nodeType === 3 ? node.nodeValue.length : node.childNodes.length) } : findNodeAtTextOffset(target, offset);
}
function findNodeAtTextOffset(node, offset, isRoot = true) {
  let i4 = offset === void 0 ? node.childNodes.length - 1 : 0, step = offset === void 0 ? -1 : 1;
  for (; offset === void 0 ? i4 >= (isRoot ? Math.max(node.childNodes.length - 1, 0) : 0) : i4 <= node.childNodes.length; ) {
    if (offset && i4 === node.childNodes.length) throw new Error("The given offset is out of bounds.");
    let c3 = node.childNodes.item(i4), text = String(c3.textContent);
    if (text.length) if (offset !== void 0 && text.length < offset) offset -= text.length;
    else {
      if (c3.nodeType === 1) return findNodeAtTextOffset(c3, offset, false);
      if (c3.nodeType === 3) return { node: c3, offset: offset ?? c3.nodeValue.length };
    }
    i4 += step;
  }
  return { node, offset: node.childNodes.length };
}
function setSelectionPerMouseDown({ document: document2, target, clickCount, node, offset }) {
  if (hasNoSelection(target)) return;
  let targetHasOwnSelection = hasOwnSelection(target), text = String(targetHasOwnSelection ? getUIValue(target) : target.textContent), [start, end] = node ? [offset, offset] : getTextRange(text, offset, clickCount);
  if (targetHasOwnSelection) return setUISelection(target, { anchorOffset: start ?? text.length, focusOffset: end ?? text.length }), { node: target, start: start ?? 0, end: end ?? text.length };
  {
    let { node: startNode, offset: startOffset } = resolveCaretPosition({ target, node, offset: start }), { node: endNode, offset: endOffset } = resolveCaretPosition({ target, node, offset: end }), range = target.ownerDocument.createRange();
    try {
      range.setStart(startNode, startOffset), range.setEnd(endNode, endOffset);
    } catch {
      throw new Error("The given offset is out of bounds.");
    }
    let selection = document2.getSelection();
    return selection == null ? void 0 : selection.removeAllRanges(), selection == null ? void 0 : selection.addRange(range.cloneRange()), range;
  }
}
function getTextRange(text, pos, clickCount) {
  if (clickCount % 3 === 1 || text.length === 0) return [pos, pos];
  let textPos = pos ?? text.length;
  return clickCount % 3 === 2 ? [textPos - text.substr(0, pos).match(/(\w+|\s+|\W)?$/)[0].length, pos === void 0 ? pos : pos + text.substr(pos).match(/^(\w+|\s+|\W)?/)[0].length] : [textPos - text.substr(0, pos).match(/[^\r\n]*$/)[0].length, pos === void 0 ? pos : pos + text.substr(pos).match(/^[^\r\n]*/)[0].length];
}
function modifySelectionPerMouseMove(selectionRange, { document: document2, target, node, offset }) {
  let selectionFocus = resolveCaretPosition({ target, node, offset });
  if ("node" in selectionRange) {
    if (selectionFocus.node === selectionRange.node) {
      let anchorOffset = selectionFocus.offset < selectionRange.start ? selectionRange.end : selectionRange.start, focusOffset = selectionFocus.offset > selectionRange.end || selectionFocus.offset < selectionRange.start ? selectionFocus.offset : selectionRange.end;
      setUISelection(selectionRange.node, { anchorOffset, focusOffset });
    }
  } else {
    let range = selectionRange.cloneRange(), cmp = range.comparePoint(selectionFocus.node, selectionFocus.offset);
    cmp < 0 ? range.setStart(selectionFocus.node, selectionFocus.offset) : cmp > 0 && range.setEnd(selectionFocus.node, selectionFocus.offset);
    let selection = document2.getSelection();
    selection == null ? void 0 : selection.removeAllRanges(), selection == null ? void 0 : selection.addRange(range.cloneRange());
  }
}
function isDifferentPointerPosition(positionA, positionB) {
  var _positionA_coords, _positionB_coords, _positionA_coords1, _positionB_coords1, _positionA_caret, _positionB_caret, _positionA_caret1, _positionB_caret1;
  return positionA.target !== positionB.target || ((_positionA_coords = positionA.coords) === null || _positionA_coords === void 0 ? void 0 : _positionA_coords.x) !== ((_positionB_coords = positionB.coords) === null || _positionB_coords === void 0 ? void 0 : _positionB_coords.y) || ((_positionA_coords1 = positionA.coords) === null || _positionA_coords1 === void 0 ? void 0 : _positionA_coords1.y) !== ((_positionB_coords1 = positionB.coords) === null || _positionB_coords1 === void 0 ? void 0 : _positionB_coords1.y) || ((_positionA_caret = positionA.caret) === null || _positionA_caret === void 0 ? void 0 : _positionA_caret.node) !== ((_positionB_caret = positionB.caret) === null || _positionB_caret === void 0 ? void 0 : _positionB_caret.node) || ((_positionA_caret1 = positionA.caret) === null || _positionA_caret1 === void 0 ? void 0 : _positionA_caret1.offset) !== ((_positionB_caret1 = positionB.caret) === null || _positionB_caret1 === void 0 ? void 0 : _positionB_caret1.offset);
}
function _define_property6(obj, key2, value2) {
  return key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
var Mouse = class {
  move(instance, position) {
    let prevPosition = this.position, prevTarget = this.getTarget(instance);
    if (this.position = position, !isDifferentPointerPosition(prevPosition, position)) return;
    let nextTarget = this.getTarget(instance), init = this.getEventInit("mousemove"), [leave, enter] = getTreeDiff(prevTarget, nextTarget);
    return { leave: () => {
      prevTarget !== nextTarget && (instance.dispatchUIEvent(prevTarget, "mouseout", init), leave.forEach((el) => instance.dispatchUIEvent(el, "mouseleave", init)));
    }, enter: () => {
      prevTarget !== nextTarget && (instance.dispatchUIEvent(nextTarget, "mouseover", init), enter.forEach((el) => instance.dispatchUIEvent(el, "mouseenter", init)));
    }, move: () => {
      instance.dispatchUIEvent(nextTarget, "mousemove", init), this.modifySelecting(instance);
    } };
  }
  down(instance, keyDef, pointer3) {
    let button = this.buttons.down(keyDef);
    if (button === void 0) return;
    let target = this.getTarget(instance);
    this.buttonDownTarget[button] = target;
    let disabled = isDisabled2(target), init = this.getEventInit("mousedown", keyDef.button);
    (disabled || instance.dispatchUIEvent(target, "mousedown", init)) && (this.startSelecting(instance, init.detail), focusElement(target)), !disabled && getMouseEventButton(keyDef.button) === 2 && instance.dispatchUIEvent(target, "contextmenu", this.getEventInit("contextmenu", keyDef.button, pointer3));
  }
  up(instance, keyDef, pointer3) {
    let button = this.buttons.up(keyDef);
    if (button === void 0) return;
    let target = this.getTarget(instance);
    if (!isDisabled2(target)) {
      instance.dispatchUIEvent(target, "mouseup", this.getEventInit("mouseup", keyDef.button)), this.endSelecting();
      let clickTarget = getTreeDiff(this.buttonDownTarget[button], target)[2][0];
      if (clickTarget) {
        let init = this.getEventInit("click", keyDef.button, pointer3);
        init.detail && (instance.dispatchUIEvent(clickTarget, init.button === 0 ? "click" : "auxclick", init), init.button === 0 && init.detail === 2 && instance.dispatchUIEvent(clickTarget, "dblclick", { ...this.getEventInit("dblclick", keyDef.button), detail: init.detail }));
      }
    }
  }
  resetClickCount() {
    this.clickCount.reset();
  }
  getEventInit(type5, button, pointer3) {
    let init = { ...this.position.coords };
    return pointer3 && (init.pointerId = pointer3.pointerId, init.pointerType = pointer3.pointerType, init.isPrimary = pointer3.isPrimary), init.button = getMouseEventButton(button), init.buttons = this.buttons.getButtons(), type5 === "mousedown" ? init.detail = this.clickCount.getOnDown(init.button) : type5 === "mouseup" ? init.detail = this.clickCount.getOnUp(init.button) : (type5 === "click" || type5 === "auxclick") && (init.detail = this.clickCount.incOnClick(init.button)), init;
  }
  getTarget(instance) {
    var _this_position_target;
    return (_this_position_target = this.position.target) !== null && _this_position_target !== void 0 ? _this_position_target : instance.config.document.body;
  }
  startSelecting(instance, clickCount) {
    var _this_position_caret, _this_position_caret1;
    this.selecting = setSelectionPerMouseDown({ document: instance.config.document, target: this.getTarget(instance), node: (_this_position_caret = this.position.caret) === null || _this_position_caret === void 0 ? void 0 : _this_position_caret.node, offset: (_this_position_caret1 = this.position.caret) === null || _this_position_caret1 === void 0 ? void 0 : _this_position_caret1.offset, clickCount });
  }
  modifySelecting(instance) {
    var _this_position_caret, _this_position_caret1;
    this.selecting && modifySelectionPerMouseMove(this.selecting, { document: instance.config.document, target: this.getTarget(instance), node: (_this_position_caret = this.position.caret) === null || _this_position_caret === void 0 ? void 0 : _this_position_caret.node, offset: (_this_position_caret1 = this.position.caret) === null || _this_position_caret1 === void 0 ? void 0 : _this_position_caret1.offset });
  }
  endSelecting() {
    this.selecting = void 0;
  }
  constructor() {
    _define_property6(this, "position", {}), _define_property6(this, "buttons", new Buttons()), _define_property6(this, "selecting", void 0), _define_property6(this, "buttonDownTarget", {}), _define_property6(this, "clickCount", new class {
      incOnClick(button) {
        let current = this.down[button] === void 0 ? void 0 : Number(this.down[button]) + 1;
        return this.count = this.count[button] === void 0 ? {} : { [button]: Number(this.count[button]) + 1 }, current;
      }
      getOnDown(button) {
        var _this_count_button;
        this.down = { [button]: (_this_count_button = this.count[button]) !== null && _this_count_button !== void 0 ? _this_count_button : 0 };
        var _this_count_button1;
        return this.count = { [button]: (_this_count_button1 = this.count[button]) !== null && _this_count_button1 !== void 0 ? _this_count_button1 : 0 }, Number(this.count[button]) + 1;
      }
      getOnUp(button) {
        return this.down[button] === void 0 ? void 0 : Number(this.down[button]) + 1;
      }
      reset() {
        this.count = {};
      }
      constructor() {
        _define_property6(this, "down", {}), _define_property6(this, "count", {});
      }
    }());
  }
};
function hasPointerEvents(instance, element) {
  var _checkPointerEvents;
  return ((_checkPointerEvents = checkPointerEvents(instance, element)) === null || _checkPointerEvents === void 0 ? void 0 : _checkPointerEvents.pointerEvents) !== "none";
}
function closestPointerEventsDeclaration(element) {
  let window2 = getWindow(element);
  for (let el = element, tree = []; el == null ? void 0 : el.ownerDocument; el = el.parentElement) {
    tree.push(el);
    let pointerEvents = window2.getComputedStyle(el).pointerEvents;
    if (pointerEvents && !["inherit", "unset"].includes(pointerEvents)) return { pointerEvents, tree };
  }
}
var PointerEventsCheck = Symbol("Last check for pointer-events");
function checkPointerEvents(instance, element) {
  let lastCheck = element[PointerEventsCheck];
  if (!(instance.config.pointerEventsCheck !== PointerEventsCheckLevel.Never && (!lastCheck || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachApiCall) && lastCheck[ApiLevel.Call] !== getLevelRef(instance, ApiLevel.Call) || hasBitFlag(instance.config.pointerEventsCheck, PointerEventsCheckLevel.EachTrigger) && lastCheck[ApiLevel.Trigger] !== getLevelRef(instance, ApiLevel.Trigger)))) return lastCheck == null ? void 0 : lastCheck.result;
  let declaration = closestPointerEventsDeclaration(element);
  return element[PointerEventsCheck] = { [ApiLevel.Call]: getLevelRef(instance, ApiLevel.Call), [ApiLevel.Trigger]: getLevelRef(instance, ApiLevel.Trigger), result: declaration }, declaration;
}
function assertPointerEvents(instance, element) {
  let declaration = checkPointerEvents(instance, element);
  if ((declaration == null ? void 0 : declaration.pointerEvents) === "none") throw new Error([`Unable to perform pointer interaction as the element ${declaration.tree.length > 1 ? "inherits" : "has"} \`pointer-events: none\`:`, "", printTree(declaration.tree)].join(`
`));
}
function printTree(tree) {
  return tree.reverse().map((el, i4) => ["".padEnd(i4), el.tagName, el.id && `#${el.id}`, el.hasAttribute("data-testid") && `(testId=${el.getAttribute("data-testid")})`, getLabelDescr(el), tree.length > 1 && i4 === 0 && "  <-- This element declared `pointer-events: none`", tree.length > 1 && i4 === tree.length - 1 && "  <-- Asserted pointer events here"].filter(Boolean).join("")).join(`
`);
}
function getLabelDescr(element) {
  var _element_labels;
  let label;
  if (element.hasAttribute("aria-label")) label = element.getAttribute("aria-label");
  else if (element.hasAttribute("aria-labelledby")) {
    var _element_ownerDocument_getElementById_textContent, _element_ownerDocument_getElementById;
    label = (_element_ownerDocument_getElementById = element.ownerDocument.getElementById(element.getAttribute("aria-labelledby"))) === null || _element_ownerDocument_getElementById === void 0 || (_element_ownerDocument_getElementById_textContent = _element_ownerDocument_getElementById.textContent) === null || _element_ownerDocument_getElementById_textContent === void 0 ? void 0 : _element_ownerDocument_getElementById_textContent.trim();
  } else if (isElementType(element, ["button", "input", "meter", "output", "progress", "select", "textarea"]) && (!((_element_labels = element.labels) === null || _element_labels === void 0) && _element_labels.length)) label = Array.from(element.labels).map((el) => {
    var _el_textContent;
    return (_el_textContent = el.textContent) === null || _el_textContent === void 0 ? void 0 : _el_textContent.trim();
  }).join("|");
  else if (isElementType(element, "button")) {
    var _element_textContent;
    label = (_element_textContent = element.textContent) === null || _element_textContent === void 0 ? void 0 : _element_textContent.trim();
  }
  return label = label == null ? void 0 : label.replace(/\n/g, "  "), Number(label == null ? void 0 : label.length) > 30 && (label = `${label == null ? void 0 : label.substring(0, 29)}`), label ? `(label=${label})` : "";
}
function hasBitFlag(conf, flag3) {
  return (conf & flag3) > 0;
}
function _define_property7(obj, key2, value2) {
  return key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
var Pointer = class {
  init(instance, position) {
    this.position = position;
    let target = this.getTarget(instance), [, enter] = getTreeDiff(null, target), init = this.getEventInit();
    return assertPointerEvents(instance, target), instance.dispatchUIEvent(target, "pointerover", init), enter.forEach((el) => instance.dispatchUIEvent(el, "pointerenter", init)), this;
  }
  move(instance, position) {
    let prevPosition = this.position, prevTarget = this.getTarget(instance);
    if (this.position = position, !isDifferentPointerPosition(prevPosition, position)) return;
    let nextTarget = this.getTarget(instance), init = this.getEventInit(), [leave, enter] = getTreeDiff(prevTarget, nextTarget);
    return { leave: () => {
      hasPointerEvents(instance, prevTarget) && prevTarget !== nextTarget && (instance.dispatchUIEvent(prevTarget, "pointerout", init), leave.forEach((el) => instance.dispatchUIEvent(el, "pointerleave", init)));
    }, enter: () => {
      assertPointerEvents(instance, nextTarget), prevTarget !== nextTarget && (instance.dispatchUIEvent(nextTarget, "pointerover", init), enter.forEach((el) => instance.dispatchUIEvent(el, "pointerenter", init)));
    }, move: () => {
      instance.dispatchUIEvent(nextTarget, "pointermove", init);
    } };
  }
  down(instance, _keyDef) {
    if (this.isDown) return;
    let target = this.getTarget(instance);
    assertPointerEvents(instance, target), this.isDown = true, this.isPrevented = !instance.dispatchUIEvent(target, "pointerdown", this.getEventInit());
  }
  up(instance, _keyDef) {
    if (!this.isDown) return;
    let target = this.getTarget(instance);
    assertPointerEvents(instance, target), this.isDown = false, instance.dispatchUIEvent(target, "pointerup", this.getEventInit());
  }
  release(instance) {
    let target = this.getTarget(instance), [leave] = getTreeDiff(target, null), init = this.getEventInit();
    hasPointerEvents(instance, target) && (instance.dispatchUIEvent(target, "pointerout", init), leave.forEach((el) => instance.dispatchUIEvent(el, "pointerleave", init))), this.isCancelled = true;
  }
  getTarget(instance) {
    var _this_position_target;
    return (_this_position_target = this.position.target) !== null && _this_position_target !== void 0 ? _this_position_target : instance.config.document.body;
  }
  getEventInit() {
    return { ...this.position.coords, pointerId: this.pointerId, pointerType: this.pointerType, isPrimary: this.isPrimary };
  }
  constructor({ pointerId, pointerType, isPrimary }) {
    _define_property7(this, "pointerId", void 0), _define_property7(this, "pointerType", void 0), _define_property7(this, "isPrimary", void 0), _define_property7(this, "isMultitouch", false), _define_property7(this, "isCancelled", false), _define_property7(this, "isDown", false), _define_property7(this, "isPrevented", false), _define_property7(this, "position", {}), this.pointerId = pointerId, this.pointerType = pointerType, this.isPrimary = isPrimary, this.isMultitouch = !isPrimary;
  }
};
function _define_property8(obj, key2, value2) {
  return key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
var PointerHost = class {
  isKeyPressed(keyDef) {
    return this.devices.get(keyDef.pointerType).isPressed(keyDef);
  }
  async press(instance, keyDef, position) {
    let pointerName = this.getPointerName(keyDef), pointer3 = keyDef.pointerType === "touch" ? this.pointers.new(pointerName, keyDef).init(instance, position) : this.pointers.get(pointerName);
    pointer3.position = position, pointer3.pointerType !== "touch" && (this.mouse.position = position), this.devices.get(keyDef.pointerType).addPressed(keyDef), this.buttons.down(keyDef), pointer3.down(instance, keyDef), pointer3.pointerType !== "touch" && !pointer3.isPrevented && this.mouse.down(instance, keyDef, pointer3);
  }
  async move(instance, pointerName, position) {
    let pointer3 = this.pointers.get(pointerName), pointermove = pointer3.move(instance, position), mousemove = pointer3.pointerType === "touch" || pointer3.isPrevented && pointer3.isDown ? void 0 : this.mouse.move(instance, position);
    pointermove == null ? void 0 : pointermove.leave(), mousemove == null ? void 0 : mousemove.leave(), pointermove == null ? void 0 : pointermove.enter(), mousemove == null ? void 0 : mousemove.enter(), pointermove == null ? void 0 : pointermove.move(), mousemove == null ? void 0 : mousemove.move();
  }
  async release(instance, keyDef, position) {
    let device = this.devices.get(keyDef.pointerType);
    device.removePressed(keyDef), this.buttons.up(keyDef);
    let pointer3 = this.pointers.get(this.getPointerName(keyDef));
    if (pointer3.position = position, pointer3.pointerType !== "touch" && (this.mouse.position = position), device.countPressed === 0 && pointer3.up(instance, keyDef), pointer3.pointerType === "touch" && pointer3.release(instance), !pointer3.isPrevented) {
      if (pointer3.pointerType === "touch" && !pointer3.isMultitouch) {
        let mousemove = this.mouse.move(instance, pointer3.position);
        mousemove == null ? void 0 : mousemove.leave(), mousemove == null ? void 0 : mousemove.enter(), mousemove == null ? void 0 : mousemove.move(), this.mouse.down(instance, keyDef, pointer3);
      }
      if (!pointer3.isMultitouch) {
        let mousemove = this.mouse.move(instance, pointer3.position);
        mousemove == null ? void 0 : mousemove.leave(), mousemove == null ? void 0 : mousemove.enter(), mousemove == null ? void 0 : mousemove.move(), this.mouse.up(instance, keyDef, pointer3);
      }
    }
  }
  getPointerName(keyDef) {
    return keyDef.pointerType === "touch" ? keyDef.name : keyDef.pointerType;
  }
  getPreviousPosition(pointerName) {
    return this.pointers.has(pointerName) ? this.pointers.get(pointerName).position : void 0;
  }
  resetClickCount() {
    this.mouse.resetClickCount();
  }
  getMouseTarget(instance) {
    var _this_mouse_position_target;
    return (_this_mouse_position_target = this.mouse.position.target) !== null && _this_mouse_position_target !== void 0 ? _this_mouse_position_target : instance.config.document.body;
  }
  setMousePosition(position) {
    this.mouse.position = position, this.pointers.get("mouse").position = position;
  }
  constructor(system) {
    _define_property8(this, "system", void 0), _define_property8(this, "mouse", void 0), _define_property8(this, "buttons", void 0), _define_property8(this, "devices", new class {
      get(k22) {
        var _this_registry, _k, _4;
        return (_4 = (_this_registry = this.registry)[_k = k22]) !== null && _4 !== void 0 || (_this_registry[_k] = new Device()), this.registry[k22];
      }
      constructor() {
        _define_property8(this, "registry", {});
      }
    }()), _define_property8(this, "pointers", new class {
      new(pointerName, keyDef) {
        let isPrimary = keyDef.pointerType !== "touch" || !Object.values(this.registry).some((p32) => p32.pointerType === "touch" && !p32.isCancelled);
        return isPrimary || Object.values(this.registry).forEach((p32) => {
          p32.pointerType === keyDef.pointerType && !p32.isCancelled && (p32.isMultitouch = true);
        }), this.registry[pointerName] = new Pointer({ pointerId: this.nextId++, pointerType: keyDef.pointerType, isPrimary }), this.registry[pointerName];
      }
      get(pointerName) {
        if (!this.has(pointerName)) throw new Error(`Trying to access pointer "${pointerName}" which does not exist.`);
        return this.registry[pointerName];
      }
      has(pointerName) {
        return pointerName in this.registry;
      }
      constructor() {
        _define_property8(this, "registry", { mouse: new Pointer({ pointerId: 1, pointerType: "mouse", isPrimary: true }) }), _define_property8(this, "nextId", 2);
      }
    }()), this.system = system, this.buttons = new Buttons(), this.mouse = new Mouse();
  }
};
function _define_property9(obj, key2, value2) {
  return key2 in obj ? Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true }) : obj[key2] = value2, obj;
}
var System = class {
  getUIEventModifiers() {
    return { altKey: this.keyboard.modifiers.Alt, ctrlKey: this.keyboard.modifiers.Control, metaKey: this.keyboard.modifiers.Meta, shiftKey: this.keyboard.modifiers.Shift, modifierAltGraph: this.keyboard.modifiers.AltGraph, modifierCapsLock: this.keyboard.modifiers.CapsLock, modifierFn: this.keyboard.modifiers.Fn, modifierFnLock: this.keyboard.modifiers.FnLock, modifierNumLock: this.keyboard.modifiers.NumLock, modifierScrollLock: this.keyboard.modifiers.ScrollLock, modifierSymbol: this.keyboard.modifiers.Symbol, modifierSymbolLock: this.keyboard.modifiers.SymbolLock };
  }
  constructor() {
    _define_property9(this, "keyboard", new KeyboardHost(this)), _define_property9(this, "pointer", new PointerHost(this));
  }
};
async function click(element) {
  let pointerIn = [];
  return this.config.skipHover || pointerIn.push({ target: element }), pointerIn.push({ keys: "[MouseLeft]", target: element }), this.pointer(pointerIn);
}
async function dblClick(element) {
  return this.pointer([{ target: element }, "[MouseLeft][MouseLeft]"]);
}
async function tripleClick(element) {
  return this.pointer([{ target: element }, "[MouseLeft][MouseLeft][MouseLeft]"]);
}
async function hover(element) {
  return this.pointer({ target: element });
}
async function unhover(element) {
  return assertPointerEvents(this, this.system.pointer.getMouseTarget(this)), this.pointer({ target: element.ownerDocument.body });
}
async function tab({ shift } = {}) {
  return this.keyboard(shift === true ? "{Shift>}{Tab}{/Shift}" : shift === false ? "[/ShiftLeft][/ShiftRight]{Tab}" : "{Tab}");
}
function parseKeyDef(keyboardMap, text) {
  let defs = [];
  do {
    let { type: type5, descriptor, consumedLength, releasePrevious, releaseSelf = true, repeat } = readNextDescriptor(text, "keyboard");
    var _keyboardMap_find;
    let keyDef = (_keyboardMap_find = keyboardMap.find((def) => {
      if (type5 === "[") {
        var _def_code;
        return ((_def_code = def.code) === null || _def_code === void 0 ? void 0 : _def_code.toLowerCase()) === descriptor.toLowerCase();
      } else if (type5 === "{") {
        var _def_key;
        return ((_def_key = def.key) === null || _def_key === void 0 ? void 0 : _def_key.toLowerCase()) === descriptor.toLowerCase();
      }
      return def.key === descriptor;
    })) !== null && _keyboardMap_find !== void 0 ? _keyboardMap_find : { key: "Unknown", code: "Unknown", [type5 === "[" ? "code" : "key"]: descriptor };
    defs.push({ keyDef, releasePrevious, releaseSelf, repeat }), text = text.slice(consumedLength);
  } while (text);
  return defs;
}
async function keyboard(text) {
  let actions = parseKeyDef(this.config.keyboardMap, text);
  for (let i4 = 0; i4 < actions.length; i4++) await wait(this.config), await keyboardAction(this, actions[i4]);
}
async function keyboardAction(instance, { keyDef, releasePrevious, releaseSelf, repeat }) {
  let { system } = instance;
  if (system.keyboard.isKeyPressed(keyDef) && await system.keyboard.keyup(instance, keyDef), !releasePrevious) {
    for (let i4 = 1; i4 <= repeat; i4++) await system.keyboard.keydown(instance, keyDef), i4 < repeat && await wait(instance.config);
    releaseSelf && await system.keyboard.keyup(instance, keyDef);
  }
}
async function releaseAllKeys(instance) {
  for (let k22 of instance.system.keyboard.getPressedKeys()) await instance.system.keyboard.keyup(instance, k22);
}
function copySelection(target) {
  let data = hasOwnSelection(target) ? { "text/plain": readSelectedValueFromInput(target) } : { "text/plain": String(target.ownerDocument.getSelection()) }, dt2 = createDataTransfer(getWindow(target));
  for (let type5 in data) data[type5] && dt2.setData(type5, data[type5]);
  return dt2;
}
function readSelectedValueFromInput(target) {
  let sel = getUISelection(target);
  return getUIValue(target).substring(sel.startOffset, sel.endOffset);
}
async function copy() {
  let doc = this.config.document;
  var _doc_activeElement;
  let target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== void 0 ? _doc_activeElement : doc.body, clipboardData = copySelection(target);
  if (clipboardData.items.length !== 0) return this.dispatchUIEvent(target, "copy", { clipboardData }) && this.config.writeToClipboard && await writeDataTransferToClipboard(doc, clipboardData), clipboardData;
}
async function cut() {
  let doc = this.config.document;
  var _doc_activeElement;
  let target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== void 0 ? _doc_activeElement : doc.body, clipboardData = copySelection(target);
  if (clipboardData.items.length !== 0) return this.dispatchUIEvent(target, "cut", { clipboardData }) && this.config.writeToClipboard && await writeDataTransferToClipboard(target.ownerDocument, clipboardData), clipboardData;
}
async function paste(clipboardData) {
  let doc = this.config.document;
  var _doc_activeElement;
  let target = (_doc_activeElement = doc.activeElement) !== null && _doc_activeElement !== void 0 ? _doc_activeElement : doc.body;
  var _ref;
  let dataTransfer = (_ref = typeof clipboardData == "string" ? getClipboardDataFromString(doc, clipboardData) : clipboardData) !== null && _ref !== void 0 ? _ref : await readDataTransferFromClipboard(doc).catch(() => {
    throw new Error("`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.");
  });
  this.dispatchUIEvent(target, "paste", { clipboardData: dataTransfer });
}
function getClipboardDataFromString(doc, text) {
  let dt2 = createDataTransfer(getWindow(doc));
  return dt2.setData("text", text), dt2;
}
function parseKeyDef2(pointerMap, keys2) {
  let defs = [];
  do {
    let { descriptor, consumedLength, releasePrevious, releaseSelf = true } = readNextDescriptor(keys2, "pointer"), keyDef = pointerMap.find((p32) => p32.name === descriptor);
    keyDef && defs.push({ keyDef, releasePrevious, releaseSelf }), keys2 = keys2.slice(consumedLength);
  } while (keys2);
  return defs;
}
async function pointer(input2) {
  let { pointerMap } = this.config, actions = [];
  (Array.isArray(input2) ? input2 : [input2]).forEach((actionInput) => {
    typeof actionInput == "string" ? actions.push(...parseKeyDef2(pointerMap, actionInput)) : "keys" in actionInput ? actions.push(...parseKeyDef2(pointerMap, actionInput.keys).map((i4) => ({ ...actionInput, ...i4 }))) : actions.push(actionInput);
  });
  for (let i4 = 0; i4 < actions.length; i4++) await wait(this.config), await pointerAction(this, actions[i4]);
  this.system.pointer.resetClickCount();
}
async function pointerAction(instance, action) {
  var _previousPosition_caret, _previousPosition_caret1;
  let pointerName = "pointerName" in action && action.pointerName ? action.pointerName : "keyDef" in action ? instance.system.pointer.getPointerName(action.keyDef) : "mouse", previousPosition = instance.system.pointer.getPreviousPosition(pointerName);
  var _action_target, _action_coords, _action_node, _action_offset;
  let position = { target: (_action_target = action.target) !== null && _action_target !== void 0 ? _action_target : getPrevTarget(instance, previousPosition), coords: (_action_coords = action.coords) !== null && _action_coords !== void 0 ? _action_coords : previousPosition == null ? void 0 : previousPosition.coords, caret: { node: (_action_node = action.node) !== null && _action_node !== void 0 ? _action_node : hasCaretPosition(action) || previousPosition == null || (_previousPosition_caret = previousPosition.caret) === null || _previousPosition_caret === void 0 ? void 0 : _previousPosition_caret.node, offset: (_action_offset = action.offset) !== null && _action_offset !== void 0 ? _action_offset : hasCaretPosition(action) || previousPosition == null || (_previousPosition_caret1 = previousPosition.caret) === null || _previousPosition_caret1 === void 0 ? void 0 : _previousPosition_caret1.offset } };
  "keyDef" in action ? (instance.system.pointer.isKeyPressed(action.keyDef) && (setLevelRef(instance, ApiLevel.Trigger), await instance.system.pointer.release(instance, action.keyDef, position)), action.releasePrevious || (setLevelRef(instance, ApiLevel.Trigger), await instance.system.pointer.press(instance, action.keyDef, position), action.releaseSelf && (setLevelRef(instance, ApiLevel.Trigger), await instance.system.pointer.release(instance, action.keyDef, position)))) : (setLevelRef(instance, ApiLevel.Trigger), await instance.system.pointer.move(instance, pointerName, position));
}
function hasCaretPosition(action) {
  var _action_target, _ref;
  return !!((_ref = (_action_target = action.target) !== null && _action_target !== void 0 ? _action_target : action.node) !== null && _ref !== void 0 ? _ref : action.offset !== void 0);
}
function getPrevTarget(instance, position) {
  if (!position) throw new Error("This pointer has no previous position. Provide a target property!");
  var _position_target;
  return (_position_target = position.target) !== null && _position_target !== void 0 ? _position_target : instance.config.document.body;
}
async function clear(element) {
  if (!isEditable(element) || isDisabled2(element)) throw new Error("clear()` is only supported on editable elements.");
  if (focusElement(element), element.ownerDocument.activeElement !== element) throw new Error("The element to be cleared could not be focused.");
  if (selectAll(element), !isAllSelected(element)) throw new Error("The element content to be cleared could not be selected.");
  input(this, element, "", "deleteContentBackward");
}
async function selectOptions(select, values) {
  return selectOptionsBase.call(this, true, select, values);
}
async function deselectOptions(select, values) {
  return selectOptionsBase.call(this, false, select, values);
}
async function selectOptionsBase(newValue, select, values) {
  if (!newValue && !select.multiple) throw getConfig22().getElementError("Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.", select);
  let valArray = Array.isArray(values) ? values : [values], allOptions = Array.from(select.querySelectorAll('option, [role="option"]')), selectedOptions = valArray.map((val) => {
    if (typeof val != "string" && allOptions.includes(val)) return val;
    {
      let matchingOption = allOptions.find((o3) => o3.value === val || o3.innerHTML === val);
      if (matchingOption) return matchingOption;
      throw getConfig22().getElementError(`Value "${String(val)}" not found in options`, select);
    }
  }).filter((option) => !isDisabled2(option));
  if (isDisabled2(select) || !selectedOptions.length) return;
  let selectOption = (option) => {
    option.selected = newValue, this.dispatchUIEvent(select, "input", { bubbles: true, cancelable: false, composed: true }), this.dispatchUIEvent(select, "change");
  };
  if (isElementType(select, "select")) if (select.multiple) for (let option of selectedOptions) {
    let withPointerEvents = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, option);
    withPointerEvents && (this.dispatchUIEvent(option, "pointerover"), this.dispatchUIEvent(select, "pointerenter"), this.dispatchUIEvent(option, "mouseover"), this.dispatchUIEvent(select, "mouseenter"), this.dispatchUIEvent(option, "pointermove"), this.dispatchUIEvent(option, "mousemove"), this.dispatchUIEvent(option, "pointerdown"), this.dispatchUIEvent(option, "mousedown")), focusElement(select), withPointerEvents && (this.dispatchUIEvent(option, "pointerup"), this.dispatchUIEvent(option, "mouseup")), selectOption(option), withPointerEvents && this.dispatchUIEvent(option, "click"), await wait(this.config);
  }
  else if (selectedOptions.length === 1) {
    let withPointerEvents = this.config.pointerEventsCheck === 0 ? true : hasPointerEvents(this, select);
    withPointerEvents ? await this.click(select) : focusElement(select), selectOption(selectedOptions[0]), withPointerEvents && (this.dispatchUIEvent(select, "pointerover"), this.dispatchUIEvent(select, "pointerenter"), this.dispatchUIEvent(select, "mouseover"), this.dispatchUIEvent(select, "mouseenter"), this.dispatchUIEvent(select, "pointerup"), this.dispatchUIEvent(select, "mouseup"), this.dispatchUIEvent(select, "click")), await wait(this.config);
  } else throw getConfig22().getElementError("Cannot select multiple options on a non-multiple select", select);
  else if (select.getAttribute("role") === "listbox") for (let option of selectedOptions) await this.click(option), await this.unhover(option);
  else throw getConfig22().getElementError("Cannot select options on elements that are neither select nor listbox elements", select);
}
async function type3(element, text, { skipClick = this.config.skipClick, skipAutoClose = this.config.skipAutoClose, initialSelectionStart, initialSelectionEnd } = {}) {
  element.disabled || (skipClick || await this.click(element), initialSelectionStart !== void 0 && setSelectionRange(element, initialSelectionStart, initialSelectionEnd ?? initialSelectionStart), await this.keyboard(text), skipAutoClose || await releaseAllKeys(this));
}
var fakeFiles = Symbol("files and value properties are mocked");
function restoreProperty(obj, prop, descriptor) {
  descriptor ? Object.defineProperty(obj, prop, descriptor) : delete obj[prop];
}
function setFiles(el, files) {
  var _el_fakeFiles;
  (_el_fakeFiles = el[fakeFiles]) === null || _el_fakeFiles === void 0 || _el_fakeFiles.restore();
  let typeDescr = Object.getOwnPropertyDescriptor(el, "type"), valueDescr = Object.getOwnPropertyDescriptor(el, "value"), filesDescr = Object.getOwnPropertyDescriptor(el, "files");
  function restore() {
    restoreProperty(el, "type", typeDescr), restoreProperty(el, "value", valueDescr), restoreProperty(el, "files", filesDescr);
  }
  el[fakeFiles] = { restore }, Object.defineProperties(el, { files: { configurable: true, get: () => files }, value: { configurable: true, get: () => files.length ? `C:\\fakepath\\${files[0].name}` : "", set(v6) {
    if (v6 === "") restore();
    else {
      var _valueDescr_set;
      valueDescr == null || (_valueDescr_set = valueDescr.set) === null || _valueDescr_set === void 0 || _valueDescr_set.call(el, v6);
    }
  } }, type: { configurable: true, get: () => "file", set(v6) {
    v6 !== "file" && (restore(), el.type = v6);
  } } });
}
async function upload(element, fileOrFiles) {
  let input2 = isElementType(element, "label") ? element.control : element;
  if (!input2 || !isElementType(input2, "input", { type: "file" })) throw new TypeError(`The ${input2 === element ? "given" : "associated"} ${input2 == null ? void 0 : input2.tagName} element does not accept file uploads`);
  if (isDisabled2(element)) return;
  let files = (Array.isArray(fileOrFiles) ? fileOrFiles : [fileOrFiles]).filter((file) => !this.config.applyAccept || isAcceptableFile(file, input2.accept)).slice(0, input2.multiple ? void 0 : 1), fileDialog = () => {
    var _input_files;
    files.length === ((_input_files = input2.files) === null || _input_files === void 0 ? void 0 : _input_files.length) && files.every((f42, i4) => {
      var _input_files2;
      return f42 === ((_input_files2 = input2.files) === null || _input_files2 === void 0 ? void 0 : _input_files2.item(i4));
    }) || (setFiles(input2, createFileList(getWindow(element), files)), this.dispatchUIEvent(input2, "input"), this.dispatchUIEvent(input2, "change"));
  };
  input2.addEventListener("fileDialog", fileDialog), await this.click(element), input2.removeEventListener("fileDialog", fileDialog);
}
function isAcceptableFile(file, accept) {
  if (!accept) return true;
  let wildcards = ["audio/*", "image/*", "video/*"];
  return accept.split(",").some((acceptToken) => acceptToken.startsWith(".") ? file.name.endsWith(acceptToken) : wildcards.includes(acceptToken) ? file.type.startsWith(acceptToken.substr(0, acceptToken.length - 1)) : file.type === acceptToken);
}
var userEventApi = { click, dblClick, tripleClick, hover, unhover, tab, keyboard, copy, cut, paste, pointer, clear, deselectOptions, selectOptions, type: type3, upload };
function wrapAsync(implementation) {
  return getConfig22().asyncWrapper(implementation);
}
var defaultOptionsDirect = { applyAccept: true, autoModify: true, delay: 0, document: globalThis.document, keyboardMap: defaultKeyMap, pointerMap: defaultKeyMap2, pointerEventsCheck: PointerEventsCheckLevel.EachApiCall, skipAutoClose: false, skipClick: false, skipHover: false, writeToClipboard: false, advanceTimers: () => Promise.resolve() };
var defaultOptionsSetup = { ...defaultOptionsDirect, writeToClipboard: true };
function createConfig(options2 = {}, defaults = defaultOptionsSetup, node) {
  let document2 = getDocument2(options2, node, defaults);
  return { ...defaults, ...options2, document: document2 };
}
function setupMain(options2 = {}) {
  let config3 = createConfig(options2);
  prepareDocument(config3.document);
  var _config_document_defaultView;
  let view = (_config_document_defaultView = config3.document.defaultView) !== null && _config_document_defaultView !== void 0 ? _config_document_defaultView : globalThis.window;
  return attachClipboardStubToView(view), createInstance(config3).api;
}
function setupDirect({ keyboardState, pointerState, ...options2 } = {}, node) {
  let config3 = createConfig(options2, defaultOptionsDirect, node);
  prepareDocument(config3.document);
  var _ref;
  let system = (_ref = pointerState ?? keyboardState) !== null && _ref !== void 0 ? _ref : new System();
  return { api: createInstance(config3, system).api, system };
}
function setupSub(options2) {
  return createInstance({ ...this.config, ...options2 }, this.system).api;
}
function wrapAndBindImpl(instance, impl) {
  function method(...args2) {
    return setLevelRef(instance, ApiLevel.Call), wrapAsync(() => impl.apply(instance, args2).then(async (ret) => (await wait(instance.config), ret)));
  }
  return Object.defineProperty(method, "name", { get: () => impl.name }), method;
}
function createInstance(config3, system = new System()) {
  let instance = {};
  return Object.assign(instance, { config: config3, dispatchEvent: dispatchEvent.bind(instance), dispatchUIEvent: dispatchUIEvent.bind(instance), system, levelRefs: {}, ...userEventApi }), { instance, api: { ...Object.fromEntries(Object.entries(userEventApi).map(([name2, api]) => [name2, wrapAndBindImpl(instance, api)])), setup: setupSub.bind(instance) } };
}
function getDocument2(options2, node, defaults) {
  var _options_document, _ref;
  return (_ref = (_options_document = options2.document) !== null && _options_document !== void 0 ? _options_document : node && getDocumentFromNode(node)) !== null && _ref !== void 0 ? _ref : defaults.document;
}
var directApi_exports = {};
__export2(directApi_exports, { clear: () => clear2, click: () => click2, copy: () => copy2, cut: () => cut2, dblClick: () => dblClick2, deselectOptions: () => deselectOptions2, hover: () => hover2, keyboard: () => keyboard2, paste: () => paste2, pointer: () => pointer2, selectOptions: () => selectOptions2, tab: () => tab2, tripleClick: () => tripleClick2, type: () => type4, unhover: () => unhover2, upload: () => upload2 });
function clear2(element) {
  return setupDirect().api.clear(element);
}
function click2(element, options2 = {}) {
  return setupDirect(options2, element).api.click(element);
}
function copy2(options2 = {}) {
  return setupDirect(options2).api.copy();
}
function cut2(options2 = {}) {
  return setupDirect(options2).api.cut();
}
function dblClick2(element, options2 = {}) {
  return setupDirect(options2).api.dblClick(element);
}
function deselectOptions2(select, values, options2 = {}) {
  return setupDirect(options2).api.deselectOptions(select, values);
}
function hover2(element, options2 = {}) {
  return setupDirect(options2).api.hover(element);
}
async function keyboard2(text, options2 = {}) {
  let { api, system } = setupDirect(options2);
  return api.keyboard(text).then(() => system);
}
async function pointer2(input2, options2 = {}) {
  let { api, system } = setupDirect(options2);
  return api.pointer(input2).then(() => system);
}
function paste2(clipboardData, options2) {
  return setupDirect(options2).api.paste(clipboardData);
}
function selectOptions2(select, values, options2 = {}) {
  return setupDirect(options2).api.selectOptions(select, values);
}
function tripleClick2(element, options2 = {}) {
  return setupDirect(options2).api.tripleClick(element);
}
function type4(element, text, options2 = {}) {
  return setupDirect(options2, element).api.type(element, text, options2);
}
function unhover2(element, options2 = {}) {
  let { api, system } = setupDirect(options2);
  return system.pointer.setMousePosition({ target: element }), api.unhover(element);
}
function upload2(element, fileOrFiles, options2 = {}) {
  return setupDirect(options2).api.upload(element, fileOrFiles);
}
function tab2(options2 = {}) {
  return setupDirect().api.tab(options2);
}
var userEvent = { ...directApi_exports, setup: setupMain };
function dedent(templ) {
  for (var values = [], _i = 1; _i < arguments.length; _i++) values[_i - 1] = arguments[_i];
  var strings = Array.from(typeof templ == "string" ? [templ] : templ);
  strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var indentLengths = strings.reduce(function(arr, str) {
    var matches3 = str.match(/\n([\t ]+|(?!\s).)/g);
    return matches3 ? arr.concat(matches3.map(function(match) {
      var _a2, _b;
      return (_b = (_a2 = match.match(/[\t ]/g)) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0;
    })) : arr;
  }, []);
  if (indentLengths.length) {
    var pattern_1 = new RegExp(`
[	 ]{` + Math.min.apply(Math, indentLengths) + "}", "g");
    strings = strings.map(function(str) {
      return str.replace(pattern_1, `
`);
    });
  }
  strings[0] = strings[0].replace(/^\r?\n/, "");
  var string = strings[0];
  return values.forEach(function(value2, i4) {
    var endentations = string.match(/(?:^|\n)( *)$/), endentation = endentations ? endentations[1] : "", indentedValue = value2;
    typeof value2 == "string" && value2.includes(`
`) && (indentedValue = String(value2).split(`
`).map(function(str, i22) {
      return i22 === 0 ? str : "" + endentation + str;
    }).join(`
`)), string += indentedValue + strings[i4 + 1];
  }), string;
}
var esm_default = dedent;
var testingLibrary = instrument({ ...dom_esm_exports }, { intercept: (method, path) => path[0] === "fireEvent" || method.startsWith("find") || method.startsWith("waitFor") });
testingLibrary.screen = new Proxy(testingLibrary.screen, { get(target, prop, receiver) {
  return n.warn(esm_default`
          You are using Testing Library's \`screen\` object. Use \`within(canvasElement)\` instead.
          More info: https://storybook.js.org/docs/essentials/interactions
        `), Reflect.get(target, prop, receiver);
} });
var { buildQueries: buildQueries2, configure: configure2, createEvent: createEvent3, fireEvent: fireEvent2, findAllByAltText: findAllByAltText2, findAllByDisplayValue: findAllByDisplayValue2, findAllByLabelText: findAllByLabelText2, findAllByPlaceholderText: findAllByPlaceholderText2, findAllByRole: findAllByRole2, findAllByTestId: findAllByTestId2, findAllByText: findAllByText2, findAllByTitle: findAllByTitle2, findByAltText: findByAltText2, findByDisplayValue: findByDisplayValue2, findByLabelText: findByLabelText2, findByPlaceholderText: findByPlaceholderText2, findByRole: findByRole2, findByTestId: findByTestId2, findByText: findByText2, findByTitle: findByTitle2, getAllByAltText: getAllByAltText2, getAllByDisplayValue: getAllByDisplayValue2, getAllByLabelText: getAllByLabelText2, getAllByPlaceholderText: getAllByPlaceholderText2, getAllByRole: getAllByRole2, getAllByTestId: getAllByTestId2, getAllByText: getAllByText2, getAllByTitle: getAllByTitle2, getByAltText: getByAltText2, getByDisplayValue: getByDisplayValue2, getByLabelText: getByLabelText2, getByPlaceholderText: getByPlaceholderText2, getByRole: getByRole2, getByTestId: getByTestId2, getByText: getByText2, getByTitle: getByTitle2, getConfig: getConfig3, getDefaultNormalizer: getDefaultNormalizer2, getElementError: getElementError2, getNodeText: getNodeText2, getQueriesForElement: getQueriesForElement2, getRoles: getRoles2, getSuggestedQuery: getSuggestedQuery2, isInaccessible: isInaccessible2, logDOM: logDOM2, logRoles: logRoles2, prettyDOM: prettyDOM2, queries: queries2, queryAllByAltText: queryAllByAltText2, queryAllByAttribute: queryAllByAttribute2, queryAllByDisplayValue: queryAllByDisplayValue2, queryAllByLabelText: queryAllByLabelText2, queryAllByPlaceholderText: queryAllByPlaceholderText2, queryAllByRole: queryAllByRole2, queryAllByTestId: queryAllByTestId2, queryAllByText: queryAllByText2, queryAllByTitle: queryAllByTitle2, queryByAltText: queryByAltText2, queryByAttribute: queryByAttribute2, queryByDisplayValue: queryByDisplayValue2, queryByLabelText: queryByLabelText2, queryByPlaceholderText: queryByPlaceholderText2, queryByRole: queryByRole2, queryByTestId: queryByTestId2, queryByText: queryByText2, queryByTitle: queryByTitle2, queryHelpers: queryHelpers2, screen: screen2, waitFor: waitFor2, waitForElementToBeRemoved: waitForElementToBeRemoved2, within, prettyFormat: prettyFormat2 } = testingLibrary;
var { userEvent: userEvent2 } = instrument({ userEvent }, { intercept: true });
var { expect: expect3 } = instrument({ expect: expect2 }, { getKeys: (obj, depth) => {
  let privateApi = ["assert", "__methods", "__flags", "_obj"];
  if (obj.constructor === Assertion) {
    let keys2 = Object.keys(Object.getPrototypeOf(obj)).filter((it2) => !privateApi.includes(it2));
    return depth > 2 ? keys2 : [...keys2, "not"];
  }
  return Object.keys(obj);
}, intercept: (method) => method !== "expect" });
var resetAllMocksLoader = ({ parameters }) => {
  var _a2, _b, _c;
  ((_a2 = parameters == null ? void 0 : parameters.test) == null ? void 0 : _a2.mockReset) === true ? resetAllMocks() : ((_b = parameters == null ? void 0 : parameters.test) == null ? void 0 : _b.clearMocks) === true ? clearAllMocks() : ((_c = parameters == null ? void 0 : parameters.test) == null ? void 0 : _c.restoreMocks) !== false && restoreAllMocks();
};
var traverseArgs = (value2, depth = 0, key2) => {
  var _a2;
  if (depth > 5 || value2 == null) return value2;
  if (isMockFunction(value2)) return key2 && value2.mockName(key2), value2;
  if (typeof value2 == "function" && "isAction" in value2 && value2.isAction && !("implicit" in value2 && value2.implicit)) {
    let mock = fn22(value2);
    return key2 && mock.mockName(key2), mock;
  }
  if (Array.isArray(value2)) return depth++, value2.map((item) => traverseArgs(item, depth));
  if (typeof value2 == "object" && value2.constructor === Object) {
    depth++;
    for (let [k22, v6] of Object.entries(value2)) ((_a2 = Object.getOwnPropertyDescriptor(value2, k22)) == null ? void 0 : _a2.writable) && (value2[k22] = traverseArgs(v6, depth, k22));
    return value2;
  }
  return value2;
};
var nameSpiesAndWrapActionsInSpies = ({ initialArgs }) => {
  traverseArgs(initialArgs);
};
var enhanceContext = (context) => {
  globalThis.HTMLElement && context.canvasElement instanceof globalThis.HTMLElement && (context.canvas = within(context.canvasElement));
};
scope.__STORYBOOK_TEST_LOADERS__ = [resetAllMocksLoader, nameSpiesAndWrapActionsInSpies, enhanceContext];
scope.__STORYBOOK_TEST_ON_MOCK_CALL__ = onMockCall;
export {
  buildQueries2 as buildQueries,
  clearAllMocks,
  configure2 as configure,
  createEvent3 as createEvent,
  expect3 as expect,
  findAllByAltText2 as findAllByAltText,
  findAllByDisplayValue2 as findAllByDisplayValue,
  findAllByLabelText2 as findAllByLabelText,
  findAllByPlaceholderText2 as findAllByPlaceholderText,
  findAllByRole2 as findAllByRole,
  findAllByTestId2 as findAllByTestId,
  findAllByText2 as findAllByText,
  findAllByTitle2 as findAllByTitle,
  findByAltText2 as findByAltText,
  findByDisplayValue2 as findByDisplayValue,
  findByLabelText2 as findByLabelText,
  findByPlaceholderText2 as findByPlaceholderText,
  findByRole2 as findByRole,
  findByTestId2 as findByTestId,
  findByText2 as findByText,
  findByTitle2 as findByTitle,
  fireEvent2 as fireEvent,
  fn22 as fn,
  getAllByAltText2 as getAllByAltText,
  getAllByDisplayValue2 as getAllByDisplayValue,
  getAllByLabelText2 as getAllByLabelText,
  getAllByPlaceholderText2 as getAllByPlaceholderText,
  getAllByRole2 as getAllByRole,
  getAllByTestId2 as getAllByTestId,
  getAllByText2 as getAllByText,
  getAllByTitle2 as getAllByTitle,
  getByAltText2 as getByAltText,
  getByDisplayValue2 as getByDisplayValue,
  getByLabelText2 as getByLabelText,
  getByPlaceholderText2 as getByPlaceholderText,
  getByRole2 as getByRole,
  getByTestId2 as getByTestId,
  getByText2 as getByText,
  getByTitle2 as getByTitle,
  getConfig3 as getConfig,
  getDefaultNormalizer2 as getDefaultNormalizer,
  getElementError2 as getElementError,
  getNodeText2 as getNodeText,
  getQueriesForElement2 as getQueriesForElement,
  getRoles2 as getRoles,
  getSuggestedQuery2 as getSuggestedQuery,
  isInaccessible2 as isInaccessible,
  isMockFunction,
  logDOM2 as logDOM,
  logRoles2 as logRoles,
  mocked,
  mocks,
  onMockCall,
  prettyDOM2 as prettyDOM,
  prettyFormat2 as prettyFormat,
  queries2 as queries,
  queryAllByAltText2 as queryAllByAltText,
  queryAllByAttribute2 as queryAllByAttribute,
  queryAllByDisplayValue2 as queryAllByDisplayValue,
  queryAllByLabelText2 as queryAllByLabelText,
  queryAllByPlaceholderText2 as queryAllByPlaceholderText,
  queryAllByRole2 as queryAllByRole,
  queryAllByTestId2 as queryAllByTestId,
  queryAllByText2 as queryAllByText,
  queryAllByTitle2 as queryAllByTitle,
  queryByAltText2 as queryByAltText,
  queryByAttribute2 as queryByAttribute,
  queryByDisplayValue2 as queryByDisplayValue,
  queryByLabelText2 as queryByLabelText,
  queryByPlaceholderText2 as queryByPlaceholderText,
  queryByRole2 as queryByRole,
  queryByTestId2 as queryByTestId,
  queryByText2 as queryByText,
  queryByTitle2 as queryByTitle,
  queryHelpers2 as queryHelpers,
  resetAllMocks,
  restoreAllMocks,
  screen2 as screen,
  spyOn2 as spyOn,
  traverseArgs,
  userEvent2 as userEvent,
  waitFor2 as waitFor,
  waitForElementToBeRemoved2 as waitForElementToBeRemoved,
  within
};
//# sourceMappingURL=@storybook_test.js.map
